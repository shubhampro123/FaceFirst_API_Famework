<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <title>report_03_11_23.html</title>
    <link href="assets/style.css" rel="stylesheet" type="text/css"/></head>
  <body onLoad="init()">
    <script>/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
 * You can obtain one at http://mozilla.org/MPL/2.0/. */


function toArray(iter) {
    if (iter === null) {
        return null;
    }
    return Array.prototype.slice.call(iter);
}

function find(selector, elem) { // eslint-disable-line no-redeclare
    if (!elem) {
        elem = document;
    }
    return elem.querySelector(selector);
}

function findAll(selector, elem) {
    if (!elem) {
        elem = document;
    }
    return toArray(elem.querySelectorAll(selector));
}

function sortColumn(elem) {
    toggleSortStates(elem);
    const colIndex = toArray(elem.parentNode.childNodes).indexOf(elem);
    let key;
    if (elem.classList.contains('result')) {
        key = keyResult;
    } else if (elem.classList.contains('links')) {
        key = keyLink;
    } else {
        key = keyAlpha;
    }
    sortTable(elem, key(colIndex));
}

function showAllExtras() { // eslint-disable-line no-unused-vars
    findAll('.col-result').forEach(showExtras);
}

function hideAllExtras() { // eslint-disable-line no-unused-vars
    findAll('.col-result').forEach(hideExtras);
}

function showExtras(colresultElem) {
    const extras = colresultElem.parentNode.nextElementSibling;
    const expandcollapse = colresultElem.firstElementChild;
    extras.classList.remove('collapsed');
    expandcollapse.classList.remove('expander');
    expandcollapse.classList.add('collapser');
}

function hideExtras(colresultElem) {
    const extras = colresultElem.parentNode.nextElementSibling;
    const expandcollapse = colresultElem.firstElementChild;
    extras.classList.add('collapsed');
    expandcollapse.classList.remove('collapser');
    expandcollapse.classList.add('expander');
}

function showFilters() {
    let visibleString = getQueryParameter('visible') || 'all';
    visibleString = visibleString.toLowerCase();
    const checkedItems = visibleString.split(',');

    const filterItems = document.getElementsByClassName('filter');
    for (let i = 0; i < filterItems.length; i++) {
        filterItems[i].hidden = false;

        if (visibleString != 'all') {
            filterItems[i].checked = checkedItems.includes(filterItems[i].getAttribute('data-test-result'));
            filterTable(filterItems[i]);
        }
    }
}

function addCollapse() {
    // Add links for show/hide all
    const resulttable = find('table#results-table');
    const showhideall = document.createElement('p');
    showhideall.innerHTML = '<a href="javascript:showAllExtras()">Show all details</a> / ' +
                            '<a href="javascript:hideAllExtras()">Hide all details</a>';
    resulttable.parentElement.insertBefore(showhideall, resulttable);

    // Add show/hide link to each result
    findAll('.col-result').forEach(function(elem) {
        const collapsed = getQueryParameter('collapsed') || 'Passed';
        const extras = elem.parentNode.nextElementSibling;
        const expandcollapse = document.createElement('span');
        if (extras.classList.contains('collapsed')) {
            expandcollapse.classList.add('expander');
        } else if (collapsed.includes(elem.innerHTML)) {
            extras.classList.add('collapsed');
            expandcollapse.classList.add('expander');
        } else {
            expandcollapse.classList.add('collapser');
        }
        elem.appendChild(expandcollapse);

        elem.addEventListener('click', function(event) {
            if (event.currentTarget.parentNode.nextElementSibling.classList.contains('collapsed')) {
                showExtras(event.currentTarget);
            } else {
                hideExtras(event.currentTarget);
            }
        });
    });
}

function getQueryParameter(name) {
    const match = RegExp('[?&]' + name + '=([^&]*)').exec(window.location.search);
    return match && decodeURIComponent(match[1].replace(/\+/g, ' '));
}

function init () { // eslint-disable-line no-unused-vars
    resetSortHeaders();

    addCollapse();

    showFilters();

    sortColumn(find('.initial-sort'));

    findAll('.sortable').forEach(function(elem) {
        elem.addEventListener('click',
            function() {
                sortColumn(elem);
            }, false);
    });
}

function sortTable(clicked, keyFunc) {
    const rows = findAll('.results-table-row');
    const reversed = !clicked.classList.contains('asc');
    const sortedRows = sort(rows, keyFunc, reversed);
    /* Whole table is removed here because browsers acts much slower
     * when appending existing elements.
     */
    const thead = document.getElementById('results-table-head');
    document.getElementById('results-table').remove();
    const parent = document.createElement('table');
    parent.id = 'results-table';
    parent.appendChild(thead);
    sortedRows.forEach(function(elem) {
        parent.appendChild(elem);
    });
    document.getElementsByTagName('BODY')[0].appendChild(parent);
}

function sort(items, keyFunc, reversed) {
    const sortArray = items.map(function(item, i) {
        return [keyFunc(item), i];
    });

    sortArray.sort(function(a, b) {
        const keyA = a[0];
        const keyB = b[0];

        if (keyA == keyB) return 0;

        if (reversed) {
            return keyA < keyB ? 1 : -1;
        } else {
            return keyA > keyB ? 1 : -1;
        }
    });

    return sortArray.map(function(item) {
        const index = item[1];
        return items[index];
    });
}

function keyAlpha(colIndex) {
    return function(elem) {
        return elem.childNodes[1].childNodes[colIndex].firstChild.data.toLowerCase();
    };
}

function keyLink(colIndex) {
    return function(elem) {
        const dataCell = elem.childNodes[1].childNodes[colIndex].firstChild;
        return dataCell == null ? '' : dataCell.innerText.toLowerCase();
    };
}

function keyResult(colIndex) {
    return function(elem) {
        const strings = ['Error', 'Failed', 'Rerun', 'XFailed', 'XPassed',
            'Skipped', 'Passed'];
        return strings.indexOf(elem.childNodes[1].childNodes[colIndex].firstChild.data);
    };
}

function resetSortHeaders() {
    findAll('.sort-icon').forEach(function(elem) {
        elem.parentNode.removeChild(elem);
    });
    findAll('.sortable').forEach(function(elem) {
        const icon = document.createElement('div');
        icon.className = 'sort-icon';
        icon.textContent = 'vvv';
        elem.insertBefore(icon, elem.firstChild);
        elem.classList.remove('desc', 'active');
        elem.classList.add('asc', 'inactive');
    });
}

function toggleSortStates(elem) {
    //if active, toggle between asc and desc
    if (elem.classList.contains('active')) {
        elem.classList.toggle('asc');
        elem.classList.toggle('desc');
    }

    //if inactive, reset all other functions and add ascending active
    if (elem.classList.contains('inactive')) {
        resetSortHeaders();
        elem.classList.remove('inactive');
        elem.classList.add('active');
    }
}

function isAllRowsHidden(value) {
    return value.hidden == false;
}

function filterTable(elem) { // eslint-disable-line no-unused-vars
    const outcomeAtt = 'data-test-result';
    const outcome = elem.getAttribute(outcomeAtt);
    const classOutcome = outcome + ' results-table-row';
    const outcomeRows = document.getElementsByClassName(classOutcome);

    for(let i = 0; i < outcomeRows.length; i++){
        outcomeRows[i].hidden = !elem.checked;
    }

    const rows = findAll('.results-table-row').filter(isAllRowsHidden);
    const allRowsHidden = rows.length == 0 ? true : false;
    const notFoundMessage = document.getElementById('not-found-message');
    notFoundMessage.hidden = !allRowsHidden;
}
</script>
    <h1>report_03_11_23.html</h1>
    <p>Report generated on 03-Nov-2023 at 15:32:31 by <a href="https://pypi.python.org/pypi/pytest-html">pytest-html</a> v3.2.0</p>
    <h2>Environment</h2>
    <table id="environment">
      <tr>
        <td>JAVA_HOME</td>
        <td>C:\Program Files\Java\jdk-17</td></tr>
      <tr>
        <td>Packages</td>
        <td>{"pluggy": "1.0.0", "pytest": "7.2.1"}</td></tr>
      <tr>
        <td>Platform</td>
        <td>Windows-10-10.0.19045-SP0</td></tr>
      <tr>
        <td>Plugins</td>
        <td>{"allure-pytest": "2.12.0", "html": "3.2.0", "metadata": "2.0.4"}</td></tr>
      <tr>
        <td>Python</td>
        <td>3.11.4</td></tr></table>
    <h2>Summary</h2>
    <p>127 tests ran in 17.91 seconds. </p>
    <p class="filter" hidden="true">(Un)check the boxes to filter the results.</p><input checked="true" class="filter" data-test-result="passed" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="passed">0 passed</span>, <input checked="true" class="filter" data-test-result="skipped" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="skipped">0 skipped</span>, <input checked="true" class="filter" data-test-result="failed" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="failed">127 failed</span>, <input checked="true" class="filter" data-test-result="error" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="error">0 errors</span>, <input checked="true" class="filter" data-test-result="xfailed" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="xfailed">0 expected failures</span>, <input checked="true" class="filter" data-test-result="xpassed" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="xpassed">0 unexpected passes</span>
    <h2>Results</h2>
    <table id="results-table">
      <thead id="results-table-head">
        <tr>
          <th class="sortable result initial-sort" col="result">Result</th>
          <th class="sortable" col="name">Test</th>
          <th class="sortable" col="duration">Duration</th>
          <th class="sortable links" col="links">Links</th></tr>
        <tr hidden="true" id="not-found-message">
          <th colspan="4">No results found. Try to check the filters</th></tr></thead>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Account_Module_API/test_account_api.py::Test_Account_api::test_Account_Test_01</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Account_Module_API.Account_API_Methods.Account_API_Methods object at 0x0000028EE9EEB010&gt;<br/><br/>    def verify_get_all_account(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Account_Module_API\Account_API_Methods.py:23: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 2, time = &#x27;start_time&#x27;, sheet_name = &#x27;Account_Test_Result&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Account_Test_Result&#x27;<br/>row_num = 2, column_no = 9, data = &#x27;15:32:15&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EE9DE1690&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Account_Module_API.test_account_api.Test_Account_api object at 0x0000028ED7C864D0&gt;<br/><br/>    def test_Account_Test_01(self):<br/>        self.logger.info(&quot;test_Account_Test_01  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Account_API_Methods(self.logger).verify_get_all_account():<br/><br/>All_API_Test_Cases_Package\Account_Module_API\test_account_api.py:10: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Account_Module_API.Account_API_Methods.Account_API_Methods object at 0x0000028EE9EEB010&gt;<br/><br/>    def verify_get_all_account(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_all_account()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            print(response_list)<br/>            for x in range(len(self.json_response)):<br/>                result.append(self.json_response[x][&quot;accountId&quot;] != &quot;&quot;)<br/>    <br/>            if response_validation(self.response) and False not in result:<br/>                excel_result(self.row,&quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row,&quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row,&quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Account_Module_API\Account_API_Methods.py:49: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>[Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_account_api.py:9 test_Account_Test_01  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Account_Module_API/test_account_api.py::Test_Account_api::test_Account_Test_02</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Account_Module_API.Account_API_Methods.Account_API_Methods object at 0x0000028EEA024450&gt;<br/><br/>    def verify_get_account_by_account_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Account_Module_API\Account_API_Methods.py:59: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 3, time = &#x27;start_time&#x27;, sheet_name = &#x27;Account_Test_Result&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Account_Test_Result&#x27;<br/>row_num = 3, column_no = 9, data = &#x27;15:32:15&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028ED964A890&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Account_Module_API.test_account_api.Test_Account_api object at 0x0000028ED9618CD0&gt;<br/><br/>    def test_Account_Test_02(self):<br/>        self.logger.info(&quot;test_Account_Test_02  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Account_API_Methods(self.logger).verify_get_account_by_account_id():<br/><br/>All_API_Test_Cases_Package\Account_Module_API\test_account_api.py:17: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Account_Module_API.Account_API_Methods.Account_API_Methods object at 0x0000028EEA024450&gt;<br/><br/>    def verify_get_account_by_account_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            ex_account_id = get_all_account()[1][0][&quot;accountId&quot;]<br/>            response_list = get_single_account_by_account_id(ex_account_id)<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            ac_account_id = self.json_response[&quot;accountId&quot;]<br/>            print(response_list)<br/>            if response_validation(self.response) and ex_account_id == ac_account_id:<br/>                excel_result(self.row,&quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row,&quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row,&quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Account_Module_API\Account_API_Methods.py:84: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>[Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_account_api.py:16 test_Account_Test_02  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Account_Module_API/test_account_api.py::Test_Account_api::test_Account_Test_03</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Account_Module_API.Account_API_Methods.Account_API_Methods object at 0x0000028ED9655390&gt;<br/><br/>    def verify_account_stations_by_account_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Account_Module_API\Account_API_Methods.py:94: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 4, time = &#x27;start_time&#x27;, sheet_name = &#x27;Account_Test_Result&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Account_Test_Result&#x27;<br/>row_num = 4, column_no = 9, data = &#x27;15:32:15&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028ED9685A50&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Account_Module_API.test_account_api.Test_Account_api object at 0x0000028EE9DCAF10&gt;<br/><br/>    def test_Account_Test_03(self):<br/>        self.logger.info(&quot;test_Account_Test_03  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Account_API_Methods(self.logger).verify_account_stations_by_account_id():<br/><br/>All_API_Test_Cases_Package\Account_Module_API\test_account_api.py:24: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Account_Module_API.Account_API_Methods.Account_API_Methods object at 0x0000028ED9655390&gt;<br/><br/>    def verify_account_stations_by_account_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            account_id = get_all_account()[1][0][&quot;accountId&quot;]<br/>            print(&quot;account_id&quot;,account_id)<br/>            response_list = get_account_stations_by_account_id(account_id)<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            print(response_list)<br/>            if response_validation(self.response):<br/>                excel_result(self.row,&quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row,&quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row,&quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Account_Module_API\Account_API_Methods.py:119: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>[Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_account_api.py:23 test_Account_Test_03  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/All_Module_Search_API/test_all_module_search_api.py::Test_All_Module_Search_api::test_All_Module_Search_Test_01</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.All_Module_Search_API.All_module_search_API_Methods.All_Module_Search_API_Methods object at 0x0000028EE9F8EA50&gt;<br/><br/>    def verify_events_search(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:30: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 2, time = &#x27;start_time&#x27;, sheet_name = &#x27;All_Module_Search_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>sheet_name = &#x27;All_Module_Search_Test_Results&#x27;, row_num = 2, column_no = 9, data = &#x27;15:32:16&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA0ADA50&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.All_Module_Search_API.test_all_module_search_api.Test_All_Module_Search_api object at 0x0000028EE9DD2B90&gt;<br/><br/>    def test_All_Module_Search_Test_01(self):<br/>        self.logger.info(&quot;test_All_Module_Search_Test_01  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if All_Module_Search_API_Methods(self.logger).verify_events_search():<br/><br/>All_API_Test_Cases_Package\All_Module_Search_API\test_all_module_search_api.py:11: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.All_Module_Search_API.All_module_search_API_Methods.All_Module_Search_API_Methods object at 0x0000028EE9F8EA50&gt;<br/><br/>    def verify_events_search(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_event_search()<br/>            self.response = response_list[0]<br/>            print(self.response)<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:55: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>[Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_all_module_search_api.py:10 test_All_Module_Search_Test_01  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/All_Module_Search_API/test_all_module_search_api.py::Test_All_Module_Search_api::test_All_Module_Search_Test_02</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.All_Module_Search_API.All_module_search_API_Methods.All_Module_Search_API_Methods object at 0x0000028EEA048F90&gt;<br/><br/>    def verify_users_search(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:65: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 3, time = &#x27;start_time&#x27;, sheet_name = &#x27;All_Module_Search_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>sheet_name = &#x27;All_Module_Search_Test_Results&#x27;, row_num = 3, column_no = 9, data = &#x27;15:32:16&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EE8A51690&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.All_Module_Search_API.test_all_module_search_api.Test_All_Module_Search_api object at 0x0000028EE9DD28D0&gt;<br/><br/>    def test_All_Module_Search_Test_02(self):<br/>        self.logger.info(&quot;test_All_Module_Search_Test_02  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if All_Module_Search_API_Methods(self.logger).verify_users_search():<br/><br/>All_API_Test_Cases_Package\All_Module_Search_API\test_all_module_search_api.py:18: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.All_Module_Search_API.All_module_search_API_Methods.All_Module_Search_API_Methods object at 0x0000028EEA048F90&gt;<br/><br/>    def verify_users_search(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_user_by_id_request()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:86: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_all_module_search_api.py:17 test_All_Module_Search_Test_02  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/All_Module_Search_API/test_all_module_search_api.py::Test_All_Module_Search_api::test_All_Module_Search_Test_03</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.All_Module_Search_API.All_module_search_API_Methods.All_Module_Search_API_Methods object at 0x0000028EEA0B4B90&gt;<br/><br/>    def verify_notes_search(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:96: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 4, time = &#x27;start_time&#x27;, sheet_name = &#x27;All_Module_Search_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>sheet_name = &#x27;All_Module_Search_Test_Results&#x27;, row_num = 4, column_no = 9, data = &#x27;15:32:16&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EE9DB9CD0&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.All_Module_Search_API.test_all_module_search_api.Test_All_Module_Search_api object at 0x0000028EE9DD3F10&gt;<br/><br/>    def test_All_Module_Search_Test_03(self):<br/>        self.logger.info(&quot;test_All_Module_Search_Test_03  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if All_Module_Search_API_Methods(self.logger).verify_notes_search():<br/><br/>All_API_Test_Cases_Package\All_Module_Search_API\test_all_module_search_api.py:25: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.All_Module_Search_API.All_module_search_API_Methods.All_Module_Search_API_Methods object at 0x0000028EEA0B4B90&gt;<br/><br/>    def verify_notes_search(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            create_notes_request()<br/>            response_list = notes_search_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:120: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>[Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_all_module_search_api.py:24 test_All_Module_Search_Test_03  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/All_Module_Search_API/test_all_module_search_api.py::Test_All_Module_Search_api::test_All_Module_Search_Test_04</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.All_Module_Search_API.All_module_search_API_Methods.All_Module_Search_API_Methods object at 0x0000028EEA0F9010&gt;<br/><br/>    def verify_visitors_search(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:130: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 5, time = &#x27;start_time&#x27;, sheet_name = &#x27;All_Module_Search_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>sheet_name = &#x27;All_Module_Search_Test_Results&#x27;, row_num = 5, column_no = 9, data = &#x27;15:32:16&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA0AC910&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.All_Module_Search_API.test_all_module_search_api.Test_All_Module_Search_api object at 0x0000028EE9DD0190&gt;<br/><br/>    def test_All_Module_Search_Test_04(self):<br/>        self.logger.info(&quot;test_All_Module_Search_Test_04  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if All_Module_Search_API_Methods(self.logger).verify_visitors_search():<br/><br/>All_API_Test_Cases_Package\All_Module_Search_API\test_all_module_search_api.py:32: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.All_Module_Search_API.All_module_search_API_Methods.All_Module_Search_API_Methods object at 0x0000028EEA0F9010&gt;<br/><br/>    def verify_visitors_search(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            create_notes_request()<br/>            response_list = get_visitors_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:154: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>[Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_all_module_search_api.py:31 test_All_Module_Search_Test_04  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/All_Module_Search_API/test_all_module_search_api.py::Test_All_Module_Search_api::test_All_Module_Search_Test_05</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.All_Module_Search_API.All_module_search_API_Methods.All_Module_Search_API_Methods object at 0x0000028EE9EF80D0&gt;<br/><br/>    def verify_enrollments_search(self):<br/>        result = []<br/>        try:<br/>            self.row = 6<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:164: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 6, time = &#x27;start_time&#x27;, sheet_name = &#x27;All_Module_Search_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>sheet_name = &#x27;All_Module_Search_Test_Results&#x27;, row_num = 6, column_no = 9, data = &#x27;15:32:16&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA0B5D90&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.All_Module_Search_API.test_all_module_search_api.Test_All_Module_Search_api object at 0x0000028EE9DD1110&gt;<br/><br/>    def test_All_Module_Search_Test_05(self):<br/>        self.logger.info(&quot;test_All_Module_Search_Test_05  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if All_Module_Search_API_Methods(self.logger).verify_enrollments_search():<br/><br/>All_API_Test_Cases_Package\All_Module_Search_API\test_all_module_search_api.py:39: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.All_Module_Search_API.All_module_search_API_Methods.All_Module_Search_API_Methods object at 0x0000028EE9EF80D0&gt;<br/><br/>    def verify_enrollments_search(self):<br/>        result = []<br/>        try:<br/>            self.row = 6<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_enrollment_group_by_id()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:188: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_all_module_search_api.py:38 test_All_Module_Search_Test_05  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/All_Module_Search_API/test_all_module_search_api.py::Test_All_Module_Search_api::test_All_Module_Search_Test_06</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.All_Module_Search_API.All_module_search_API_Methods.All_Module_Search_API_Methods object at 0x0000028EE9DBBE50&gt;<br/><br/>    def verify_visitor_search_jobs_search(self):<br/>        result = []<br/>        try:<br/>            self.row = 7<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:198: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 7, time = &#x27;start_time&#x27;, sheet_name = &#x27;All_Module_Search_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>sheet_name = &#x27;All_Module_Search_Test_Results&#x27;, row_num = 7, column_no = 9, data = &#x27;15:32:16&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028ED96567D0&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.All_Module_Search_API.test_all_module_search_api.Test_All_Module_Search_api object at 0x0000028EE9DE2210&gt;<br/><br/>    def test_All_Module_Search_Test_06(self):<br/>        self.logger.info(&quot;test_All_Module_Search_Test_06  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if All_Module_Search_API_Methods(self.logger).verify_visitor_search_jobs_search():<br/><br/>All_API_Test_Cases_Package\All_Module_Search_API\test_all_module_search_api.py:46: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.All_Module_Search_API.All_module_search_API_Methods.All_Module_Search_API_Methods object at 0x0000028EE9DBBE50&gt;<br/><br/>    def verify_visitor_search_jobs_search(self):<br/>        result = []<br/>        try:<br/>            self.row = 7<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_visitor_search_jobs_search()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:222: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_all_module_search_api.py:45 test_All_Module_Search_Test_06  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Audit_Module_API/test_audit_api.py::Test_Account_api::test_Account_Test_01</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Audit_Module_API.Audit_API_Methods.Audit_API_Methods object at 0x0000028EE9EF9450&gt;<br/><br/>    def verify_audit_approvers(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Audit_Module_API\Audit_API_Methods.py:27: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 2, time = &#x27;start_time&#x27;, sheet_name = &#x27;Audit_logReport_Test_Result&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Audit_logReport_Test_Result&#x27;<br/>row_num = 2, column_no = 9, data = &#x27;15:32:16&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028ED95D6390&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Audit_Module_API.test_audit_api.Test_Account_api object at 0x0000028EE9DB1CD0&gt;<br/><br/>    def test_Account_Test_01(self):<br/>        self.logger.info(&quot;test_Account_Test_01  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Audit_API_Methods(self.logger).verify_audit_approvers():<br/><br/>All_API_Test_Cases_Package\Audit_Module_API\test_audit_api.py:10: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Audit_Module_API.Audit_API_Methods.Audit_API_Methods object at 0x0000028EE9EF9450&gt;<br/><br/>    def verify_audit_approvers(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_all_account()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            print(response_list)<br/>            for x in range(len(self.json_response)):<br/>                result.append(self.json_response[x][&quot;accountId&quot;] != &quot;&quot;)<br/>    <br/>            if response_validation(self.response) and False not in result:<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Audit_Module_API\Audit_API_Methods.py:55: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>[Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_audit_api.py:9 test_Account_Test_01  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Audit_Module_API/test_audit_api.py::Test_Account_api::test_Account_Test_02</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Audit_Module_API.Audit_API_Methods.Audit_API_Methods object at 0x0000028EE9DAA1D0&gt;<br/><br/>    def verify_audit_users(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Audit_Module_API\Audit_API_Methods.py:65: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 3, time = &#x27;start_time&#x27;, sheet_name = &#x27;Audit_logReport_Test_Result&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Audit_logReport_Test_Result&#x27;<br/>row_num = 3, column_no = 9, data = &#x27;15:32:16&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028ED9663310&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Audit_Module_API.test_audit_api.Test_Account_api object at 0x0000028EE9DB11D0&gt;<br/><br/>    def test_Account_Test_02(self):<br/>        self.logger.info(&quot;test_Account_Test_02  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Audit_API_Methods(self.logger).verify_audit_users():<br/><br/>All_API_Test_Cases_Package\Audit_Module_API\test_audit_api.py:17: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Audit_Module_API.Audit_API_Methods.Audit_API_Methods object at 0x0000028EE9DAA1D0&gt;<br/><br/>    def verify_audit_users(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_all_account_user()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            print(response_list)<br/>            for x in range(len(self.json_response)):<br/>                result.append(self.json_response[x][&quot;accountId&quot;] != &quot;&quot;)<br/>    <br/>            if response_validation(self.response) and False not in result:<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Audit_Module_API\Audit_API_Methods.py:93: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>[Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_audit_api.py:16 test_Account_Test_02  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Audit_Module_API/test_audit_api.py::Test_Account_api::test_Account_Test_03</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Audit_Module_API.Audit_API_Methods.Audit_API_Methods object at 0x0000028EE9DB9850&gt;<br/><br/>    def verify_audit_login(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Audit_Module_API\Audit_API_Methods.py:103: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 4, time = &#x27;start_time&#x27;, sheet_name = &#x27;Audit_logReport_Test_Result&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Audit_logReport_Test_Result&#x27;<br/>row_num = 4, column_no = 9, data = &#x27;15:32:16&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EE9F057D0&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Audit_Module_API.test_audit_api.Test_Account_api object at 0x0000028EE9DB0510&gt;<br/><br/>    def test_Account_Test_03(self):<br/>        self.logger.info(&quot;test_Account_Test_03  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Audit_API_Methods(self.logger).verify_audit_login():<br/><br/>All_API_Test_Cases_Package\Audit_Module_API\test_audit_api.py:24: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Audit_Module_API.Audit_API_Methods.Audit_API_Methods object at 0x0000028EE9DB9850&gt;<br/><br/>    def verify_audit_login(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_all_account_login()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            print(response_list)<br/>            for x in range(len(self.json_response)):<br/>                result.append(self.json_response[x][&quot;accountId&quot;] != &quot;&quot;)<br/>    <br/>            if response_validation(self.response) and False not in result:<br/>                excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Audit_Module_API\Audit_API_Methods.py:131: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>[Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_audit_api.py:23 test_Account_Test_03  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Audit_Module_API/test_audit_api.py::Test_Account_api::test_Account_Test_04</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Audit_Module_API.Audit_API_Methods.Audit_API_Methods object at 0x0000028EEA09FD10&gt;<br/><br/>    def verify_get_audit_logins(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Audit_Module_API\Audit_API_Methods.py:141: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 5, time = &#x27;start_time&#x27;, sheet_name = &#x27;Audit_logReport_Test_Result&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Audit_logReport_Test_Result&#x27;<br/>row_num = 5, column_no = 9, data = &#x27;15:32:16&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA074390&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Audit_Module_API.test_audit_api.Test_Account_api object at 0x0000028EE9DB0110&gt;<br/><br/>    def test_Account_Test_04(self):<br/>        self.logger.info(&quot;test_Account_Test_04  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Audit_API_Methods(self.logger).verify_get_audit_logins():<br/><br/>All_API_Test_Cases_Package\Audit_Module_API\test_audit_api.py:31: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Audit_Module_API.Audit_API_Methods.Audit_API_Methods object at 0x0000028EEA09FD10&gt;<br/><br/>    def verify_get_audit_logins(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_all_login_users()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response) and False not in result:<br/>                excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Audit_Module_API\Audit_API_Methods.py:165: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>[Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_audit_api.py:30 test_Account_Test_04  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Audit_Module_API/test_audit_api.py::Test_Account_api::test_Account_Test_05</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Audit_Module_API.Audit_API_Methods.Audit_API_Methods object at 0x0000028EE9F10650&gt;<br/><br/>    def verify_audit_threshold_changes(self):<br/>        result = []<br/>        try:<br/>            self.row = 6<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Audit_Module_API\Audit_API_Methods.py:175: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 6, time = &#x27;start_time&#x27;, sheet_name = &#x27;Audit_logReport_Test_Result&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Audit_logReport_Test_Result&#x27;<br/>row_num = 6, column_no = 9, data = &#x27;15:32:16&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EE9DB2190&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Audit_Module_API.test_audit_api.Test_Account_api object at 0x0000028EE9DB18D0&gt;<br/><br/>    def test_Account_Test_05(self):<br/>        self.logger.info(&quot;test_Account_Test_05  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Audit_API_Methods(self.logger).verify_audit_threshold_changes():<br/><br/>All_API_Test_Cases_Package\Audit_Module_API\test_audit_api.py:38: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Audit_Module_API.Audit_API_Methods.Audit_API_Methods object at 0x0000028EE9F10650&gt;<br/><br/>    def verify_audit_threshold_changes(self):<br/>        result = []<br/>        try:<br/>            self.row = 6<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = verify_audit_threshold_changes()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            print(response_list)<br/>            for x in range(len(self.json_response)):<br/>                result.append(self.json_response[x][&quot;accountId&quot;] != &quot;&quot;)<br/>    <br/>            if response_validation(self.response) and False not in result:<br/>                excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Audit_Module_API\Audit_API_Methods.py:203: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>[Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_audit_api.py:37 test_Account_Test_05  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Detect_Face_Module_API/test_detect_faces_api.py::Test_detect_face_api::test_tags_Test_01</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Detect_Face_Module_API.Detect_Faces_API_Methods.Detect_Face_API_Methods object at 0x0000028EEA088550&gt;<br/><br/>    def verify_post_detect_face_with_valid_data(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Detect_Face_Module_API\Detect_Faces_API_Methods.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 2, time = &#x27;start_time&#x27;, sheet_name = &#x27;Detect_Face_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Detect_Face_Test_Results&#x27;<br/>row_num = 2, column_no = 9, data = &#x27;15:32:16&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA074090&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Detect_Face_Module_API.test_detect_faces_api.Test_detect_face_api object at 0x0000028EE9DEEF50&gt;<br/><br/>    def test_tags_Test_01(self):<br/>        self.logger.info(&quot;test_detect_face_Test_01  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Detect_Face_API_Methods(self.logger).verify_post_detect_face_with_valid_data():<br/><br/>All_API_Test_Cases_Package\Detect_Face_Module_API\test_detect_faces_api.py:10: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Detect_Face_Module_API.Detect_Faces_API_Methods.Detect_Face_API_Methods object at 0x0000028EEA088550&gt;<br/><br/>    def verify_post_detect_face_with_valid_data(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = create_detect_face_request(self.row)<br/>    <br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>    <br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Detect_Face_Module_API\Detect_Faces_API_Methods.py:49: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_detect_faces_api.py:9 test_detect_face_Test_01  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Enrollment_Data_Module_API/test_enrollment_data_api.py::Test_Enrollment_Data_api::test_Enrollment_Data_Test_01</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Enrollment_Data_Module_API.Enrollment_Data_API_Methods.Enrollment_Data_API_Methods object at 0x0000028EEA09D510&gt;<br/><br/>    def verify_get_enrollment_data_by_enrollment_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Enrollment_Data_Module_API\Enrollment_Data_API_Methods.py:24: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 2, time = &#x27;start_time&#x27;, sheet_name = &#x27;Enrollment_Data_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Enrollment_Data_Test_Results&#x27;<br/>row_num = 2, column_no = 9, data = &#x27;15:32:17&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EE8A1A290&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Enrollment_Data_Module_API.test_enrollment_data_api.Test_Enrollment_Data_api object at 0x0000028EE9DC9D10&gt;<br/><br/>    def test_Enrollment_Data_Test_01(self):<br/>        self.logger.info(&quot;test_Enrollment_Data_Test_01  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Enrollment_Data_API_Methods(self.logger).verify_get_enrollment_data_by_enrollment_id():<br/><br/>All_API_Test_Cases_Package\Enrollment_Data_Module_API\test_enrollment_data_api.py:10: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Data_Module_API.Enrollment_Data_API_Methods.Enrollment_Data_API_Methods object at 0x0000028EEA09D510&gt;<br/><br/>    def verify_get_enrollment_data_by_enrollment_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            token = login_token()<br/>            # case_id = create_enrollment_request()[3]<br/>            case_id = get_case_id(token)<br/>            print(case_id)<br/>            response_list = get_enrollment_data_by_enrollment_id_request(case_id)<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row,&quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row,&quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row,&quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Enrollment_Data_Module_API\Enrollment_Data_API_Methods.py:50: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>[Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_enrollment_data_api.py:9 test_Enrollment_Data_Test_01  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Enrollment_Data_Module_API/test_enrollment_data_api.py::Test_Enrollment_Data_api::test_Enrollment_Data_Test_02</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Enrollment_Data_Module_API.Enrollment_Data_API_Methods.Enrollment_Data_API_Methods object at 0x0000028EEA084A10&gt;<br/><br/>    def verify_get_enrollment_data_by_page_number_and_batch_size(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Enrollment_Data_Module_API\Enrollment_Data_API_Methods.py:60: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 3, time = &#x27;start_time&#x27;, sheet_name = &#x27;Enrollment_Data_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Enrollment_Data_Test_Results&#x27;<br/>row_num = 3, column_no = 9, data = &#x27;15:32:17&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA10FF50&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Enrollment_Data_Module_API.test_enrollment_data_api.Test_Enrollment_Data_api object at 0x0000028EE9DC8590&gt;<br/><br/>    def test_Enrollment_Data_Test_02(self):<br/>        self.logger.info(&quot;test_Enrollment_Data_Test_02  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Enrollment_Data_API_Methods(self.logger).verify_get_enrollment_data_by_page_number_and_batch_size():<br/><br/>All_API_Test_Cases_Package\Enrollment_Data_Module_API\test_enrollment_data_api.py:17: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Data_Module_API.Enrollment_Data_API_Methods.Enrollment_Data_API_Methods object at 0x0000028EEA084A10&gt;<br/><br/>    def verify_get_enrollment_data_by_page_number_and_batch_size(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_enrollment_data_by_page_number_and_batch_size_request()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row,&quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row,&quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row,&quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Enrollment_Data_Module_API\Enrollment_Data_API_Methods.py:82: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>[Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_enrollment_data_api.py:16 test_Enrollment_Data_Test_02  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Enrollment_Data_Module_API/test_enrollment_data_api.py::Test_Enrollment_Data_api::test_Enrollment_Data_Test_03</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Enrollment_Data_Module_API.Enrollment_Data_API_Methods.Enrollment_Data_API_Methods object at 0x0000028EEA0C2E10&gt;<br/><br/>    def verify_get_enrollment_data_count(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Enrollment_Data_Module_API\Enrollment_Data_API_Methods.py:92: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 4, time = &#x27;start_time&#x27;, sheet_name = &#x27;Enrollment_Data_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Enrollment_Data_Test_Results&#x27;<br/>row_num = 4, column_no = 9, data = &#x27;15:32:17&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EE9D73C90&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Enrollment_Data_Module_API.test_enrollment_data_api.Test_Enrollment_Data_api object at 0x0000028EE9DCA650&gt;<br/><br/>    def test_Enrollment_Data_Test_03(self):<br/>        self.logger.info(&quot;test_Enrollment_Data_Test_03  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Enrollment_Data_API_Methods(self.logger).verify_get_enrollment_data_count():<br/><br/>All_API_Test_Cases_Package\Enrollment_Data_Module_API\test_enrollment_data_api.py:24: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Data_Module_API.Enrollment_Data_API_Methods.Enrollment_Data_API_Methods object at 0x0000028EEA0C2E10&gt;<br/><br/>    def verify_get_enrollment_data_count(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_enrollment_data_count_request()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row,&quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row,&quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row,&quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Enrollment_Data_Module_API\Enrollment_Data_API_Methods.py:114: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>[Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_enrollment_data_api.py:23 test_Enrollment_Data_Test_03  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Enrollment_Group_Data_Module_API/test_enrollment_group_data_api.py::Test_Enrollment_Group_Datat_api::test_Enrollment_Group_Data_Test_01</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Enrollment_Group_Data_Module_API.Enrollment_Group_Data_API_Methods.Enrollment_Group_Data_API_Methods object at 0x0000028EE9F10550&gt;<br/><br/>    def verify_get_enrollment_group_data_by_enrollment_group_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Enrollment_Group_Data_Module_API\Enrollment_Group_Data_API_Methods.py:25: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 2, time = &#x27;start_time&#x27;, sheet_name = &#x27;Enrollment_Group_Data_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Enrollment_Group_Data_Results&#x27;<br/>row_num = 2, column_no = 9, data = &#x27;15:32:17&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA0B6110&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Enrollment_Group_Data_Module_API.test_enrollment_group_data_api.Test_Enrollment_Group_Datat_api object at 0x0000028EE9DB8850&gt;<br/><br/>    def test_Enrollment_Group_Data_Test_01(self):<br/>        self.logger.info(&quot;test_Enrollment_Group_Data_Test_01  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Enrollment_Group_Data_API_Methods(self.logger).verify_get_enrollment_group_data_by_enrollment_group_id():<br/><br/>All_API_Test_Cases_Package\Enrollment_Group_Data_Module_API\test_enrollment_group_data_api.py:11: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Group_Data_Module_API.Enrollment_Group_Data_API_Methods.Enrollment_Group_Data_API_Methods object at 0x0000028EE9F10550&gt;<br/><br/>    def verify_get_enrollment_group_data_by_enrollment_group_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            c_group_id = get_all_enrollment_group_request()[1][2][&quot;id&quot;]<br/>            print(c_group_id)<br/>            response_list = get_enrollment_group_data_by_enrollment_group_id_request(c_group_id)<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row,&quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row,&quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row,&quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Enrollment_Group_Data_Module_API\Enrollment_Group_Data_API_Methods.py:49: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>[Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_enrollment_group_data_api.py:10 test_Enrollment_Group_Data_Test_01  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Enrollment_Group_Data_Module_API/test_enrollment_group_data_api.py::Test_Enrollment_Group_Datat_api::test_Enrollment_Group_Data_Test_02</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Enrollment_Group_Data_Module_API.Enrollment_Group_Data_API_Methods.Enrollment_Group_Data_API_Methods object at 0x0000028EEA09E3D0&gt;<br/><br/>    def verify_get_enrollment_group_data_by_page_number_and_batch_size(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Enrollment_Group_Data_Module_API\Enrollment_Group_Data_API_Methods.py:59: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 3, time = &#x27;start_time&#x27;, sheet_name = &#x27;Enrollment_Group_Data_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Enrollment_Group_Data_Results&#x27;<br/>row_num = 3, column_no = 9, data = &#x27;15:32:17&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EE9EFA550&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Enrollment_Group_Data_Module_API.test_enrollment_group_data_api.Test_Enrollment_Group_Datat_api object at 0x0000028EE9DB9290&gt;<br/><br/>    def test_Enrollment_Group_Data_Test_02(self):<br/>        self.logger.info(&quot;test_Enrollment_Group_Data_Test_02  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Enrollment_Group_Data_API_Methods(self.logger).verify_get_enrollment_group_data_by_page_number_and_batch_size():<br/><br/>All_API_Test_Cases_Package\Enrollment_Group_Data_Module_API\test_enrollment_group_data_api.py:18: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Group_Data_Module_API.Enrollment_Group_Data_API_Methods.Enrollment_Group_Data_API_Methods object at 0x0000028EEA09E3D0&gt;<br/><br/>    def verify_get_enrollment_group_data_by_page_number_and_batch_size(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_enrollment_group_data_by_page_number_and_batch_size_request()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row,&quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row,&quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row,&quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Enrollment_Group_Data_Module_API\Enrollment_Group_Data_API_Methods.py:81: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>[Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_enrollment_group_data_api.py:17 test_Enrollment_Group_Data_Test_02  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Enrollment_Group_Data_Module_API/test_enrollment_group_data_api.py::Test_Enrollment_Group_Datat_api::test_Enrollment_Group_Data_Test_03</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Enrollment_Group_Data_Module_API.Enrollment_Group_Data_API_Methods.Enrollment_Group_Data_API_Methods object at 0x0000028EE9DA9F50&gt;<br/><br/>    def verify_get_enrollment_group_data_count(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Enrollment_Group_Data_Module_API\Enrollment_Group_Data_API_Methods.py:91: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 4, time = &#x27;start_time&#x27;, sheet_name = &#x27;Enrollment_Group_Data_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Enrollment_Group_Data_Results&#x27;<br/>row_num = 4, column_no = 9, data = &#x27;15:32:17&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EE9D97510&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Enrollment_Group_Data_Module_API.test_enrollment_group_data_api.Test_Enrollment_Group_Datat_api object at 0x0000028EE9DB98D0&gt;<br/><br/>    def test_Enrollment_Group_Data_Test_03(self):<br/>        self.logger.info(&quot;test_Enrollment_Group_Data_Test_03  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Enrollment_Group_Data_API_Methods(self.logger).verify_get_enrollment_group_data_count():<br/><br/>All_API_Test_Cases_Package\Enrollment_Group_Data_Module_API\test_enrollment_group_data_api.py:25: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Group_Data_Module_API.Enrollment_Group_Data_API_Methods.Enrollment_Group_Data_API_Methods object at 0x0000028EE9DA9F50&gt;<br/><br/>    def verify_get_enrollment_group_data_count(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_enrollment_group_data_count_request()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row,&quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row,&quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row,&quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Enrollment_Group_Data_Module_API\Enrollment_Group_Data_API_Methods.py:113: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>[Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_enrollment_group_data_api.py:24 test_Enrollment_Group_Data_Test_03  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Enrollment_Group_Module_API/test_enrollment_group_api.py::Test_enrollment_group_api::test_enrollment_group_Test_01</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x0000028EE9D73090&gt;<br/><br/>    def verify_the_get_all_enrollment_group(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:29: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 2, time = &#x27;start_time&#x27;, sheet_name = &#x27;Enrollment_Group_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Enrollment_Group_Test_Results&#x27;<br/>row_num = 2, column_no = 9, data = &#x27;15:32:17&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EE8A2D190&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Enrollment_Group_Module_API.test_enrollment_group_api.Test_enrollment_group_api object at 0x0000028EDA2EF890&gt;<br/><br/>    def test_enrollment_group_Test_01(self):<br/>        self.logger.info(&quot;test_enrollment_group_Test_01  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Enrollment_Group_API_Methods(self.logger).verify_the_get_all_enrollment_group():<br/><br/>All_API_Test_Cases_Package\Enrollment_Group_Module_API\test_enrollment_group_api.py:11: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x0000028EE9D73090&gt;<br/><br/>    def verify_the_get_all_enrollment_group(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_all_enrollment_group_request()<br/>            self.response = response_list<br/>            print(response_validation(self.response))<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:52: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_enrollment_group_api.py:10 test_enrollment_group_Test_01  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Enrollment_Group_Module_API/test_enrollment_group_api.py::Test_enrollment_group_api::test_enrollment_group_Test_02</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x0000028EEA2BC850&gt;<br/><br/>    def verify_the_enrollment_groups_is_created_with_valid_data(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:62: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 3, time = &#x27;start_time&#x27;, sheet_name = &#x27;Enrollment_Group_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Enrollment_Group_Test_Results&#x27;<br/>row_num = 3, column_no = 9, data = &#x27;15:32:17&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EE9DB8C50&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Enrollment_Group_Module_API.test_enrollment_group_api.Test_enrollment_group_api object at 0x0000028ED9640C50&gt;<br/><br/>    def test_enrollment_group_Test_02(self):<br/>        self.logger.info(&quot;test_enrollment_group_Test_02  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Enrollment_Group_API_Methods(self.logger).verify_the_enrollment_groups_is_created_with_valid_data():<br/><br/>All_API_Test_Cases_Package\Enrollment_Group_Module_API\test_enrollment_group_api.py:18: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x0000028EEA2BC850&gt;<br/><br/>    def verify_the_enrollment_groups_is_created_with_valid_data(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = create_enrollment_group_request(self.row)<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.act_msg = self.json_response[&quot;message&quot;]<br/>            exp_id = response_list[3]<br/>            self.exp_msg = Read_Expected_Enrollment_Group_Response_msg().create_enrollment_group_msg(exp_id)<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:89: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_enrollment_group_api.py:17 test_enrollment_group_Test_02  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Enrollment_Group_Module_API/test_enrollment_group_api.py::Test_enrollment_group_api::test_enrollment_group_Test_03</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x0000028EE9FB16D0&gt;<br/><br/>    def verify_the_get_single_enrollment_group(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:99: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 4, time = &#x27;start_time&#x27;, sheet_name = &#x27;Enrollment_Group_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Enrollment_Group_Test_Results&#x27;<br/>row_num = 4, column_no = 9, data = &#x27;15:32:17&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EE9DCBF50&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Enrollment_Group_Module_API.test_enrollment_group_api.Test_enrollment_group_api object at 0x0000028EE9D82290&gt;<br/><br/>    def test_enrollment_group_Test_03(self):<br/>        self.logger.info(&quot;test_enrollment_group_Test_03  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Enrollment_Group_API_Methods(self.logger).verify_the_get_single_enrollment_group():<br/><br/>All_API_Test_Cases_Package\Enrollment_Group_Module_API\test_enrollment_group_api.py:25: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x0000028EE9FB16D0&gt;<br/><br/>    def verify_the_get_single_enrollment_group(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_enrollment_group_by_id()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:123: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_enrollment_group_api.py:24 test_enrollment_group_Test_03  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Enrollment_Group_Module_API/test_enrollment_group_api.py::Test_enrollment_group_api::test_enrollment_group_Test_04</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x0000028EEA3ED610&gt;<br/><br/>    def verify_the_update_enrollment_group(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:133: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 5, time = &#x27;start_time&#x27;, sheet_name = &#x27;Enrollment_Group_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Enrollment_Group_Test_Results&#x27;<br/>row_num = 5, column_no = 9, data = &#x27;15:32:17&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA076B90&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Enrollment_Group_Module_API.test_enrollment_group_api.Test_enrollment_group_api object at 0x0000028EE9D81DD0&gt;<br/><br/>    def test_enrollment_group_Test_04(self):<br/>        self.logger.info(&quot;test_enrollment_group_Test_04  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Enrollment_Group_API_Methods(self.logger).verify_the_update_enrollment_group():<br/><br/>All_API_Test_Cases_Package\Enrollment_Group_Module_API\test_enrollment_group_api.py:32: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x0000028EEA3ED610&gt;<br/><br/>    def verify_the_update_enrollment_group(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = update_enrollment_group_request(self.row)<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.act_msg = self.json_response[&quot;message&quot;]<br/>            act_group_id = self.json_response[&quot;data&quot;]<br/>            exp_group_id = response_list[3]<br/>            self.exp_msg = Read_Expected_Enrollment_Group_Response_msg().update_enrollment_group_msg()<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg and act_group_id == exp_group_id:<br/>                excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:161: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_enrollment_group_api.py:31 test_enrollment_group_Test_04  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Enrollment_Group_Module_API/test_enrollment_group_api.py::Test_enrollment_group_api::test_enrollment_group_Test_05</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x0000028EEA0B6E50&gt;<br/><br/>    def verify_remove_a_single_Enrollment_Group_from_collection(self):<br/>        result = []<br/>        try:<br/>            self.row = 6<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:171: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 6, time = &#x27;start_time&#x27;, sheet_name = &#x27;Enrollment_Group_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Enrollment_Group_Test_Results&#x27;<br/>row_num = 6, column_no = 9, data = &#x27;15:32:17&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EE9F1DCD0&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Enrollment_Group_Module_API.test_enrollment_group_api.Test_enrollment_group_api object at 0x0000028EE9D80F10&gt;<br/><br/>    def test_enrollment_group_Test_05(self):<br/>        self.logger.info(&quot;test_enrollment_group_Test_05  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Enrollment_Group_API_Methods(self.logger).verify_remove_a_single_Enrollment_Group_from_collection():<br/><br/>All_API_Test_Cases_Package\Enrollment_Group_Module_API\test_enrollment_group_api.py:39: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x0000028EEA0B6E50&gt;<br/><br/>    def verify_remove_a_single_Enrollment_Group_from_collection(self):<br/>        result = []<br/>        try:<br/>            self.row = 6<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = delete_enrollment_group()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            self.act_msg = self.json_response[&quot;message&quot;]<br/>            exp_id = response_list[2]<br/>            self.exp_msg = Read_Expected_Enrollment_Group_Response_msg().delete_enrollment_group_msg(exp_id)<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:197: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_enrollment_group_api.py:38 test_enrollment_group_Test_05  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Enrollment_Group_Module_API/test_enrollment_group_api.py::Test_enrollment_group_api::test_enrollment_group_Test_06</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x0000028EE9F8D6D0&gt;<br/><br/>    def verify_create_enrollment_group_with_addCaseGroupZone(self):<br/>        result = []<br/>        try:<br/>            self.row = 7<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:207: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 7, time = &#x27;start_time&#x27;, sheet_name = &#x27;Enrollment_Group_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Enrollment_Group_Test_Results&#x27;<br/>row_num = 7, column_no = 9, data = &#x27;15:32:17&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EE9D70290&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Enrollment_Group_Module_API.test_enrollment_group_api.Test_enrollment_group_api object at 0x0000028EE9D80690&gt;<br/><br/>    def test_enrollment_group_Test_06(self):<br/>        self.logger.info(&quot;test_enrollment_group_Test_06  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Enrollment_Group_API_Methods(self.logger).verify_create_enrollment_group_with_addCaseGroupZone():<br/><br/>All_API_Test_Cases_Package\Enrollment_Group_Module_API\test_enrollment_group_api.py:46: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x0000028EE9F8D6D0&gt;<br/><br/>    def verify_create_enrollment_group_with_addCaseGroupZone(self):<br/>        result = []<br/>        try:<br/>            self.row = 7<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = create_enrollment_group_with_addCaseGroupZone_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.act_msg = self.json_response[&quot;result&quot;][&quot;message&quot;]<br/>            account_id = response_list[3]<br/>            cGroupId = response_list[4]<br/>            self.exp_msg = Read_Expected_Enrollment_Group_Response_msg(). \<br/>                create_enrollment_group_with_addCaseGroupZone_msg(cGroupId, account_id)<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:236: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_enrollment_group_api.py:45 test_enrollment_group_Test_06  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Enrollment_Group_Module_API/test_enrollment_group_api.py::Test_enrollment_group_api::test_enrollment_group_Test_07</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x0000028EEA3268D0&gt;<br/><br/>    def verify_removeCaseGroupZone(self):<br/>        result = []<br/>        try:<br/>            self.row = 8<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:246: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 8, time = &#x27;start_time&#x27;, sheet_name = &#x27;Enrollment_Group_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Enrollment_Group_Test_Results&#x27;<br/>row_num = 8, column_no = 9, data = &#x27;15:32:18&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA3EE050&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Enrollment_Group_Module_API.test_enrollment_group_api.Test_enrollment_group_api object at 0x0000028EE9D82C90&gt;<br/><br/>    def test_enrollment_group_Test_07(self):<br/>        self.logger.info(&quot;test_enrollment_group_Test_07  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Enrollment_Group_API_Methods(self.logger).verify_removeCaseGroupZone():<br/><br/>All_API_Test_Cases_Package\Enrollment_Group_Module_API\test_enrollment_group_api.py:53: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x0000028EEA3268D0&gt;<br/><br/>    def verify_removeCaseGroupZone(self):<br/>        result = []<br/>        try:<br/>            self.row = 8<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = remove_enrollment_group_with_removeCaseGroupZone_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.act_msg = self.json_response[&quot;result&quot;][&quot;message&quot;]<br/>            account_id = response_list[3]<br/>            cGroupId = response_list[4]<br/>            self.exp_msg = Read_Expected_Enrollment_Group_Response_msg(). \<br/>                removeCaseGroupZone_msg(cGroupId, account_id)<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_07&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_07&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_07&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:275: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_enrollment_group_api.py:52 test_enrollment_group_Test_07  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Enrollment_Group_Module_API/test_enrollment_group_api.py::Test_enrollment_group_api::test_enrollment_group_Test_08</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x0000028EE9DAA910&gt;<br/><br/>    def verify_addCaseGroupCase(self):<br/>        result = []<br/>        try:<br/>            self.row = 9<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:285: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 9, time = &#x27;start_time&#x27;, sheet_name = &#x27;Enrollment_Group_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Enrollment_Group_Test_Results&#x27;<br/>row_num = 9, column_no = 9, data = &#x27;15:32:18&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EE9D9F950&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Enrollment_Group_Module_API.test_enrollment_group_api.Test_enrollment_group_api object at 0x0000028EE9D82A90&gt;<br/><br/>    def test_enrollment_group_Test_08(self):<br/>        self.logger.info(&quot;test_enrollment_group_Test_08  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Enrollment_Group_API_Methods(self.logger).verify_addCaseGroupCase():<br/><br/>All_API_Test_Cases_Package\Enrollment_Group_Module_API\test_enrollment_group_api.py:60: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x0000028EE9DAA910&gt;<br/><br/>    def verify_addCaseGroupCase(self):<br/>        result = []<br/>        try:<br/>            self.row = 9<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = create_enrollment_group_with_verify_addCaseGroupCase_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.act_msg = self.json_response[&quot;result&quot;][&quot;message&quot;]<br/>            account_id = response_list[3]<br/>            cGroupId = response_list[4]<br/>            self.exp_msg = Read_Expected_Enrollment_Group_Response_msg().addCaseGroupCase_msg(cGroupId, account_id)<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:311: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_enrollment_group_api.py:59 test_enrollment_group_Test_08  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Enrollment_Group_Module_API/test_enrollment_group_api.py::Test_enrollment_group_api::test_enrollment_group_Test_09</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x0000028EE9FAD750&gt;<br/><br/>    def verify_removeCaseGroupCase(self):<br/>        result = []<br/>        try:<br/>            self.row = 10<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:321: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 10, time = &#x27;start_time&#x27;, sheet_name = &#x27;Enrollment_Group_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Enrollment_Group_Test_Results&#x27;<br/>row_num = 10, column_no = 9, data = &#x27;15:32:18&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA23E390&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Enrollment_Group_Module_API.test_enrollment_group_api.Test_enrollment_group_api object at 0x0000028EE9D82ED0&gt;<br/><br/>    def test_enrollment_group_Test_09(self):<br/>        self.logger.info(&quot;test_enrollment_group_Test_09  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Enrollment_Group_API_Methods(self.logger).verify_removeCaseGroupCase():<br/><br/>All_API_Test_Cases_Package\Enrollment_Group_Module_API\test_enrollment_group_api.py:67: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x0000028EE9FAD750&gt;<br/><br/>    def verify_removeCaseGroupCase(self):<br/>        result = []<br/>        try:<br/>            self.row = 10<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = remove_enrollment_group_with_removeCaseGroupCase_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.act_msg = self.json_response[&quot;result&quot;][&quot;message&quot;]<br/>            account_id = response_list[3]<br/>            cGroupId = response_list[4]<br/>            self.exp_msg = Read_Expected_Enrollment_Group_Response_msg().removeCaseGroupCase_msg(cGroupId, account_id)<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_09&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_09&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_09&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:349: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_enrollment_group_api.py:66 test_enrollment_group_Test_09  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Enrollment_Group_Module_API/test_enrollment_group_api.py::Test_enrollment_group_api::test_enrollment_group_Test_10</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x0000028EEA37B890&gt;<br/><br/>    def verify_addAlertGroupCase(self):<br/>        result = []<br/>        try:<br/>            self.row = 11<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:359: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 11, time = &#x27;start_time&#x27;, sheet_name = &#x27;Enrollment_Group_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Enrollment_Group_Test_Results&#x27;<br/>row_num = 11, column_no = 9, data = &#x27;15:32:18&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA23A750&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Enrollment_Group_Module_API.test_enrollment_group_api.Test_enrollment_group_api object at 0x0000028EE9D81E90&gt;<br/><br/>    def test_enrollment_group_Test_10(self):<br/>        self.logger.info(&quot;test_enrollment_group_Test_10  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Enrollment_Group_API_Methods(self.logger).verify_addAlertGroupCase():<br/><br/>All_API_Test_Cases_Package\Enrollment_Group_Module_API\test_enrollment_group_api.py:74: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x0000028EEA37B890&gt;<br/><br/>    def verify_addAlertGroupCase(self):<br/>        result = []<br/>        try:<br/>            self.row = 11<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = remove_enrollment_group_with_addAlertGroupCase_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.act_msg = self.json_response[&quot;result&quot;][&quot;message&quot;]<br/>            cGroupId = response_list[4]<br/>            self.exp_msg = Read_Expected_Enrollment_Group_Response_msg().addAlertGroupCase_msg(cGroupId)<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_10&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_10&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_10&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:386: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_enrollment_group_api.py:73 test_enrollment_group_Test_10  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Enrollment_Group_Module_API/test_enrollment_group_api.py::Test_enrollment_group_api::test_enrollment_group_Test_11</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x0000028EEA3C2CD0&gt;<br/><br/>    def verify_removeAlertGroupCase(self):<br/>        result = []<br/>        try:<br/>            self.row = 12<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:396: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 12, time = &#x27;start_time&#x27;, sheet_name = &#x27;Enrollment_Group_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Enrollment_Group_Test_Results&#x27;<br/>row_num = 12, column_no = 9, data = &#x27;15:32:18&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EE9D9E890&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Enrollment_Group_Module_API.test_enrollment_group_api.Test_enrollment_group_api object at 0x0000028EE9D83ED0&gt;<br/><br/>    def test_enrollment_group_Test_11(self):<br/>        self.logger.info(&quot;test_enrollment_group_Test_11  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Enrollment_Group_API_Methods(self.logger).verify_removeAlertGroupCase():<br/><br/>All_API_Test_Cases_Package\Enrollment_Group_Module_API\test_enrollment_group_api.py:81: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x0000028EEA3C2CD0&gt;<br/><br/>    def verify_removeAlertGroupCase(self):<br/>        result = []<br/>        try:<br/>            self.row = 12<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = remove_enrollment_group_with_removeAlertGroupCase_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.act_msg = self.json_response[&quot;result&quot;][&quot;message&quot;]<br/>            cGroupId = response_list[4]<br/>            self.exp_msg = Read_Expected_Enrollment_Group_Response_msg().removeAlertGroupCase_msg(cGroupId)<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_11&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_11&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_11&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:423: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_enrollment_group_api.py:80 test_enrollment_group_Test_11  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Identify_and_Enroll_Module_API/test_identify_enroll_api.py::Test_identify_enroll_api::test_identify_enroll_Test_01</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000028EE9FAFF90&gt;<br/><br/>    def verify_create_enrollment(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:31: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 2, time = &#x27;start_time&#x27;, sheet_name = &#x27;Identify_Enroll_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Identify_Enroll_Test_Results&#x27;<br/>row_num = 2, column_no = 9, data = &#x27;15:32:18&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA0C0F50&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Identify_and_Enroll_Module_API.test_identify_enroll_api.Test_identify_enroll_api object at 0x0000028EE9D52D50&gt;<br/><br/>    @pytest.mark.p1<br/>    def test_identify_enroll_Test_01(self):<br/>        self.logger.info(&quot;test_identify_enroll_Test_01  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Identify_Enroll_API_Methods(self.logger).verify_create_enrollment():<br/><br/>All_API_Test_Cases_Package\Identify_and_Enroll_Module_API\test_identify_enroll_api.py:14: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000028EE9FAFF90&gt;<br/><br/>    def verify_create_enrollment(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = create_enrollment_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.act_msg = self.json_response[&quot;enroll&quot;][&quot;success&quot;]<br/>            self.exp_msg = Read_identify_enroll_Response_msg().create_enrollment_success_msg();<br/>            if response_validation(self.response) and self:<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:55: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_identify_enroll_api.py:13 test_identify_enroll_Test_01  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Identify_and_Enroll_Module_API/test_identify_enroll_api.py::Test_identify_enroll_api::test_identify_enroll_Test_02</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000028EEA23A790&gt;<br/><br/>    def verify_clear_enrollment_info(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:65: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 3, time = &#x27;start_time&#x27;, sheet_name = &#x27;Identify_Enroll_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Identify_Enroll_Test_Results&#x27;<br/>row_num = 3, column_no = 9, data = &#x27;15:32:18&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA37A950&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Identify_and_Enroll_Module_API.test_identify_enroll_api.Test_identify_enroll_api object at 0x0000028EE9D52850&gt;<br/><br/>    @pytest.mark.p1<br/>    def test_identify_enroll_Test_02(self):<br/>        self.logger.info(&quot;test_identify_enroll_Test_02  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Identify_Enroll_API_Methods(self.logger).verify_clear_enrollment_info():<br/><br/>All_API_Test_Cases_Package\Identify_and_Enroll_Module_API\test_identify_enroll_api.py:22: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000028EEA23A790&gt;<br/><br/>    def verify_clear_enrollment_info(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = clear_enrollment_info_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:87: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_identify_enroll_api.py:21 test_identify_enroll_Test_02  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Identify_and_Enroll_Module_API/test_identify_enroll_api.py::Test_identify_enroll_api::test_identify_enroll_Test_03</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000028EEA3C19D0&gt;<br/><br/>    def verify_query_Enrollment_FaceInfo(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:97: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 4, time = &#x27;start_time&#x27;, sheet_name = &#x27;Identify_Enroll_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Identify_Enroll_Test_Results&#x27;<br/>row_num = 4, column_no = 9, data = &#x27;15:32:18&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028ED9654C90&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Identify_and_Enroll_Module_API.test_identify_enroll_api.Test_identify_enroll_api object at 0x0000028EE9D537D0&gt;<br/><br/>    @pytest.mark.p1<br/>    def test_identify_enroll_Test_03(self):<br/>        self.logger.info(&quot;test_identify_enroll_Test_03  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Identify_Enroll_API_Methods(self.logger).verify_query_Enrollment_FaceInfo():<br/><br/>All_API_Test_Cases_Package\Identify_and_Enroll_Module_API\test_identify_enroll_api.py:30: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000028EEA3C19D0&gt;<br/><br/>    def verify_query_Enrollment_FaceInfo(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = query_Enrollment_FaceInfo_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:119: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_identify_enroll_api.py:29 test_identify_enroll_Test_03  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Identify_and_Enroll_Module_API/test_identify_enroll_api.py::Test_identify_enroll_api::test_identify_enroll_Test_04</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000028EEA32FD10&gt;<br/><br/>    def verify_enrollment_profiles(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:129: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 5, time = &#x27;start_time&#x27;, sheet_name = &#x27;Identify_Enroll_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Identify_Enroll_Test_Results&#x27;<br/>row_num = 5, column_no = 9, data = &#x27;15:32:18&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA0CAA10&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Identify_and_Enroll_Module_API.test_identify_enroll_api.Test_identify_enroll_api object at 0x0000028EE9D53B10&gt;<br/><br/>    @pytest.mark.p1<br/>    def test_identify_enroll_Test_04(self):<br/>        self.logger.info(&quot;test_identify_enroll_Test_04  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Identify_Enroll_API_Methods(self.logger).verify_enrollment_profiles():<br/><br/>All_API_Test_Cases_Package\Identify_and_Enroll_Module_API\test_identify_enroll_api.py:38: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000028EEA32FD10&gt;<br/><br/>    def verify_enrollment_profiles(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_enrollment_profiles_request()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:150: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_identify_enroll_api.py:37 test_identify_enroll_Test_04  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Identify_and_Enroll_Module_API/test_identify_enroll_api.py::Test_identify_enroll_api::test_identify_enroll_Test_05</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000028EEA0C3810&gt;<br/><br/>    def verify_identify_enrollment(self):<br/>        result = []<br/>        try:<br/>            self.row = 6<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:160: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 6, time = &#x27;start_time&#x27;, sheet_name = &#x27;Identify_Enroll_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Identify_Enroll_Test_Results&#x27;<br/>row_num = 6, column_no = 9, data = &#x27;15:32:18&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA074C10&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Identify_and_Enroll_Module_API.test_identify_enroll_api.Test_identify_enroll_api object at 0x0000028EDA352010&gt;<br/><br/>    @pytest.mark.p1<br/>    def test_identify_enroll_Test_05(self):<br/>        self.logger.info(&quot;test_identify_enroll_Test_05  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Identify_Enroll_API_Methods(self.logger).verify_identify_enrollment():<br/><br/>All_API_Test_Cases_Package\Identify_and_Enroll_Module_API\test_identify_enroll_api.py:46: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000028EEA0C3810&gt;<br/><br/>    def verify_identify_enrollment(self):<br/>        result = []<br/>        try:<br/>            self.row = 6<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = identify_enrollment()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:181: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_identify_enroll_api.py:45 test_identify_enroll_Test_05  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Identify_and_Enroll_Module_API/test_identify_enroll_api.py::Test_identify_enroll_api::test_identify_enroll_Test_06</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000028EEA09C6D0&gt;<br/><br/>    def verify_search_enrollments(self):<br/>        result = []<br/>        try:<br/>            self.row = 7<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:191: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 7, time = &#x27;start_time&#x27;, sheet_name = &#x27;Identify_Enroll_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Identify_Enroll_Test_Results&#x27;<br/>row_num = 7, column_no = 9, data = &#x27;15:32:18&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA2C0950&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Identify_and_Enroll_Module_API.test_identify_enroll_api.Test_identify_enroll_api object at 0x0000028EE9D61810&gt;<br/><br/>    @pytest.mark.p1<br/>    def test_identify_enroll_Test_06(self):<br/>        self.logger.info(&quot;test_identify_enroll_Test_06  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Identify_Enroll_API_Methods(self.logger).verify_search_enrollments():<br/><br/>All_API_Test_Cases_Package\Identify_and_Enroll_Module_API\test_identify_enroll_api.py:54: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000028EEA09C6D0&gt;<br/><br/>    def verify_search_enrollments(self):<br/>        result = []<br/>        try:<br/>            self.row = 7<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = search_enrollment_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:213: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_identify_enroll_api.py:53 test_identify_enroll_Test_06  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Identify_and_Enroll_Module_API/test_identify_enroll_api.py::Test_identify_enroll_api::test_identify_enroll_Test_07</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000028EEA0CA2D0&gt;<br/><br/>    def verify_edit_enrollments(self):<br/>        result = []<br/>        try:<br/>            self.row = 8<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:223: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 8, time = &#x27;start_time&#x27;, sheet_name = &#x27;Identify_Enroll_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Identify_Enroll_Test_Results&#x27;<br/>row_num = 8, column_no = 9, data = &#x27;15:32:19&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA2BF650&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Identify_and_Enroll_Module_API.test_identify_enroll_api.Test_identify_enroll_api object at 0x0000028EE9D61590&gt;<br/><br/>    @pytest.mark.p1<br/>    def test_identify_enroll_Test_07(self):<br/>        self.logger.info(&quot;test_identify_enroll_Test_07  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Identify_Enroll_API_Methods(self.logger).verify_edit_enrollments():<br/><br/>All_API_Test_Cases_Package\Identify_and_Enroll_Module_API\test_identify_enroll_api.py:62: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000028EEA0CA2D0&gt;<br/><br/>    def verify_edit_enrollments(self):<br/>        result = []<br/>        try:<br/>            self.row = 8<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = edit_enrollment_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            enroll_id = response_list[3]<br/>            self.act_msg = self.json_response[&quot;message&quot;]<br/>            self.exp_msg = Read_identify_enroll_Response_msg().edit_enrollment_success_msg(enroll_id)<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_07&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_07&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_07&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:248: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_identify_enroll_api.py:61 test_identify_enroll_Test_07  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Identify_and_Enroll_Module_API/test_identify_enroll_api.py::Test_identify_enroll_api::test_identify_enroll_Test_08</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000028EEA327450&gt;<br/><br/>    def verify_delete_enrollments(self):<br/>        result = []<br/>        try:<br/>            self.row = 9<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:258: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 9, time = &#x27;start_time&#x27;, sheet_name = &#x27;Identify_Enroll_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Identify_Enroll_Test_Results&#x27;<br/>row_num = 9, column_no = 9, data = &#x27;15:32:19&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA0B7450&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Identify_and_Enroll_Module_API.test_identify_enroll_api.Test_identify_enroll_api object at 0x0000028EE9D61F90&gt;<br/><br/>    @pytest.mark.p1<br/>    def test_identify_enroll_Test_08(self):<br/>        self.logger.info(&quot;test_identify_enroll_Test_08  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Identify_Enroll_API_Methods(self.logger).verify_delete_enrollments():<br/><br/>All_API_Test_Cases_Package\Identify_and_Enroll_Module_API\test_identify_enroll_api.py:70: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000028EEA327450&gt;<br/><br/>    def verify_delete_enrollments(self):<br/>        result = []<br/>        try:<br/>            self.row = 9<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = delete_enrollment_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            enroll_id = response_list[3]<br/>            self.act_msg = self.json_response[&quot;message&quot;]<br/>            self.exp_msg = Read_identify_enroll_Response_msg().delete_enrollment_success_msg(enroll_id)<br/>            if response_validation(self.response) and self.act_msg == self.act_msg:<br/>                excel_result(self.row, &quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:283: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_identify_enroll_api.py:69 test_identify_enroll_Test_08  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Identify_and_Enroll_Module_API/test_identify_enroll_api.py::Test_identify_enroll_api::test_identify_enroll_Test_09</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000028EE9FAD210&gt;<br/><br/>    def verify_add_enrollment_with_image(self):<br/>        result = []<br/>        try:<br/>            self.row = 10<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:293: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 10, time = &#x27;start_time&#x27;, sheet_name = &#x27;Identify_Enroll_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Identify_Enroll_Test_Results&#x27;<br/>row_num = 10, column_no = 9, data = &#x27;15:32:19&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EE9F1FE50&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Identify_and_Enroll_Module_API.test_identify_enroll_api.Test_identify_enroll_api object at 0x0000028EE9D63910&gt;<br/><br/>    @pytest.mark.p1<br/>    def test_identify_enroll_Test_09(self):<br/>        self.logger.info(&quot;test_identify_enroll_Test_09  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Identify_Enroll_API_Methods(self.logger).verify_add_enrollment_with_image():<br/><br/>All_API_Test_Cases_Package\Identify_and_Enroll_Module_API\test_identify_enroll_api.py:78: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000028EE9FAD210&gt;<br/><br/>    def verify_add_enrollment_with_image(self):<br/>        result = []<br/>        try:<br/>            self.row = 10<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = create_enrollment_with_image()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_09&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_09&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_09&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:314: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_identify_enroll_api.py:77 test_identify_enroll_Test_09  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Identify_and_Enroll_Module_API/test_identify_enroll_api.py::Test_identify_enroll_api::test_identify_enroll_Test_10</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000028EEA0C82D0&gt;<br/><br/>    def Verify_Get_enrollment_image_by_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 11<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:324: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 11, time = &#x27;start_time&#x27;, sheet_name = &#x27;Identify_Enroll_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Identify_Enroll_Test_Results&#x27;<br/>row_num = 11, column_no = 9, data = &#x27;15:32:19&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA3EF710&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Identify_and_Enroll_Module_API.test_identify_enroll_api.Test_identify_enroll_api object at 0x0000028EE9D60190&gt;<br/><br/>    @pytest.mark.p1<br/>    def test_identify_enroll_Test_10(self):<br/>        self.logger.info(&quot;test_identify_enroll_Test_10  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Identify_Enroll_API_Methods(self.logger).Verify_Get_enrollment_image_by_id():<br/><br/>All_API_Test_Cases_Package\Identify_and_Enroll_Module_API\test_identify_enroll_api.py:86: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000028EEA0C82D0&gt;<br/><br/>    def Verify_Get_enrollment_image_by_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 11<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            self.response = get_enrollment_by_id()<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_10&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_10&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_10&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:343: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_identify_enroll_api.py:85 test_identify_enroll_Test_10  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Identify_and_Enroll_Module_API/test_identify_enroll_api.py::Test_identify_enroll_api::test_identify_enroll_Test_11</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000028EEA2BF8D0&gt;<br/><br/>    def Verify_remove_enrollment_image_by_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 12<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:353: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 12, time = &#x27;start_time&#x27;, sheet_name = &#x27;Identify_Enroll_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Identify_Enroll_Test_Results&#x27;<br/>row_num = 12, column_no = 9, data = &#x27;15:32:19&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EE9FAD550&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Identify_and_Enroll_Module_API.test_identify_enroll_api.Test_identify_enroll_api object at 0x0000028EE9D627D0&gt;<br/><br/>    @pytest.mark.p1<br/>    def test_identify_enroll_Test_11(self):<br/>        self.logger.info(&quot;test_identify_enroll_Test_11  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Identify_Enroll_API_Methods(self.logger).Verify_remove_enrollment_image_by_id():<br/><br/>All_API_Test_Cases_Package\Identify_and_Enroll_Module_API\test_identify_enroll_api.py:94: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000028EEA2BF8D0&gt;<br/><br/>    def Verify_remove_enrollment_image_by_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 12<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = remove_enrollment_images_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_11&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_11&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_11&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:375: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_identify_enroll_api.py:93 test_identify_enroll_Test_11  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Identify_and_Enroll_Module_API/test_identify_enroll_api.py::Test_identify_enroll_api::test_identify_enroll_Test_12</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000028EEA09EAD0&gt;<br/><br/>    def verify_create_enrollment_with_id_and_notification_group(self):<br/>        result = []<br/>        try:<br/>            self.row = 13<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:385: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 13, time = &#x27;start_time&#x27;, sheet_name = &#x27;Identify_Enroll_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Identify_Enroll_Test_Results&#x27;<br/>row_num = 13, column_no = 9, data = &#x27;15:32:19&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA2EE6D0&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Identify_and_Enroll_Module_API.test_identify_enroll_api.Test_identify_enroll_api object at 0x0000028EE9D60690&gt;<br/><br/>    @pytest.mark.p1<br/>    def test_identify_enroll_Test_12(self):<br/>        self.logger.info(&quot;test_identify_enroll_Test_12  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Identify_Enroll_API_Methods(self.logger).verify_create_enrollment_with_id_and_notification_group():<br/><br/>All_API_Test_Cases_Package\Identify_and_Enroll_Module_API\test_identify_enroll_api.py:102: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000028EEA09EAD0&gt;<br/><br/>    def verify_create_enrollment_with_id_and_notification_group(self):<br/>        result = []<br/>        try:<br/>            self.row = 13<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = create_enrollment_with_id_and_notification_group_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_12&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_12&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_12&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:407: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_identify_enroll_api.py:101 test_identify_enroll_Test_12  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Identify_and_Enroll_Module_API/test_identify_enroll_api.py::Test_identify_enroll_api::test_identify_enroll_Test_13</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000028EEA025BD0&gt;<br/><br/>    def verify_query_enrollment_info(self):<br/>        result = []<br/>        try:<br/>            self.row = 14<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:417: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 14, time = &#x27;start_time&#x27;, sheet_name = &#x27;Identify_Enroll_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Identify_Enroll_Test_Results&#x27;<br/>row_num = 14, column_no = 9, data = &#x27;15:32:19&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA0CB190&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Identify_and_Enroll_Module_API.test_identify_enroll_api.Test_identify_enroll_api object at 0x0000028EE9DC8D50&gt;<br/><br/>    @pytest.mark.p1<br/>    def test_identify_enroll_Test_13(self):<br/>        self.logger.info(&quot;test_identify_enroll_Test_13  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Identify_Enroll_API_Methods(self.logger).verify_query_enrollment_info():<br/><br/>All_API_Test_Cases_Package\Identify_and_Enroll_Module_API\test_identify_enroll_api.py:110: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000028EEA025BD0&gt;<br/><br/>    def verify_query_enrollment_info(self):<br/>        result = []<br/>        try:<br/>            self.row = 14<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = query_enrollment_info_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_12&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_12&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_12&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:439: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_identify_enroll_api.py:109 test_identify_enroll_Test_13  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Integration_End_To_End/test_integration_end_to_end.py::Test_integration_api::test_integration_Test_01</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Integration_End_To_End.integration_Methods.Integration_API_Methods object at 0x0000028EEA37B2D0&gt;<br/><br/>    def integration_end_to_end(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Integration_End_To_End\integration_Methods.py:40: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 2, time = &#x27;start_time&#x27;, sheet_name = &#x27;Integration_Test_Result&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Integration_Test_Result&#x27;<br/>row_num = 2, column_no = 9, data = &#x27;15:32:19&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA247E50&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Integration_End_To_End.test_integration_end_to_end.Test_integration_api object at 0x0000028EE9D6A390&gt;<br/><br/>    @pytest.mark.p1<br/>    def test_integration_Test_01(self):<br/>        self.logger.info(&quot;test_integration_Test_01  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Integration_API_Methods(self.logger).integration_end_to_end():<br/><br/>All_API_Test_Cases_Package\Integration_End_To_End\test_integration_end_to_end.py:13: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Integration_End_To_End.integration_Methods.Integration_API_Methods object at 0x0000028EEA37B2D0&gt;<br/><br/>    def integration_end_to_end(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = integration_end_to_end_request()<br/>            self.response = response_list[1]<br/>            if False not in response_list[0]:<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Integration_End_To_End\integration_Methods.py:61: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_integration_end_to_end.py:12 test_integration_Test_01  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Login_Module_API/test_login_api.py::Test_login_api::test_Login_Test_01</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Login_Module_API.Login_API_Methods.Login_API_Methods object at 0x0000028EEA03BB10&gt;<br/><br/>    def login_with_valid_username_and_password(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Login_Module_API\Login_API_Methods.py:25: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 2, time = &#x27;start_time&#x27;, sheet_name = &#x27;Login_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Login_Test_Results&#x27;<br/>row_num = 2, column_no = 9, data = &#x27;15:32:19&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA2865D0&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Login_Module_API.test_login_api.Test_login_api object at 0x0000028EE9D53210&gt;<br/><br/>    @pytest.mark.p1<br/>    def test_Login_Test_01(self):<br/>        self.logger.info(&quot;test_Login_Test_01  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Login_API_Methods(self.logger).login_with_valid_username_and_password():<br/><br/>All_API_Test_Cases_Package\Login_Module_API\test_login_api.py:13: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Login_Module_API.Login_API_Methods.Login_API_Methods object at 0x0000028EEA03BB10&gt;<br/><br/>    def login_with_valid_username_and_password(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = login_request(self.row)<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.r_body = response_list[3]<br/>            self.act_msg = self.json_response[&quot;result&quot;][&quot;message&quot;]<br/>            self.exp_msg = Read_Expected_login_Response_msg().login_success_msg()<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Login_Module_API\Login_API_Methods.py:49: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_login_api.py:12 test_Login_Test_01  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Login_Module_API/test_login_api.py::Test_login_api::test_Login_Test_02</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Login_Module_API.Login_API_Methods.Login_API_Methods object at 0x0000028EEA2BD250&gt;<br/><br/>    def verify_get_login(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Login_Module_API\Login_API_Methods.py:197: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 3, time = &#x27;start_time&#x27;, sheet_name = &#x27;Login_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Login_Test_Results&#x27;<br/>row_num = 3, column_no = 9, data = &#x27;15:32:19&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EE9EF9910&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Login_Module_API.test_login_api.Test_login_api object at 0x0000028EE9D9C510&gt;<br/><br/>    @pytest.mark.p1<br/>    def test_Login_Test_02(self):<br/>        self.logger.info(&quot;test_Login_Test_02  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Login_API_Methods(self.logger).verify_get_login():<br/><br/>All_API_Test_Cases_Package\Login_Module_API\test_login_api.py:21: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Login_Module_API.Login_API_Methods.Login_API_Methods object at 0x0000028EEA2BD250&gt;<br/><br/>    def verify_get_login(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_login_request()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Login_Module_API\Login_API_Methods.py:218: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_login_api.py:20 test_Login_Test_02  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Login_Module_API/test_login_api.py::Test_login_api::test_Login_Test_03</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Login_Module_API.Login_API_Methods.Login_API_Methods object at 0x0000028EEA0C29D0&gt;<br/><br/>    def verify_query_login_info(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Login_Module_API\Login_API_Methods.py:228: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 4, time = &#x27;start_time&#x27;, sheet_name = &#x27;Login_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Login_Test_Results&#x27;<br/>row_num = 4, column_no = 9, data = &#x27;15:32:20&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA32EE90&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Login_Module_API.test_login_api.Test_login_api object at 0x0000028EE9D9CE10&gt;<br/><br/>    @pytest.mark.p1<br/>    def test_Login_Test_03(self):<br/>        self.logger.info(&quot;test_Login_Test_03  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Login_API_Methods(self.logger).verify_query_login_info():<br/><br/>All_API_Test_Cases_Package\Login_Module_API\test_login_api.py:29: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Login_Module_API.Login_API_Methods.Login_API_Methods object at 0x0000028EEA0C29D0&gt;<br/><br/>    def verify_query_login_info(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_query_login_info_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.act_msg = self.json_response[&quot;type&quot;]<br/>            self.exp_msg = Read_Expected_login_Response_msg().query_login_msg()<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Login_Module_API\Login_API_Methods.py:252: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_login_api.py:28 test_Login_Test_03  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Login_Module_API/test_login_api.py::Test_login_api::test_Login_Test_04</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Login_Module_API.Login_API_Methods.Login_API_Methods object at 0x0000028EEA382ED0&gt;<br/><br/>    def verify_logout_request(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Login_Module_API\Login_API_Methods.py:262: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 5, time = &#x27;start_time&#x27;, sheet_name = &#x27;Login_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Login_Test_Results&#x27;<br/>row_num = 5, column_no = 9, data = &#x27;15:32:20&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA285350&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Login_Module_API.test_login_api.Test_login_api object at 0x0000028EE9D9FA10&gt;<br/><br/>    @pytest.mark.p1<br/>    def test_Login_Test_04(self):<br/>        self.logger.info(&quot;test_Login_Test_04  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Login_API_Methods(self.logger).verify_logout_request():<br/><br/>All_API_Test_Cases_Package\Login_Module_API\test_login_api.py:37: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Login_Module_API.Login_API_Methods.Login_API_Methods object at 0x0000028EEA382ED0&gt;<br/><br/>    def verify_logout_request(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = logout_request()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            self.act_msg = self.json_response[&quot;data&quot;]<br/>            self.exp_msg = Read_Expected_login_Response_msg().logout_success_msg()<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Login_Module_API\Login_API_Methods.py:285: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_login_api.py:36 test_Login_Test_04  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Login_Module_API/test_login_api.py::Test_login_api::test_Login_Test_05</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Login_Module_API.Login_API_Methods.Login_API_Methods object at 0x0000028EEA2E9B90&gt;<br/><br/>    def login_with_blank_username_and_blank_password(self):<br/>        result = []<br/>        try:<br/>            self.row = 6<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Login_Module_API\Login_API_Methods.py:163: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 6, time = &#x27;start_time&#x27;, sheet_name = &#x27;Login_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Login_Test_Results&#x27;<br/>row_num = 6, column_no = 9, data = &#x27;15:32:20&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028ED9686FD0&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Login_Module_API.test_login_api.Test_login_api object at 0x0000028EE9D9F110&gt;<br/><br/>    @pytest.mark.p1<br/>    def test_Login_Test_05(self):<br/>        self.logger.info(&quot;test_Login_Test_05  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Login_API_Methods(self.logger).login_with_blank_username_and_blank_password():<br/><br/>All_API_Test_Cases_Package\Login_Module_API\test_login_api.py:45: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Login_Module_API.Login_API_Methods.Login_API_Methods object at 0x0000028EEA2E9B90&gt;<br/><br/>    def login_with_blank_username_and_blank_password(self):<br/>        result = []<br/>        try:<br/>            self.row = 6<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = login_request(self.row)<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.r_body = response_list[3]<br/>            self.act_msg = self.json_response[&quot;Data&quot;][&quot;exceptionMessage&quot;]<br/>            self.exp_msg = Read_Expected_login_Response_msg().login_blank_username_password()<br/>            if invalid_response_validation(self.response) and self.act_msg == self.act_msg:<br/>                excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Login_Module_API\Login_API_Methods.py:187: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_login_api.py:44 test_Login_Test_05  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Notes_Module_API/test_notes_api.py::Test_notes_api::test_notes_Test_01</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x0000028EEA2ECB50&gt;<br/><br/>    def verify_create_notes(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:29: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 2, time = &#x27;start_time&#x27;, sheet_name = &#x27;Notes_Test_Result&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Notes_Test_Result&#x27;<br/>row_num = 2, column_no = 9, data = &#x27;15:32:20&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EE9DF4410&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Notes_Module_API.test_notes_api.Test_notes_api object at 0x0000028EE9D63190&gt;<br/><br/>    def test_notes_Test_01(self):<br/>        self.logger.info(&quot;test_notes_Test_01  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Notes_API_Methods(self.logger).verify_create_notes():<br/><br/>All_API_Test_Cases_Package\Notes_Module_API\test_notes_api.py:10: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x0000028EEA2ECB50&gt;<br/><br/>    def verify_create_notes(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = create_notes_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            note_id = self.json_response[&quot;data&quot;][&quot;id&quot;]<br/>            self.exp_msg = Read_notes_Response_msg().create_notes_success_msg(note_id)<br/>            self.act_msg = self.json_response[&quot;data&quot;][&quot;message&quot;]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:54: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_notes_api.py:9 test_notes_Test_01  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Notes_Module_API/test_notes_api.py::Test_notes_api::test_notes_Test_02</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x0000028EE9F9C650&gt;<br/><br/>    def verify_get_notes_using_note_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:64: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 3, time = &#x27;start_time&#x27;, sheet_name = &#x27;Notes_Test_Result&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Notes_Test_Result&#x27;<br/>row_num = 3, column_no = 9, data = &#x27;15:32:20&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA09A810&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Notes_Module_API.test_notes_api.Test_notes_api object at 0x0000028EE9D62390&gt;<br/><br/>    def test_notes_Test_02(self):<br/>        self.logger.info(&quot;test_notes_Test_02  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Notes_API_Methods(self.logger).verify_get_notes_using_note_id():<br/><br/>All_API_Test_Cases_Package\Notes_Module_API\test_notes_api.py:17: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x0000028EE9F9C650&gt;<br/><br/>    def verify_get_notes_using_note_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            ex_note_id = create_notes_request()[2][&quot;data&quot;][&quot;id&quot;]<br/>            response_list = get_notes_using_id(ex_note_id)<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            ac_notes_id = self.json_response[&quot;notesInfo&quot;][&quot;notes&quot;][0][&quot;noteID&quot;]<br/>            self.act_msg = ac_notes_id<br/>            if response_validation(self.response) and ex_note_id == ac_notes_id:<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:88: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_notes_api.py:16 test_notes_Test_02  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Notes_Module_API/test_notes_api.py::Test_notes_api::test_notes_Test_03</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x0000028EE9D6AE90&gt;<br/><br/>    def verify_update_notes(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:98: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 4, time = &#x27;start_time&#x27;, sheet_name = &#x27;Notes_Test_Result&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Notes_Test_Result&#x27;<br/>row_num = 4, column_no = 9, data = &#x27;15:32:20&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA2FD7D0&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Notes_Module_API.test_notes_api.Test_notes_api object at 0x0000028EE9EC3A50&gt;<br/><br/>    def test_notes_Test_03(self):<br/>        self.logger.info(&quot;test_notes_Test_03  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Notes_API_Methods(self.logger).verify_update_notes():<br/><br/>All_API_Test_Cases_Package\Notes_Module_API\test_notes_api.py:24: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x0000028EE9D6AE90&gt;<br/><br/>    def verify_update_notes(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            note_id = create_notes_request()[2][&quot;data&quot;][&quot;id&quot;]<br/>            response_list = edit_notes_request(note_id)<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.exp_msg = Read_notes_Response_msg().update_notes_success_msg()<br/>            self.act_msg = self.json_response[&quot;result&quot;][&quot;message&quot;]<br/>            if response_validation(self.response) and self.exp_msg == self.act_msg:<br/>                excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:123: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_notes_api.py:23 test_notes_Test_03  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Notes_Module_API/test_notes_api.py::Test_notes_api::test_notes_Test_04</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x0000028EEA373210&gt;<br/><br/>    def verify_delete_notes_using_note_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:133: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 5, time = &#x27;start_time&#x27;, sheet_name = &#x27;Notes_Test_Result&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Notes_Test_Result&#x27;<br/>row_num = 5, column_no = 9, data = &#x27;15:32:20&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA075090&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Notes_Module_API.test_notes_api.Test_notes_api object at 0x0000028EE9EC3B90&gt;<br/><br/>    def test_notes_Test_04(self):<br/>        self.logger.info(&quot;test_notes_Test_04  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Notes_API_Methods(self.logger).verify_delete_notes_using_note_id():<br/><br/>All_API_Test_Cases_Package\Notes_Module_API\test_notes_api.py:31: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x0000028EEA373210&gt;<br/><br/>    def verify_delete_notes_using_note_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            note_id = create_notes_request()[2][&quot;data&quot;][&quot;id&quot;]<br/>            response_list = delete_notes_request(note_id)<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            self.exp_msg = Read_notes_Response_msg().delete_notes_success_msg(note_id)<br/>            self.act_msg = self.json_response[&quot;message&quot;]<br/>            if response_validation(self.response) and self.exp_msg == self.act_msg:<br/>                excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:157: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_notes_api.py:30 test_notes_Test_04  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Notes_Module_API/test_notes_api.py::Test_notes_api::test_notes_Test_05</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x0000028EEA09B550&gt;<br/><br/>    def verify_clear_notes(self):<br/>        result = []<br/>        try:<br/>            self.row = 6<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:167: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 6, time = &#x27;start_time&#x27;, sheet_name = &#x27;Notes_Test_Result&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Notes_Test_Result&#x27;<br/>row_num = 6, column_no = 9, data = &#x27;15:32:20&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA2BFAD0&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Notes_Module_API.test_notes_api.Test_notes_api object at 0x0000028EE9EC0FD0&gt;<br/><br/>    def test_notes_Test_05(self):<br/>        self.logger.info(&quot;test_notes_Test_05  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Notes_API_Methods(self.logger).verify_clear_notes():<br/><br/>All_API_Test_Cases_Package\Notes_Module_API\test_notes_api.py:38: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x0000028EEA09B550&gt;<br/><br/>    def verify_clear_notes(self):<br/>        result = []<br/>        try:<br/>            self.row = 6<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            note_id = create_notes_request()[2][&quot;data&quot;][&quot;id&quot;]<br/>            response_list = clear_notes_request(note_id)<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.exp_msg = Read_notes_Response_msg().clear_notes_success_msg()<br/>            self.act_msg = self.json_response[&quot;result&quot;][&quot;message&quot;]<br/>            if response_validation(self.response) and self.exp_msg == self.act_msg:<br/>                excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:192: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_notes_api.py:37 test_notes_Test_05  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Notes_Module_API/test_notes_api.py::Test_notes_api::test_notes_Test_06</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x0000028EE9FB3B50&gt;<br/><br/>    def verify_add_image_to_note_using_note_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 7<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:202: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 7, time = &#x27;start_time&#x27;, sheet_name = &#x27;Notes_Test_Result&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Notes_Test_Result&#x27;<br/>row_num = 7, column_no = 9, data = &#x27;15:32:20&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EE9F9EF10&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Notes_Module_API.test_notes_api.Test_notes_api object at 0x0000028EE9EC3810&gt;<br/><br/>    def test_notes_Test_06(self):<br/>        self.logger.info(&quot;test_notes_Test_06  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Notes_API_Methods(self.logger).verify_add_image_to_note_using_note_id():<br/><br/>All_API_Test_Cases_Package\Notes_Module_API\test_notes_api.py:45: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x0000028EE9FB3B50&gt;<br/><br/>    def verify_add_image_to_note_using_note_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 7<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            note_id = create_notes_request()[2][&quot;data&quot;][&quot;id&quot;]<br/>            response_list = add_image_request(note_id)<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.exp_msg = Read_notes_Response_msg().add_image_to_notes_success_msg()<br/>            self.act_msg = self.json_response[&quot;result&quot;][&quot;status&quot;]<br/>            if response_validation(self.response) and self.exp_msg == self.act_msg:<br/>                excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:227: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_notes_api.py:44 test_notes_Test_06  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Notes_Module_API/test_notes_api.py::Test_notes_api::test_notes_Test_07</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x0000028EEA03FA50&gt;<br/><br/>    def verify_get_image_using_note_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 8<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:237: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 8, time = &#x27;start_time&#x27;, sheet_name = &#x27;Notes_Test_Result&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Notes_Test_Result&#x27;<br/>row_num = 8, column_no = 9, data = &#x27;15:32:20&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA376B50&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Notes_Module_API.test_notes_api.Test_notes_api object at 0x0000028EE9EC2850&gt;<br/><br/>    def test_notes_Test_07(self):<br/>        self.logger.info(&quot;test_notes_Test_07  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Notes_API_Methods(self.logger).verify_get_image_using_note_id():<br/><br/>All_API_Test_Cases_Package\Notes_Module_API\test_notes_api.py:52: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x0000028EEA03FA50&gt;<br/><br/>    def verify_get_image_using_note_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 8<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            note_id = create_notes_request()[2][&quot;data&quot;][&quot;id&quot;]<br/>            self.response = get_image_using_note_id(note_id)<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_07&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_07&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_07&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:257: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_notes_api.py:51 test_notes_Test_07  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Notes_Module_API/test_notes_api.py::Test_notes_api::test_notes_Test_08</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x0000028EEA2F7490&gt;<br/><br/>    def verify_delete_image_using_note_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 9<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:267: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 9, time = &#x27;start_time&#x27;, sheet_name = &#x27;Notes_Test_Result&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Notes_Test_Result&#x27;<br/>row_num = 9, column_no = 9, data = &#x27;15:32:20&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA380ED0&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Notes_Module_API.test_notes_api.Test_notes_api object at 0x0000028EE9EC20D0&gt;<br/><br/>    def test_notes_Test_08(self):<br/>        self.logger.info(&quot;test_notes_Test_08  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Notes_API_Methods(self.logger).verify_delete_image_using_note_id():<br/><br/>All_API_Test_Cases_Package\Notes_Module_API\test_notes_api.py:59: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x0000028EEA2F7490&gt;<br/><br/>    def verify_delete_image_using_note_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 9<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            note_id = create_notes_request()[2][&quot;data&quot;][&quot;id&quot;]<br/>            image_id = get_notes_using_id(note_id)[1][&quot;notesInfo&quot;][&quot;notes&quot;][0][&quot;imageIDs&quot;][0]<br/>            response_list = delete_image_request(note_id, image_id)<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.exp_msg = Read_notes_Response_msg().delete_image_to_notes_success_msg(note_id)<br/>            self.act_msg = self.json_response[&quot;message&quot;]<br/>            if response_validation(self.response) and self.exp_msg == self.act_msg:<br/>                excel_result(self.row, &quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:293: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_notes_api.py:58 test_notes_Test_08  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Notes_Module_API/test_notes_api.py::Test_notes_api::test_notes_Test_09</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x0000028EEA2BEF90&gt;<br/><br/>    def verify_notes_search(self):<br/>        result = []<br/>        try:<br/>            self.row = 10<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:303: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 10, time = &#x27;start_time&#x27;, sheet_name = &#x27;Notes_Test_Result&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Notes_Test_Result&#x27;<br/>row_num = 10, column_no = 9, data = &#x27;15:32:21&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EE9FB2850&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Notes_Module_API.test_notes_api.Test_notes_api object at 0x0000028EE9EC2110&gt;<br/><br/>    def test_notes_Test_09(self):<br/>        self.logger.info(&quot;test_notes_Test_09  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Notes_API_Methods(self.logger).verify_notes_search():<br/><br/>All_API_Test_Cases_Package\Notes_Module_API\test_notes_api.py:66: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x0000028EEA2BEF90&gt;<br/><br/>    def verify_notes_search(self):<br/>        result = []<br/>        try:<br/>            self.row = 10<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            create_notes_request()<br/>            response_list = notes_search_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_09&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_09&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_09&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:326: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_notes_api.py:65 test_notes_Test_09  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Notes_Module_API/test_notes_api.py::Test_notes_api::test_notes_Test_10</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x0000028EEA377490&gt;<br/><br/>    def verify_notes_aggregates_by_geospatial(self):<br/>        result = []<br/>        try:<br/>            self.row = 11<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:336: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 11, time = &#x27;start_time&#x27;, sheet_name = &#x27;Notes_Test_Result&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Notes_Test_Result&#x27;<br/>row_num = 11, column_no = 9, data = &#x27;15:32:21&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA265E50&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Notes_Module_API.test_notes_api.Test_notes_api object at 0x0000028EE9EC1210&gt;<br/><br/>    def test_notes_Test_10(self):<br/>        self.logger.info(&quot;test_notes_Test_10  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Notes_API_Methods(self.logger).verify_notes_aggregates_by_geospatial():<br/><br/>All_API_Test_Cases_Package\Notes_Module_API\test_notes_api.py:73: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x0000028EEA377490&gt;<br/><br/>    def verify_notes_aggregates_by_geospatial(self):<br/>        result = []<br/>        try:<br/>            self.row = 11<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            create_notes_request()<br/>            response_list = aggregates_by_geospatial_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_10&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_10&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_10&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:359: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_notes_api.py:72 test_notes_Test_10  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Notes_Module_API/test_notes_api.py::Test_notes_api::test_notes_Test_11</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x0000028EEA2ED4D0&gt;<br/><br/>    def verify_get_by_enrollment(self):<br/>        result = []<br/>        try:<br/>            self.row = 12<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:369: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 12, time = &#x27;start_time&#x27;, sheet_name = &#x27;Notes_Test_Result&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Notes_Test_Result&#x27;<br/>row_num = 12, column_no = 9, data = &#x27;15:32:21&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA08D210&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Notes_Module_API.test_notes_api.Test_notes_api object at 0x0000028EE9EC0A10&gt;<br/><br/>    def test_notes_Test_11(self):<br/>        self.logger.info(&quot;test_notes_Test_11  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Notes_API_Methods(self.logger).verify_get_by_enrollment():<br/><br/>All_API_Test_Cases_Package\Notes_Module_API\test_notes_api.py:80: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x0000028EEA2ED4D0&gt;<br/><br/>    def verify_get_by_enrollment(self):<br/>        result = []<br/>        try:<br/>            self.row = 12<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            case_id = create_notes_to_a_person_request()[3]<br/>            response_list = get_by_enrollment_request(case_id)<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_11&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_11&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_11&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:392: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_notes_api.py:79 test_notes_Test_11  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Notification_Groups_Module_APi/test_notification_groups_api.py::Test_Notification_groups_api::test_Notification_Groups_Test_01</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Notification_groups_Module_API.Notification_Groups_Methods.Notification_Groups_API_Methods object at 0x0000028EEA219DD0&gt;<br/><br/>    def verify_create_notification_group_with_users_enrollment_group_zones(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:31: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 2, time = &#x27;start_time&#x27;, sheet_name = &#x27;Notification_Groups_Test_Result&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>sheet_name = &#x27;Notification_Groups_Test_Result&#x27;, row_num = 2, column_no = 9, data = &#x27;15:32:21&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA374AD0&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Notification_Groups_Module_APi.test_notification_groups_api.Test_Notification_groups_api object at 0x0000028ED96424D0&gt;<br/><br/>    def test_Notification_Groups_Test_01(self):<br/>        self.logger.info(&quot;test_Notification_Groups_Test_01  : Execution Started &gt;&gt;&quot;)<br/>        if Notification_Groups_API_Methods(self.logger)\<br/>&gt;               .verify_create_notification_group_with_users_enrollment_group_zones():<br/><br/>All_API_Test_Cases_Package\Notification_Groups_Module_APi\test_notification_groups_api.py:13: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Notification_groups_Module_API.Notification_Groups_Methods.Notification_Groups_API_Methods object at 0x0000028EEA219DD0&gt;<br/><br/>    def verify_create_notification_group_with_users_enrollment_group_zones(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = create_notification_group_with_users_enrollment_group_zones()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            alert_id = self.json_response[&quot;data&quot;]<br/>            self.act_msg = self.json_response[&quot;message&quot;]<br/>            print(response_list)<br/>            self.exp_msg = Read_Expected_Notification_Groups_Response_msg().notification_created_success_msg(alert_id)<br/>            if response_validation(self.response) and self.exp_msg == self.act_msg:<br/>                excel_result(self.row,&quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row,&quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:58: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>[Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_notification_groups_api.py:11 test_Notification_Groups_Test_01  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Notification_Groups_Module_APi/test_notification_groups_api.py::Test_Notification_groups_api::test_Notification_Groups_Test_02</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Notification_groups_Module_API.Notification_Groups_Methods.Notification_Groups_API_Methods object at 0x0000028EEA1A9950&gt;<br/><br/>    def verify_create_notification_group_without_users_enrollment_group_and_zones(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:68: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 3, time = &#x27;start_time&#x27;, sheet_name = &#x27;Notification_Groups_Test_Result&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>sheet_name = &#x27;Notification_Groups_Test_Result&#x27;, row_num = 3, column_no = 9, data = &#x27;15:32:21&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA373350&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Notification_Groups_Module_APi.test_notification_groups_api.Test_Notification_groups_api object at 0x0000028EE9E71610&gt;<br/><br/>    def test_Notification_Groups_Test_02(self):<br/>        self.logger.info(&quot;test_Notification_Groups_Test_02  : Execution Started &gt;&gt;&quot;)<br/>        if Notification_Groups_API_Methods(self.logger)\<br/>&gt;               .verify_create_notification_group_without_users_enrollment_group_and_zones():<br/><br/>All_API_Test_Cases_Package\Notification_Groups_Module_APi\test_notification_groups_api.py:21: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Notification_groups_Module_API.Notification_Groups_Methods.Notification_Groups_API_Methods object at 0x0000028EEA1A9950&gt;<br/><br/>    def verify_create_notification_group_without_users_enrollment_group_and_zones(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = create_notification_group_without_users_enrollment_group_zones()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            alert_id = self.json_response[&quot;data&quot;]<br/>            self.act_msg = self.json_response[&quot;message&quot;]<br/>            print(response_list)<br/>            self.exp_msg = Read_Expected_Notification_Groups_Response_msg().notification_created_success_msg(alert_id)<br/>            if response_validation(self.response) and self.exp_msg == self.act_msg:<br/>                excel_result(self.row,&quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row,&quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:95: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>[Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_notification_groups_api.py:19 test_Notification_Groups_Test_02  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Notification_Groups_Module_APi/test_notification_groups_api.py::Test_Notification_groups_api::test_Notification_Groups_Test_03</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Notification_groups_Module_API.Notification_Groups_Methods.Notification_Groups_API_Methods object at 0x0000028EE9F9C250&gt;<br/><br/>    def verify_get_all_alert_groups(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:105: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 4, time = &#x27;start_time&#x27;, sheet_name = &#x27;Notification_Groups_Test_Result&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>sheet_name = &#x27;Notification_Groups_Test_Result&#x27;, row_num = 4, column_no = 9, data = &#x27;15:32:21&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA08CA50&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Notification_Groups_Module_APi.test_notification_groups_api.Test_Notification_groups_api object at 0x0000028EE9E73950&gt;<br/><br/>    def test_Notification_Groups_Test_03(self):<br/>        self.logger.info(&quot;test_Notification_Groups_Test_03  : Execution Started &gt;&gt;&quot;)<br/>        if Notification_Groups_API_Methods(self.logger)\<br/>&gt;               .verify_get_all_alert_groups():<br/><br/>All_API_Test_Cases_Package\Notification_Groups_Module_APi\test_notification_groups_api.py:29: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Notification_groups_Module_API.Notification_Groups_Methods.Notification_Groups_API_Methods object at 0x0000028EE9F9C250&gt;<br/><br/>    def verify_get_all_alert_groups(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_all_notification_groups()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            print(response_list)<br/>            if response_validation(self.response):<br/>                excel_result(self.row,&quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row,&quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row,&quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:128: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>[Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_notification_groups_api.py:27 test_Notification_Groups_Test_03  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Notification_Groups_Module_APi/test_notification_groups_api.py::Test_Notification_groups_api::test_Notification_Groups_Test_04</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Notification_groups_Module_API.Notification_Groups_Methods.Notification_Groups_API_Methods object at 0x0000028EEA219850&gt;<br/><br/>    def verify_get_single_alert_group_using_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:138: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 5, time = &#x27;start_time&#x27;, sheet_name = &#x27;Notification_Groups_Test_Result&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>sheet_name = &#x27;Notification_Groups_Test_Result&#x27;, row_num = 5, column_no = 9, data = &#x27;15:32:21&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA264910&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Notification_Groups_Module_APi.test_notification_groups_api.Test_Notification_groups_api object at 0x0000028EE9E73610&gt;<br/><br/>    def test_Notification_Groups_Test_04(self):<br/>        self.logger.info(&quot;test_Notification_Groups_Test_04  : Execution Started &gt;&gt;&quot;)<br/>        if Notification_Groups_API_Methods(self.logger)\<br/>&gt;               .verify_get_single_alert_group_using_id():<br/><br/>All_API_Test_Cases_Package\Notification_Groups_Module_APi\test_notification_groups_api.py:37: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Notification_groups_Module_API.Notification_Groups_Methods.Notification_Groups_API_Methods object at 0x0000028EEA219850&gt;<br/><br/>    def verify_get_single_alert_group_using_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            post_response_list = create_notification_group_without_users_enrollment_group_zones()<br/>            alert_id = post_response_list[2][&quot;data&quot;]<br/>            ex_alert_name = post_response_list[3]<br/>            response_list = get_notification_group_using_id(alert_id)<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            ac_alert_name = self.json_response[&quot;agroupinfo&quot;][&quot;agroups&quot;][0][&quot;name&quot;]<br/>            print(response_list)<br/>            if response_validation(self.response) and ex_alert_name == ac_alert_name:<br/>                excel_result(self.row,&quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row,&quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row,&quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:165: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>[Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_notification_groups_api.py:35 test_Notification_Groups_Test_04  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Notification_Groups_Module_APi/test_notification_groups_api.py::Test_Notification_groups_api::test_Notification_Groups_Test_05</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Notification_groups_Module_API.Notification_Groups_Methods.Notification_Groups_API_Methods object at 0x0000028EEA379B50&gt;<br/><br/>    def modify_alert_group(self):<br/>        result = []<br/>        try:<br/>            self.row = 6<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:175: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 6, time = &#x27;start_time&#x27;, sheet_name = &#x27;Notification_Groups_Test_Result&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>sheet_name = &#x27;Notification_Groups_Test_Result&#x27;, row_num = 6, column_no = 9, data = &#x27;15:32:21&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA1AA350&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Notification_Groups_Module_APi.test_notification_groups_api.Test_Notification_groups_api object at 0x0000028EE9E73990&gt;<br/><br/>    def test_Notification_Groups_Test_05(self):<br/>        self.logger.info(&quot;test_Notification_Groups_Test_05  : Execution Started &gt;&gt;&quot;)<br/>        if Notification_Groups_API_Methods(self.logger)\<br/>&gt;               .modify_alert_group():<br/><br/>All_API_Test_Cases_Package\Notification_Groups_Module_APi\test_notification_groups_api.py:45: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Notification_groups_Module_API.Notification_Groups_Methods.Notification_Groups_API_Methods object at 0x0000028EEA379B50&gt;<br/><br/>    def modify_alert_group(self):<br/>        result = []<br/>        try:<br/>            self.row = 6<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            post_response_list = create_notification_group_without_users_enrollment_group_zones()<br/>            print(post_response_list)<br/>            alert_id = post_response_list[2][&quot;data&quot;]<br/>            alert_name = post_response_list[3]<br/>            print(alert_id)<br/>            print(alert_name)<br/>            response_list = edit_alert_group_request(alert_id,alert_name)<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            print(&quot;response_list&quot;,response_list)<br/>            ex_update_msg = Read_Expected_Notification_Groups_Response_msg().notification_updated_success_msg(alert_id)<br/>            ac_update_msg = response_list[2][&quot;message&quot;]<br/>            if response_validation(self.response) and ex_update_msg == ac_update_msg:<br/>                excel_result(self.row,&quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row,&quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row,&quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:207: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>[Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_notification_groups_api.py:43 test_Notification_Groups_Test_05  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Notification_Groups_Module_APi/test_notification_groups_api.py::Test_Notification_groups_api::test_Notification_Groups_Test_06</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Notification_groups_Module_API.Notification_Groups_Methods.Notification_Groups_API_Methods object at 0x0000028EEA08E390&gt;<br/><br/>    def verify_add_user_to_alert_group(self):<br/>        result = []<br/>        try:<br/>            self.row = 7<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:217: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 7, time = &#x27;start_time&#x27;, sheet_name = &#x27;Notification_Groups_Test_Result&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>sheet_name = &#x27;Notification_Groups_Test_Result&#x27;, row_num = 7, column_no = 9, data = &#x27;15:32:21&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EE9F132D0&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Notification_Groups_Module_APi.test_notification_groups_api.Test_Notification_groups_api object at 0x0000028EE9E70F50&gt;<br/><br/>    def test_Notification_Groups_Test_06(self):<br/>        self.logger.info(&quot;test_Notification_Groups_Test_06  : Execution Started &gt;&gt;&quot;)<br/>        if Notification_Groups_API_Methods(self.logger)\<br/>&gt;               .verify_add_user_to_alert_group():<br/><br/>All_API_Test_Cases_Package\Notification_Groups_Module_APi\test_notification_groups_api.py:53: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Notification_groups_Module_API.Notification_Groups_Methods.Notification_Groups_API_Methods object at 0x0000028EEA08E390&gt;<br/><br/>    def verify_add_user_to_alert_group(self):<br/>        result = []<br/>        try:<br/>            self.row = 7<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            user_info_list = get_user_info()<br/>            post_response_list = create_notification_group_without_users_enrollment_group_zones()<br/>            print(post_response_list)<br/>            alert_id = post_response_list[2][&quot;data&quot;]<br/>            print(alert_id)<br/>            response_list = add_user_to_alert_group_request(alert_id)<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            print(&quot;response_list&quot;,response_list)<br/>            ex_update_msg = Read_Expected_Notification_Groups_Response_msg().user_added_to_notification_success_msg(user_info_list[3], alert_id)<br/>            ac_update_msg = response_list[2][&quot;result&quot;][&quot;message&quot;]<br/>            self.exp_msg = Read_Expected_Notification_Groups_Response_msg().user_added_to_notification_status_success_msg()<br/>            self.act_msg = response_list[2][&quot;result&quot;][&quot;status&quot;]<br/>    <br/>            if response_validation(self.response) and ex_update_msg == ac_update_msg and self.exp_msg == self.act_msg:<br/>                excel_result(self.row,&quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row,&quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row,&quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:251: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>[Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_notification_groups_api.py:51 test_Notification_Groups_Test_06  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Notification_Groups_Module_APi/test_notification_groups_api.py::Test_Notification_groups_api::test_Notification_Groups_Test_07</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Notification_groups_Module_API.Notification_Groups_Methods.Notification_Groups_API_Methods object at 0x0000028EE9FB3D50&gt;<br/><br/>    def verify_remove_user_from_alert_group(self):<br/>        result = []<br/>        try:<br/>            self.row = 8<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:261: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 8, time = &#x27;start_time&#x27;, sheet_name = &#x27;Notification_Groups_Test_Result&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>sheet_name = &#x27;Notification_Groups_Test_Result&#x27;, row_num = 8, column_no = 9, data = &#x27;15:32:21&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA2EE650&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Notification_Groups_Module_APi.test_notification_groups_api.Test_Notification_groups_api object at 0x0000028EE9E719D0&gt;<br/><br/>    def test_Notification_Groups_Test_07(self):<br/>        self.logger.info(&quot;test_Notification_Groups_Test_07  : Execution Started &gt;&gt;&quot;)<br/>        if Notification_Groups_API_Methods(self.logger)\<br/>&gt;               .verify_remove_user_from_alert_group():<br/><br/>All_API_Test_Cases_Package\Notification_Groups_Module_APi\test_notification_groups_api.py:61: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Notification_groups_Module_API.Notification_Groups_Methods.Notification_Groups_API_Methods object at 0x0000028EE9FB3D50&gt;<br/><br/>    def verify_remove_user_from_alert_group(self):<br/>        result = []<br/>        try:<br/>            self.row = 8<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            user_info_list = get_user_info()<br/>            post_response_list = create_notification_group_without_users_enrollment_group_zones()<br/>            print(post_response_list)<br/>            alert_id = post_response_list[2][&quot;data&quot;]<br/>            print(alert_id)<br/>            add_user_to_alert_group_request(alert_id)<br/>            response_list = remove_user_from_alert_group_request(alert_id)<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            print(&quot;response_list&quot;,response_list)<br/>            ex_update_msg = Read_Expected_Notification_Groups_Response_msg().user_removed_from_notification_success_msg(user_info_list[3], alert_id)<br/>            ac_update_msg = response_list[2][&quot;result&quot;][&quot;message&quot;]<br/>            self.exp_msg = Read_Expected_Notification_Groups_Response_msg().user_removed_from_notification_status_success_msg()<br/>            self.act_msg = response_list[2][&quot;result&quot;][&quot;status&quot;]<br/>    <br/>            if response_validation(self.response) and ex_update_msg == ac_update_msg and self.exp_msg == self.act_msg:<br/>                excel_result(self.row,&quot;Test_07&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row,&quot;Test_07&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row,&quot;Test_07&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:296: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>[Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_notification_groups_api.py:59 test_Notification_Groups_Test_07  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Notification_Groups_Module_APi/test_notification_groups_api.py::Test_Notification_groups_api::test_Notification_Groups_Test_08</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Notification_groups_Module_API.Notification_Groups_Methods.Notification_Groups_API_Methods object at 0x0000028EEA1A9490&gt;<br/><br/>    def verify_delete_alert_group(self):<br/>        result = []<br/>        try:<br/>            self.row = 9<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:306: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 9, time = &#x27;start_time&#x27;, sheet_name = &#x27;Notification_Groups_Test_Result&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>sheet_name = &#x27;Notification_Groups_Test_Result&#x27;, row_num = 9, column_no = 9, data = &#x27;15:32:21&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA3C38D0&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Notification_Groups_Module_APi.test_notification_groups_api.Test_Notification_groups_api object at 0x0000028EE9E70710&gt;<br/><br/>    def test_Notification_Groups_Test_08(self):<br/>        self.logger.info(&quot;test_Notification_Groups_Test_08  : Execution Started &gt;&gt;&quot;)<br/>        if Notification_Groups_API_Methods(self.logger)\<br/>&gt;               .verify_delete_alert_group():<br/><br/>All_API_Test_Cases_Package\Notification_Groups_Module_APi\test_notification_groups_api.py:69: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Notification_groups_Module_API.Notification_Groups_Methods.Notification_Groups_API_Methods object at 0x0000028EEA1A9490&gt;<br/><br/>    def verify_delete_alert_group(self):<br/>        result = []<br/>        try:<br/>            self.row = 9<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            post_response_list = create_notification_group_without_users_enrollment_group_zones()<br/>            print(post_response_list)<br/>            alert_id = post_response_list[2][&quot;data&quot;]<br/>            print(alert_id)<br/>            get_response_list = get_notification_group_using_id(alert_id)<br/>            alert_name = get_response_list[1][&quot;agroupinfo&quot;][&quot;agroups&quot;][0][&quot;name&quot;]<br/>            response_list = get_delete_user_request(alert_id)<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            print(&quot;response_list&quot;,response_list)<br/>            self.exp_msg = Read_Expected_Notification_Groups_Response_msg().notification_delete_msg(alert_name,alert_id)<br/>            self.act_msg = self.json_response[&quot;message&quot;]<br/>    <br/>            if response_validation(self.response) and self.exp_msg == self.act_msg:<br/>                excel_result(self.row,&quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row,&quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row,&quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:338: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>[Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_notification_groups_api.py:67 test_Notification_Groups_Test_08  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Notification_Groups_Module_APi/test_notification_groups_api.py::Test_Notification_groups_api::test_Notification_Groups_Test_09</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Notification_groups_Module_API.Notification_Groups_Methods.Notification_Groups_API_Methods object at 0x0000028EEA08CBD0&gt;<br/><br/>    def verify_notification_group_should_not_be_duplicate(self):<br/>        result = []<br/>        try:<br/>            self.row = 10<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:348: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 10, time = &#x27;start_time&#x27;, sheet_name = &#x27;Notification_Groups_Test_Result&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>sheet_name = &#x27;Notification_Groups_Test_Result&#x27;, row_num = 10, column_no = 9, data = &#x27;15:32:22&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EE9DF5AD0&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Notification_Groups_Module_APi.test_notification_groups_api.Test_Notification_groups_api object at 0x0000028EE9E72390&gt;<br/><br/>    def test_Notification_Groups_Test_09(self):<br/>        self.logger.info(&quot;test_Notification_Groups_Test_09  : Execution Started &gt;&gt;&quot;)<br/>        if Notification_Groups_API_Methods(self.logger)\<br/>&gt;               .verify_notification_group_should_not_be_duplicate():<br/><br/>All_API_Test_Cases_Package\Notification_Groups_Module_APi\test_notification_groups_api.py:77: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Notification_groups_Module_API.Notification_Groups_Methods.Notification_Groups_API_Methods object at 0x0000028EEA08CBD0&gt;<br/><br/>    def verify_notification_group_should_not_be_duplicate(self):<br/>        result = []<br/>        try:<br/>            self.row = 10<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            post_response_list = create_notification_group_without_users_enrollment_group_zones()<br/>            print(post_response_list)<br/>            alert_id = post_response_list[2][&quot;data&quot;]<br/>            print(alert_id)<br/>            alert_name = post_response_list[3]<br/>            post_duplicate_response_list = create_duplicate_notification_group(alert_name)<br/>            self.r_body = post_duplicate_response_list[0]<br/>            self.response = post_duplicate_response_list[1]<br/>            self.json_response = post_duplicate_response_list[2]<br/>            print(&quot;response_list&quot;,post_duplicate_response_list)<br/>    <br/>            if invalid_response_validation(self.response):<br/>                excel_result(self.row,&quot;Test_09&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row,&quot;Test_09&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row,&quot;Test_09&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:378: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>[Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_notification_groups_api.py:75 test_Notification_Groups_Test_09  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Notification_Groups_Module_APi/test_notification_groups_api.py::Test_Notification_groups_api::test_Notification_Groups_Test_10</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Notification_groups_Module_API.Notification_Groups_Methods.Notification_Groups_API_Methods object at 0x0000028EEA2F21D0&gt;<br/><br/>    def verify_add_enrollment_group_to_notification_group(self):<br/>        result = []<br/>        try:<br/>            self.row = 11<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:388: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 11, time = &#x27;start_time&#x27;, sheet_name = &#x27;Notification_Groups_Test_Result&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>sheet_name = &#x27;Notification_Groups_Test_Result&#x27;, row_num = 11, column_no = 9, data = &#x27;15:32:22&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA1C4990&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Notification_Groups_Module_APi.test_notification_groups_api.Test_Notification_groups_api object at 0x0000028EE9E712D0&gt;<br/><br/>    def test_Notification_Groups_Test_10(self):<br/>        self.logger.info(&quot;test_Notification_Groups_Test_10  : Execution Started &gt;&gt;&quot;)<br/>        if Notification_Groups_API_Methods(self.logger)\<br/>&gt;               .verify_add_enrollment_group_to_notification_group():<br/><br/>All_API_Test_Cases_Package\Notification_Groups_Module_APi\test_notification_groups_api.py:85: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Notification_groups_Module_API.Notification_Groups_Methods.Notification_Groups_API_Methods object at 0x0000028EEA2F21D0&gt;<br/><br/>    def verify_add_enrollment_group_to_notification_group(self):<br/>        result = []<br/>        try:<br/>            self.row = 11<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            enrollment_id = get_enrollment_group_id()<br/>            response_list = create_notification_group_without_users_enrollment_group_zones()<br/>            alert_id = response_list[2][&quot;data&quot;]<br/>            add_enrollment_resp_list = add_enrollment_to_alert_group_request(enrollment_id, alert_id)<br/>            self.r_body = add_enrollment_resp_list[0]<br/>            self.response = add_enrollment_resp_list[1]<br/>            self.json_response = add_enrollment_resp_list[2]<br/>            self.act_msg = self.json_response[&quot;result&quot;][&quot;status&quot;]<br/>            print(response_list)<br/>            if response_validation(self.response):<br/>                excel_result(self.row,&quot;Test_10&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_10&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row,&quot;Test_10&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:416: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>[Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_notification_groups_api.py:83 test_Notification_Groups_Test_10  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Region_Module_API/test_region_api.py::Test_region_api::test_tags_Test_01</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x0000028EEA03EE90&gt;<br/><br/>    def verify_get_region_by_account_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:32: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 2, time = &#x27;start_time&#x27;, sheet_name = &#x27;Regions_Test_Resul&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Regions_Test_Resul&#x27;<br/>row_num = 2, column_no = 9, data = &#x27;15:32:22&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA375190&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Region_Module_API.test_region_api.Test_region_api object at 0x0000028EE9E57B90&gt;<br/><br/>    def test_tags_Test_01(self):<br/>        self.logger.info(&quot;test_region_Test_01  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Region_API_Methods(self.logger).verify_get_region_by_account_id():<br/><br/>All_API_Test_Cases_Package\Region_Module_API\test_region_api.py:10: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x0000028EEA03EE90&gt;<br/><br/>    def verify_get_region_by_account_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_region_request_by_account_id()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:55: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_region_api.py:9 test_region_Test_01  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Region_Module_API/test_region_api.py::Test_region_api::test_tags_Test_02</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x0000028EEA284210&gt;<br/><br/>    def verify_get_region_by_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:65: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 3, time = &#x27;start_time&#x27;, sheet_name = &#x27;Regions_Test_Resul&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Regions_Test_Resul&#x27;<br/>row_num = 3, column_no = 9, data = &#x27;15:32:22&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA2F1A90&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Region_Module_API.test_region_api.Test_region_api object at 0x0000028EE9E56ED0&gt;<br/><br/>    def test_tags_Test_02(self):<br/>        self.logger.info(&quot;test_region_Test_02  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Region_API_Methods(self.logger).verify_get_region_by_id():<br/><br/>All_API_Test_Cases_Package\Region_Module_API\test_region_api.py:17: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x0000028EEA284210&gt;<br/><br/>    def verify_get_region_by_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_request_by_region_id()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:88: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_region_api.py:16 test_region_Test_02  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Region_Module_API/test_region_api.py::Test_region_api::test_tags_Test_03</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x0000028EEA37AED0&gt;<br/><br/>    def verify_get_region_by_region_path(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:98: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 4, time = &#x27;start_time&#x27;, sheet_name = &#x27;Regions_Test_Resul&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Regions_Test_Resul&#x27;<br/>row_num = 4, column_no = 9, data = &#x27;15:32:22&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA1524D0&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Region_Module_API.test_region_api.Test_region_api object at 0x0000028EE9E57050&gt;<br/><br/>    def test_tags_Test_03(self):<br/>        self.logger.info(&quot;test_region_Test_03  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Region_API_Methods(self.logger).verify_get_region_by_region_path():<br/><br/>All_API_Test_Cases_Package\Region_Module_API\test_region_api.py:24: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x0000028EEA37AED0&gt;<br/><br/>    def verify_get_region_by_region_path(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_region_by_region_path()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:121: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_region_api.py:23 test_region_Test_03  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Region_Module_API/test_region_api.py::Test_region_api::test_tags_Test_04</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x0000028EEA325190&gt;<br/><br/>    def verify_get_region_by_descendants(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:131: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 5, time = &#x27;start_time&#x27;, sheet_name = &#x27;Regions_Test_Resul&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Regions_Test_Resul&#x27;<br/>row_num = 5, column_no = 9, data = &#x27;15:32:22&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA1D2810&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Region_Module_API.test_region_api.Test_region_api object at 0x0000028EE9E57810&gt;<br/><br/>    def test_tags_Test_04(self):<br/>        self.logger.info(&quot;test_region_Test_04  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Region_API_Methods(self.logger).verify_get_region_by_descendants():<br/><br/>All_API_Test_Cases_Package\Region_Module_API\test_region_api.py:31: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x0000028EEA325190&gt;<br/><br/>    def verify_get_region_by_descendants(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_request_region_by_descendants()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:154: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_region_api.py:30 test_region_Test_04  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Region_Module_API/test_region_api.py::Test_region_api::test_tags_Test_05</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x0000028EEA264210&gt;<br/><br/>    def verify_create_regions_migrate_events(self):<br/>        result = []<br/>        try:<br/>            self.row = 6<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:164: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 6, time = &#x27;start_time&#x27;, sheet_name = &#x27;Regions_Test_Resul&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Regions_Test_Resul&#x27;<br/>row_num = 6, column_no = 9, data = &#x27;15:32:22&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA180E10&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Region_Module_API.test_region_api.Test_region_api object at 0x0000028EE9E578D0&gt;<br/><br/>    def test_tags_Test_05(self):<br/>        self.logger.info(&quot;test_region_Test_05  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Region_API_Methods(self.logger).verify_create_regions_migrate_events():<br/><br/>All_API_Test_Cases_Package\Region_Module_API\test_region_api.py:38: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x0000028EEA264210&gt;<br/><br/>    def verify_create_regions_migrate_events(self):<br/>        result = []<br/>        try:<br/>            self.row = 6<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_create_regions_migrate_events()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:187: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_region_api.py:37 test_region_Test_05  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Region_Module_API/test_region_api.py::Test_region_api::test_tags_Test_06</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x0000028EEA0C0950&gt;<br/><br/>    def verify_get_regions_by_cameras(self):<br/>        result = []<br/>        try:<br/>            self.row = 7<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:197: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 7, time = &#x27;start_time&#x27;, sheet_name = &#x27;Regions_Test_Resul&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Regions_Test_Resul&#x27;<br/>row_num = 7, column_no = 9, data = &#x27;15:32:22&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA2F2190&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Region_Module_API.test_region_api.Test_region_api object at 0x0000028EE9E56A90&gt;<br/><br/>    def test_tags_Test_06(self):<br/>        self.logger.info(&quot;test_region_Test_06  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Region_API_Methods(self.logger).verify_get_regions_by_cameras():<br/><br/>All_API_Test_Cases_Package\Region_Module_API\test_region_api.py:45: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x0000028EEA0C0950&gt;<br/><br/>    def verify_get_regions_by_cameras(self):<br/>        result = []<br/>        try:<br/>            self.row = 7<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_regions_by_cameras()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:220: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_region_api.py:44 test_region_Test_06  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Region_Module_API/test_region_api.py::Test_region_api::test_tags_Test_07</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x0000028EEA1D3850&gt;<br/><br/>    def verify_update_region_by_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 8<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:230: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 8, time = &#x27;start_time&#x27;, sheet_name = &#x27;Regions_Test_Resul&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Regions_Test_Resul&#x27;<br/>row_num = 8, column_no = 9, data = &#x27;15:32:22&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA284210&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Region_Module_API.test_region_api.Test_region_api object at 0x0000028EE9E55C50&gt;<br/><br/>    def test_tags_Test_07(self):<br/>        self.logger.info(&quot;test_region_Test_07  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Region_API_Methods(self.logger).verify_update_region_by_id():<br/><br/>All_API_Test_Cases_Package\Region_Module_API\test_region_api.py:52: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x0000028EEA1D3850&gt;<br/><br/>    def verify_update_region_by_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 8<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_request_update_region_by_id()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            region_id = response_list[3]<br/>            self.exp_msg = Read_Expected_Region_Response_msg().update_success_msg(region_id)<br/>            self.act_msg = self.json_response[&quot;message&quot;]<br/>            if response_validation(self.response) and self.exp_msg == self.act_msg:<br/>                excel_result(self.row, &quot;Test_07&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_07&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_07&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:255: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_region_api.py:51 test_region_Test_07  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Region_Module_API/test_region_api.py::Test_region_api::test_tags_Test_08</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x0000028EEA08CF50&gt;<br/><br/>    def verify_regions_import(self):<br/>        result = []<br/>        try:<br/>            self.row = 9<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:265: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 9, time = &#x27;start_time&#x27;, sheet_name = &#x27;Regions_Test_Resul&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Regions_Test_Resul&#x27;<br/>row_num = 9, column_no = 9, data = &#x27;15:32:23&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA1F5010&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Region_Module_API.test_region_api.Test_region_api object at 0x0000028EE9E563D0&gt;<br/><br/>    def test_tags_Test_08(self):<br/>        self.logger.info(&quot;test_region_Test_08  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Region_API_Methods(self.logger).verify_regions_import():<br/><br/>All_API_Test_Cases_Package\Region_Module_API\test_region_api.py:59: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x0000028EEA08CF50&gt;<br/><br/>    def verify_regions_import(self):<br/>        result = []<br/>        try:<br/>            self.row = 9<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_regions_import()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response) or invalid_response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:286: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_region_api.py:58 test_region_Test_08  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Region_Module_API/test_region_api.py::Test_region_api::test_tags_Test_09</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x0000028EEA232350&gt;<br/><br/>    def varify_create_regions_by_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 10<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:296: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 10, time = &#x27;start_time&#x27;, sheet_name = &#x27;Regions_Test_Resul&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Regions_Test_Resul&#x27;<br/>row_num = 10, column_no = 9, data = &#x27;15:32:23&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA259DD0&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Region_Module_API.test_region_api.Test_region_api object at 0x0000028EE9E55510&gt;<br/><br/>    def test_tags_Test_09(self):<br/>        self.logger.info(&quot;test_region_Test_09  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Region_API_Methods(self.logger).varify_create_regions_by_id():<br/><br/>All_API_Test_Cases_Package\Region_Module_API\test_region_api.py:66: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x0000028EEA232350&gt;<br/><br/>    def varify_create_regions_by_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 10<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = create_request_regions()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            self.r_body = response_list[2]<br/>            region_id = response_list[3]<br/>            self.act_msg = self.json_response[&quot;message&quot;]<br/>            self.exp_msg = Read_Expected_Region_Response_msg().create_success_msg(region_id)<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_09&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_09&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_09&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:321: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_region_api.py:65 test_region_Test_09  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Region_Module_API/test_region_api.py::Test_region_api::test_tags_Test_10</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x0000028EEA2843D0&gt;<br/><br/>    def varify_create_regions_by_id_descendants(self):<br/>        result = []<br/>        try:<br/>            self.row = 11<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:331: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 11, time = &#x27;start_time&#x27;, sheet_name = &#x27;Regions_Test_Resul&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Regions_Test_Resul&#x27;<br/>row_num = 11, column_no = 9, data = &#x27;15:32:23&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA099350&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Region_Module_API.test_region_api.Test_region_api object at 0x0000028EE9E54750&gt;<br/><br/>    def test_tags_Test_10(self):<br/>        self.logger.info(&quot;test_region_Test_10  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Region_API_Methods(self.logger).varify_create_regions_by_id_descendants():<br/><br/>All_API_Test_Cases_Package\Region_Module_API\test_region_api.py:73: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x0000028EEA2843D0&gt;<br/><br/>    def varify_create_regions_by_id_descendants(self):<br/>        result = []<br/>        try:<br/>            self.row = 11<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = create_request_regions_by_descendants()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            self.r_body = response_list[2]<br/>            region_id = response_list[3]<br/>            self.act_msg = self.json_response[&quot;message&quot;]<br/>            self.exp_msg = Read_Expected_Region_Response_msg().create_success_msg(region_id)<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_10&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_10&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_10&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:356: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_region_api.py:72 test_region_Test_10  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Region_Module_API/test_region_api.py::Test_region_api::test_tags_Test_11</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x0000028EEA1811D0&gt;<br/><br/>    def varify_create_regions_by_move(self):<br/>        result = []<br/>        try:<br/>            self.row = 12<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:366: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 12, time = &#x27;start_time&#x27;, sheet_name = &#x27;Regions_Test_Resul&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Regions_Test_Resul&#x27;<br/>row_num = 12, column_no = 9, data = &#x27;15:32:23&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA144690&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Region_Module_API.test_region_api.Test_region_api object at 0x0000028EE9E54ED0&gt;<br/><br/>    def test_tags_Test_11(self):<br/>        self.logger.info(&quot;test_region_Test_11  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Region_API_Methods(self.logger).varify_create_regions_by_move():<br/><br/>All_API_Test_Cases_Package\Region_Module_API\test_region_api.py:80: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x0000028EEA1811D0&gt;<br/><br/>    def varify_create_regions_by_move(self):<br/>        result = []<br/>        try:<br/>            self.row = 12<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = create_request_regions_by_move()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            self.r_body = response_list[2]<br/>            region_id = response_list[3]<br/>            self.act_msg = self.json_response[&quot;message&quot;]<br/>            self.exp_msg = Read_Expected_Region_Response_msg().update_success_msg(region_id)<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_11&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_11&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_11&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:391: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_region_api.py:79 test_region_Test_11  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Region_Module_API/test_region_api.py::Test_region_api::test_tags_Test_12</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x0000028EEA09E8D0&gt;<br/><br/>    def varify_delete_regions(self):<br/>        result = []<br/>        try:<br/>            self.row = 13<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:401: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 13, time = &#x27;start_time&#x27;, sheet_name = &#x27;Regions_Test_Resul&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Regions_Test_Resul&#x27;<br/>row_num = 13, column_no = 9, data = &#x27;15:32:23&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EE9DD1A50&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Region_Module_API.test_region_api.Test_region_api object at 0x0000028EE9D9F210&gt;<br/><br/>    def test_tags_Test_12(self):<br/>        self.logger.info(&quot;test_region_Test_12  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Region_API_Methods(self.logger).varify_delete_regions():<br/><br/>All_API_Test_Cases_Package\Region_Module_API\test_region_api.py:87: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x0000028EEA09E8D0&gt;<br/><br/>    def varify_delete_regions(self):<br/>        result = []<br/>        try:<br/>            self.row = 13<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = delete_region_request()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            region_id = response_list[2]<br/>            self.act_msg = self.json_response[&quot;message&quot;]<br/>            self.exp_msg = Read_Expected_Region_Response_msg().delete_success_msg(region_id)<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_12&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_12&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_12&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:425: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_region_api.py:86 test_region_Test_12  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Tags_Module_API/test_tags_api.py::Test_tags_api::test_tags_Test_01</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Tags_Module_API.Tags_API_Methods.Tags_API_Methods object at 0x0000028EEA2868D0&gt;<br/><br/>    def verify_create_tags_with_valid_data(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Tags_Module_API\Tags_API_Methods.py:27: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 2, time = &#x27;start_time&#x27;, sheet_name = &#x27;Tags_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Tags_Test_Results&#x27;<br/>row_num = 2, column_no = 9, data = &#x27;15:32:24&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA1F5E90&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Tags_Module_API.test_tags_api.Test_tags_api object at 0x0000028EE9EC3390&gt;<br/><br/>    def test_tags_Test_01(self):<br/>        self.logger.info(&quot;test_tags_Test_01  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Tags_API_Methods(self.logger).verify_create_tags_with_valid_data():<br/><br/>All_API_Test_Cases_Package\Tags_Module_API\test_tags_api.py:10: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Tags_Module_API.Tags_API_Methods.Tags_API_Methods object at 0x0000028EEA2868D0&gt;<br/><br/>    def verify_create_tags_with_valid_data(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = create_tags_request(self.row)<br/>    <br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>    <br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Tags_Module_API\Tags_API_Methods.py:50: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_tags_api.py:9 test_tags_Test_01  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Tags_Module_API/test_tags_api.py::Test_tags_api::test_tags_Test_02</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Tags_Module_API.Tags_API_Methods.Tags_API_Methods object at 0x0000028EEA0B6C10&gt;<br/><br/>    def verify_all_get_tag_data(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Tags_Module_API\Tags_API_Methods.py:60: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 3, time = &#x27;start_time&#x27;, sheet_name = &#x27;Tags_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Tags_Test_Results&#x27;<br/>row_num = 3, column_no = 9, data = &#x27;15:32:24&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA0B50D0&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Tags_Module_API.test_tags_api.Test_tags_api object at 0x0000028EE9EC1090&gt;<br/><br/>    def test_tags_Test_02(self):<br/>        self.logger.info(&quot;test_tags_Test_02  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Tags_API_Methods(self.logger).verify_all_get_tag_data():<br/><br/>All_API_Test_Cases_Package\Tags_Module_API\test_tags_api.py:17: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Tags_Module_API.Tags_API_Methods.Tags_API_Methods object at 0x0000028EEA0B6C10&gt;<br/><br/>    def verify_all_get_tag_data(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_all_tags()<br/>            print(response_list)<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>    <br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Tags_Module_API\Tags_API_Methods.py:83: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_tags_api.py:16 test_tags_Test_02  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Tags_Module_API/test_tags_api.py::Test_tags_api::test_tags_Test_03</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Tags_Module_API.Tags_API_Methods.Tags_API_Methods object at 0x0000028EEA0E55D0&gt;<br/><br/>    def verify_update_tag_with_valid_data(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Tags_Module_API\Tags_API_Methods.py:93: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 4, time = &#x27;start_time&#x27;, sheet_name = &#x27;Tags_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Tags_Test_Results&#x27;<br/>row_num = 4, column_no = 9, data = &#x27;15:32:24&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EE9D63510&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Tags_Module_API.test_tags_api.Test_tags_api object at 0x0000028EE9EC1ED0&gt;<br/><br/>    def test_tags_Test_03(self):<br/>        self.logger.info(&quot;test_tags_Test_03  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Tags_API_Methods(self.logger).verify_update_tag_with_valid_data():<br/><br/>All_API_Test_Cases_Package\Tags_Module_API\test_tags_api.py:24: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Tags_Module_API.Tags_API_Methods.Tags_API_Methods object at 0x0000028EEA0E55D0&gt;<br/><br/>    def verify_update_tag_with_valid_data(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = update_tags_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>    <br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Tags_Module_API\Tags_API_Methods.py:116: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_tags_api.py:23 test_tags_Test_03  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Tags_Module_API/test_tags_api.py::Test_tags_api::test_tags_Test_04</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Tags_Module_API.Tags_API_Methods.Tags_API_Methods object at 0x0000028EEA09C8D0&gt;<br/><br/>    def verify_delete_tags_with_valid_tag_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Tags_Module_API\Tags_API_Methods.py:126: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 5, time = &#x27;start_time&#x27;, sheet_name = &#x27;Tags_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Tags_Test_Results&#x27;<br/>row_num = 5, column_no = 9, data = &#x27;15:32:24&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA09D1D0&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Tags_Module_API.test_tags_api.Test_tags_api object at 0x0000028EE9EC3DD0&gt;<br/><br/>    def test_tags_Test_04(self):<br/>        self.logger.info(&quot;test_tags_Test_04  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Tags_API_Methods(self.logger).verify_delete_tags_with_valid_tag_id():<br/><br/>All_API_Test_Cases_Package\Tags_Module_API\test_tags_api.py:31: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Tags_Module_API.Tags_API_Methods.Tags_API_Methods object at 0x0000028EEA09C8D0&gt;<br/><br/>    def verify_delete_tags_with_valid_tag_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = del_tags_by_id_request()<br/>            print(response_list)<br/>            self.response = response_list[0]<br/>            print(self.response)<br/>            self.json_response = response_list[1]<br/>            # self.act_msg = response_list[2]<br/>            # self.exp_msg = response_list[3]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Tags_Module_API\Tags_API_Methods.py:151: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_tags_api.py:30 test_tags_Test_04  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Tags_Module_API/test_tags_api.py::Test_tags_api::test_tags_Test_05</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Tags_Module_API.Tags_API_Methods.Tags_API_Methods object at 0x0000028EE9E72ED0&gt;<br/><br/>    def verify_create_tag_with_tag_alert(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Tags_Module_API\Tags_API_Methods.py:161: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 2, time = &#x27;start_time&#x27;, sheet_name = &#x27;Tags_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Tags_Test_Results&#x27;<br/>row_num = 2, column_no = 9, data = &#x27;15:32:24&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA0B66D0&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Tags_Module_API.test_tags_api.Test_tags_api object at 0x0000028EE9EC2350&gt;<br/><br/>    def test_tags_Test_05(self):<br/>        self.logger.info(&quot;test_tags_Test_05  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Tags_API_Methods(self.logger).verify_create_tag_with_tag_alert():<br/><br/>All_API_Test_Cases_Package\Tags_Module_API\test_tags_api.py:38: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Tags_Module_API.Tags_API_Methods.Tags_API_Methods object at 0x0000028EE9E72ED0&gt;<br/><br/>    def verify_create_tag_with_tag_alert(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = create_tags_request(self.row)<br/>    <br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>    <br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;Test_05&quot;, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Tags_Module_API\Tags_API_Methods.py:184: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_tags_api.py:37 test_tags_Test_05  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/User_Role_Module_API/test_user_role_api.py::Test_user_role_api::test_user_role_Test_01</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.User_Roles_Module_API.User_Role_Methods.User_Role_API_Methods object at 0x0000028EEA209790&gt;<br/><br/>    def verify_create_user_role_with_valid_data_in_enable_mode(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\User_Roles_Module_API\User_Role_Methods.py:27: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 2, time = &#x27;start_time&#x27;, sheet_name = &#x27;User_Role_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;User_Role_Test_Results&#x27;<br/>row_num = 2, column_no = 9, data = &#x27;15:32:24&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA2BC350&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.User_Role_Module_API.test_user_role_api.Test_user_role_api object at 0x0000028EE9DF5150&gt;<br/><br/>    def test_user_role_Test_01(self):<br/>        self.logger.info(&quot;test_user_role_Test_01  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if User_Role_API_Methods(self.logger).verify_create_user_role_with_valid_data_in_enable_mode():<br/><br/>All_API_Test_Cases_Package\User_Role_Module_API\test_user_role_api.py:11: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.User_Roles_Module_API.User_Role_Methods.User_Role_API_Methods object at 0x0000028EEA209790&gt;<br/><br/>    def verify_create_user_role_with_valid_data_in_enable_mode(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = create_user_role_request(self.row)<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.act_msg = self.json_response[&quot;roleName&quot;]<br/>            self.exp_msg = response_list[3]<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\User_Roles_Module_API\User_Role_Methods.py:53: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_user_role_api.py:10 test_user_role_Test_01  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/User_Role_Module_API/test_user_role_api.py::Test_user_role_api::test_user_role_Test_02</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.User_Roles_Module_API.User_Role_Methods.User_Role_API_Methods object at 0x0000028EEA285E50&gt;<br/><br/>    def verify_get_single_user_role_by_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\User_Roles_Module_API\User_Role_Methods.py:63: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 3, time = &#x27;start_time&#x27;, sheet_name = &#x27;User_Role_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;User_Role_Test_Results&#x27;<br/>row_num = 3, column_no = 9, data = &#x27;15:32:24&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA1EE5D0&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.User_Role_Module_API.test_user_role_api.Test_user_role_api object at 0x0000028EE9DF5B50&gt;<br/><br/>    def test_user_role_Test_02(self):<br/>        self.logger.info(&quot;test_user_role_Test_02  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if User_Role_API_Methods(self.logger).verify_get_single_user_role_by_id():<br/><br/>All_API_Test_Cases_Package\User_Role_Module_API\test_user_role_api.py:18: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.User_Roles_Module_API.User_Role_Methods.User_Role_API_Methods object at 0x0000028EEA285E50&gt;<br/><br/>    def verify_get_single_user_role_by_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_user_role_by_id_request()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            self.act_msg = response_list[2]<br/>            self.exp_msg = response_list[3]<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\User_Roles_Module_API\User_Role_Methods.py:88: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_user_role_api.py:17 test_user_role_Test_02  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/User_Role_Module_API/test_user_role_api.py::Test_user_role_api::test_user_role_Test_03</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.User_Roles_Module_API.User_Role_Methods.User_Role_API_Methods object at 0x0000028EE9E76550&gt;<br/><br/>    def verify_update_user_role_with_valid_data(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\User_Roles_Module_API\User_Role_Methods.py:98: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 4, time = &#x27;start_time&#x27;, sheet_name = &#x27;User_Role_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;User_Role_Test_Results&#x27;<br/>row_num = 4, column_no = 9, data = &#x27;15:32:24&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA387D50&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.User_Role_Module_API.test_user_role_api.Test_user_role_api object at 0x0000028EE9DF5410&gt;<br/><br/>    def test_user_role_Test_03(self):<br/>        self.logger.info(&quot;test_user_role_Test_03  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if User_Role_API_Methods(self.logger).verify_update_user_role_with_valid_data():<br/><br/>All_API_Test_Cases_Package\User_Role_Module_API\test_user_role_api.py:25: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.User_Roles_Module_API.User_Role_Methods.User_Role_API_Methods object at 0x0000028EE9E76550&gt;<br/><br/>    def verify_update_user_role_with_valid_data(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = update_user_role_request(self.row)<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.act_msg = self.json_response[&quot;roleName&quot;]<br/>            self.exp_msg = response_list[3]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\User_Roles_Module_API\User_Role_Methods.py:124: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_user_role_api.py:24 test_user_role_Test_03  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/User_Role_Module_API/test_user_role_api.py::Test_user_role_api::test_user_role_Test_04</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.User_Roles_Module_API.User_Role_Methods.User_Role_API_Methods object at 0x0000028EEA246A90&gt;<br/><br/>    def verify_delete_user_role_with_valid_user_role_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\User_Roles_Module_API\User_Role_Methods.py:134: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 5, time = &#x27;start_time&#x27;, sheet_name = &#x27;User_Role_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;User_Role_Test_Results&#x27;<br/>row_num = 5, column_no = 9, data = &#x27;15:32:25&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA3C2650&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.User_Role_Module_API.test_user_role_api.Test_user_role_api object at 0x0000028EE9DF7A50&gt;<br/><br/>    def test_user_role_Test_04(self):<br/>        self.logger.info(&quot;test_user_role_Test_04  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if User_Role_API_Methods(self.logger).verify_delete_user_role_with_valid_user_role_id():<br/><br/>All_API_Test_Cases_Package\User_Role_Module_API\test_user_role_api.py:32: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.User_Roles_Module_API.User_Role_Methods.User_Role_API_Methods object at 0x0000028EEA246A90&gt;<br/><br/>    def verify_delete_user_role_with_valid_user_role_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = del_user_role_by_id_request()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            # self.act_msg = response_list[2]<br/>            # self.exp_msg = response_list[3]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\User_Roles_Module_API\User_Role_Methods.py:159: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_user_role_api.py:31 test_user_role_Test_04  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/User_Role_Module_API/test_user_role_api.py::Test_user_role_api::test_user_role_Test_05</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.User_Roles_Module_API.User_Role_Methods.User_Role_API_Methods object at 0x0000028EEA590850&gt;<br/><br/>    def verify_all_get_user_roles(self):<br/>        result = []<br/>        try:<br/>            self.row = 6<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\User_Roles_Module_API\User_Role_Methods.py:169: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 6, time = &#x27;start_time&#x27;, sheet_name = &#x27;User_Role_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;User_Role_Test_Results&#x27;<br/>row_num = 6, column_no = 9, data = &#x27;15:32:25&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA056E10&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.User_Role_Module_API.test_user_role_api.Test_user_role_api object at 0x0000028EE9DF5190&gt;<br/><br/>    def test_user_role_Test_05(self):<br/>        self.logger.info(&quot;test_user_role_Test_05  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if User_Role_API_Methods(self.logger).verify_all_get_user_roles():<br/><br/>All_API_Test_Cases_Package\User_Role_Module_API\test_user_role_api.py:39: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.User_Roles_Module_API.User_Role_Methods.User_Role_API_Methods object at 0x0000028EEA590850&gt;<br/><br/>    def verify_all_get_user_roles(self):<br/>        result = []<br/>        try:<br/>            self.row = 6<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_all_user_role()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            self.act_msg = response_list[2]<br/>            self.exp_msg = response_list[3]<br/>            if response_validation(self.response) and self.act_msg in self.exp_msg:<br/>                excel_result(self.row,&quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row,&quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\User_Roles_Module_API\User_Role_Methods.py:194: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_user_role_api.py:38 test_user_role_Test_05  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/User_Role_Module_API/test_user_role_api.py::Test_user_role_api::test_user_role_Test_06</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.User_Roles_Module_API.User_Role_Methods.User_Role_API_Methods object at 0x0000028EEA270410&gt;<br/><br/>    def verify_the_user_role_is_created_with_valid_data_in_disable_mode(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\User_Roles_Module_API\User_Role_Methods.py:204: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 3, time = &#x27;start_time&#x27;, sheet_name = &#x27;User_Role_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;User_Role_Test_Results&#x27;<br/>row_num = 3, column_no = 9, data = &#x27;15:32:25&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA2EC410&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.User_Role_Module_API.test_user_role_api.Test_user_role_api object at 0x0000028EE9DF5090&gt;<br/><br/>    def test_user_role_Test_06(self):<br/>        self.logger.info(&quot;test_user_role_Test_06  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if User_Role_API_Methods(self.logger).verify_the_user_role_is_created_with_valid_data_in_disable_mode():<br/><br/>All_API_Test_Cases_Package\User_Role_Module_API\test_user_role_api.py:46: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.User_Roles_Module_API.User_Role_Methods.User_Role_API_Methods object at 0x0000028EEA270410&gt;<br/><br/>    def verify_the_user_role_is_created_with_valid_data_in_disable_mode(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = create_user_role_request(self.row)<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.act_msg = self.json_response[&quot;roleName&quot;]<br/>            self.exp_msg = response_list[3]<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\User_Roles_Module_API\User_Role_Methods.py:230: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_user_role_api.py:45 test_user_role_Test_06  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Users_Module_API/test_users_api.py::Test_Users_api::test_Users_Test_01</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000028EE9E74B50&gt;<br/><br/>    def verify_create_user_with_valid_information_in_enabled_mode(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:27: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 2, time = &#x27;start_time&#x27;, sheet_name = &#x27;Users_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Users_Test_Results&#x27;<br/>row_num = 2, column_no = 9, data = &#x27;15:32:25&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA039550&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Users_Module_API.test_users_api.Test_Users_api object at 0x0000028EE9F12450&gt;<br/><br/>    def test_Users_Test_01(self):<br/>        self.logger.info(&quot;test_Users_Test_01  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Users_API_Methods(self.logger).verify_create_user_with_valid_information_in_enabled_mode():<br/><br/>All_API_Test_Cases_Package\Users_Module_API\test_users_api.py:10: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000028EE9E74B50&gt;<br/><br/>    def verify_create_user_with_valid_information_in_enabled_mode(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = user_create_request(self.row)<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.act_msg = self.json_response[&quot;status&quot;]<br/>            self.exp_msg = Read_Expected_users_Response_msg().users_success_msg()<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:51: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_users_api.py:9 test_Users_Test_01  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Users_Module_API/test_users_api.py::Test_Users_api::test_Users_Test_02</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000028EEA4A1390&gt;<br/><br/>    def verify_create_user_with_mandatory_information_in_enabled_mode(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:61: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 3, time = &#x27;start_time&#x27;, sheet_name = &#x27;Users_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Users_Test_Results&#x27;<br/>row_num = 3, column_no = 9, data = &#x27;15:32:25&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA1D1E50&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Users_Module_API.test_users_api.Test_Users_api object at 0x0000028EE9F13E50&gt;<br/><br/>    def test_Users_Test_02(self):<br/>        self.logger.info(&quot;test_Users_Test_02  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Users_API_Methods(self.logger).verify_create_user_with_mandatory_information_in_enabled_mode():<br/><br/>All_API_Test_Cases_Package\Users_Module_API\test_users_api.py:17: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000028EEA4A1390&gt;<br/><br/>    def verify_create_user_with_mandatory_information_in_enabled_mode(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = user_create_request(self.row)<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.act_msg = self.json_response[&quot;status&quot;]<br/>            self.exp_msg = Read_Expected_users_Response_msg().users_success_msg()<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:87: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_users_api.py:16 test_Users_Test_02  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Users_Module_API/test_users_api.py::Test_Users_api::test_Users_Test_03</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000028EEA484D10&gt;<br/><br/>    def verify_create_user_with_valid_information_in_disabled_mode(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:97: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 4, time = &#x27;start_time&#x27;, sheet_name = &#x27;Users_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Users_Test_Results&#x27;<br/>row_num = 4, column_no = 9, data = &#x27;15:32:25&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EE9E576D0&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Users_Module_API.test_users_api.Test_Users_api object at 0x0000028EE9F13250&gt;<br/><br/>    def test_Users_Test_03(self):<br/>        self.logger.info(&quot;test_Users_Test_03  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Users_API_Methods(self.logger).verify_create_user_with_valid_information_in_disabled_mode():<br/><br/>All_API_Test_Cases_Package\Users_Module_API\test_users_api.py:24: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000028EEA484D10&gt;<br/><br/>    def verify_create_user_with_valid_information_in_disabled_mode(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = user_create_request(self.row)<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.act_msg = self.json_response[&quot;status&quot;]<br/>            self.exp_msg = Read_Expected_users_Response_msg().users_success_msg()<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:123: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_users_api.py:23 test_Users_Test_03  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Users_Module_API/test_users_api.py::Test_Users_api::test_Users_Test_04</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000028EEA3C1090&gt;<br/><br/>    def verify_create_user_with_mandatory_fields_in_disable_mode(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:133: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 5, time = &#x27;start_time&#x27;, sheet_name = &#x27;Users_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Users_Test_Results&#x27;<br/>row_num = 5, column_no = 9, data = &#x27;15:32:26&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EE9D96D10&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Users_Module_API.test_users_api.Test_Users_api object at 0x0000028EE9F13410&gt;<br/><br/>    def test_Users_Test_04(self):<br/>        self.logger.info(&quot;test_Users_Test_04  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Users_API_Methods(self.logger).verify_create_user_with_mandatory_fields_in_disable_mode():<br/><br/>All_API_Test_Cases_Package\Users_Module_API\test_users_api.py:31: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000028EEA3C1090&gt;<br/><br/>    def verify_create_user_with_mandatory_fields_in_disable_mode(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = user_create_request(self.row)<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.act_msg = self.json_response[&quot;status&quot;]<br/>            self.exp_msg = Read_Expected_users_Response_msg().users_success_msg()<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:157: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_users_api.py:30 test_Users_Test_04  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Users_Module_API/test_users_api.py::Test_Users_api::test_Users_Test_06</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000028EEA4676D0&gt;<br/><br/>    def verify_users_update_alert_schedule(self):<br/>        result = []<br/>        try:<br/>            self.row = 7<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:328: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 7, time = &#x27;start_time&#x27;, sheet_name = &#x27;Users_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Users_Test_Results&#x27;<br/>row_num = 7, column_no = 9, data = &#x27;15:32:26&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA2E8710&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Users_Module_API.test_users_api.Test_Users_api object at 0x0000028EE9F136D0&gt;<br/><br/>    def test_Users_Test_06(self):<br/>        self.logger.info(&quot;test_Users_Test_06  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Users_API_Methods(self.logger).verify_users_update_alert_schedule():<br/><br/>All_API_Test_Cases_Package\Users_Module_API\test_users_api.py:38: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000028EEA4676D0&gt;<br/><br/>    def verify_users_update_alert_schedule(self):<br/>        result = []<br/>        try:<br/>            self.row = 7<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = users_update_alert_schedule_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.act_msg = self.json_response[&quot;data&quot;]<br/>            self.exp_msg = Read_Expected_users_Response_msg().user_update_alert_schedule_msg()<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:352: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_users_api.py:37 test_Users_Test_06  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Users_Module_API/test_users_api.py::Test_Users_api::test_Users_Test_07</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000028EEA510310&gt;<br/><br/>    def verify_create_users_using_json(self):<br/>        result = []<br/>        try:<br/>            self.row = 8<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:362: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 8, time = &#x27;start_time&#x27;, sheet_name = &#x27;Users_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Users_Test_Results&#x27;<br/>row_num = 8, column_no = 9, data = &#x27;15:32:26&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA7DCC10&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Users_Module_API.test_users_api.Test_Users_api object at 0x0000028EE9F125D0&gt;<br/><br/>    def test_Users_Test_07(self):<br/>        self.logger.info(&quot;test_Users_Test_07  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Users_API_Methods(self.logger).verify_create_users_using_json():<br/><br/>All_API_Test_Cases_Package\Users_Module_API\test_users_api.py:45: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000028EEA510310&gt;<br/><br/>    def verify_create_users_using_json(self):<br/>        result = []<br/>        try:<br/>            self.row = 8<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = create_users_using_json()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.act_msg = self.json_response[&quot;status&quot;]<br/>            self.exp_msg = Read_Expected_users_Response_msg().user_create_msg()<br/>            act_username = self.json_response[&quot;userName&quot;]<br/>            exp_username = response_list[3]<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg and act_username == exp_username:<br/>                excel_result(self.row, &quot;Test_07&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_07&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_07&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:388: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_users_api.py:44 test_Users_Test_07  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Users_Module_API/test_users_api.py::Test_Users_api::test_Users_Test_08</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000028EE9FAA990&gt;<br/><br/>    def verify_edit_user_with_mandatory_information(self):<br/>        result = []<br/>        try:<br/>            self.row = 9<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:167: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 9, time = &#x27;start_time&#x27;, sheet_name = &#x27;Users_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Users_Test_Results&#x27;<br/>row_num = 9, column_no = 9, data = &#x27;15:32:26&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA2E9610&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Users_Module_API.test_users_api.Test_Users_api object at 0x0000028EE9F11910&gt;<br/><br/>    def test_Users_Test_08(self):<br/>        self.logger.info(&quot;test_Users_Test_08  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Users_API_Methods(self.logger).verify_edit_user_with_mandatory_information():<br/><br/>All_API_Test_Cases_Package\Users_Module_API\test_users_api.py:52: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000028EE9FAA990&gt;<br/><br/>    def verify_edit_user_with_mandatory_information(self):<br/>        result = []<br/>        try:<br/>            self.row = 9<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = edite_user_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.act_msg = self.json_response[&quot;message&quot;]<br/>            self.exp_msg = f&quot;User  {self.json_response[&#x27;data&#x27;]} is updated.&quot;<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:191: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_users_api.py:51 test_Users_Test_08  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Users_Module_API/test_users_api.py::Test_Users_api::test_Users_Test_09</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000028EEA07F010&gt;<br/><br/>    def verify_edit_user_password(self):<br/>        result = []<br/>        try:<br/>            self.row = 9<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:201: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 9, time = &#x27;start_time&#x27;, sheet_name = &#x27;Users_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Users_Test_Results&#x27;<br/>row_num = 9, column_no = 9, data = &#x27;15:32:26&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA7DD2D0&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Users_Module_API.test_users_api.Test_Users_api object at 0x0000028EE9F12250&gt;<br/><br/>    def test_Users_Test_09(self):<br/>        self.logger.info(&quot;test_Users_Test_09  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Users_API_Methods(self.logger).verify_edit_user_password():<br/><br/>All_API_Test_Cases_Package\Users_Module_API\test_users_api.py:59: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000028EEA07F010&gt;<br/><br/>    def verify_edit_user_password(self):<br/>        result = []<br/>        try:<br/>            self.row = 9<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = edit_user_password()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.act_msg = self.json_response[&quot;message&quot;]<br/>            self.exp_msg = Read_Expected_users_Response_msg().edit_password_success_msg()<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:225: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_users_api.py:58 test_Users_Test_09  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Users_Module_API/test_users_api.py::Test_Users_api::test_Users_Test_10</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000028EE9F128D0&gt;<br/><br/>    def verify_edite_user_with_json_data(self):<br/>        result = []<br/>        try:<br/>            self.row = 11<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:398: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 11, time = &#x27;start_time&#x27;, sheet_name = &#x27;Users_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Users_Test_Results&#x27;<br/>row_num = 11, column_no = 9, data = &#x27;15:32:27&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA43D1D0&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Users_Module_API.test_users_api.Test_Users_api object at 0x0000028EE9F11090&gt;<br/><br/>    def test_Users_Test_10(self):<br/>        self.logger.info(&quot;test_Users_Test_10  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Users_API_Methods(self.logger).verify_edite_user_with_json_data():<br/><br/>All_API_Test_Cases_Package\Users_Module_API\test_users_api.py:66: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000028EE9F128D0&gt;<br/><br/>    def verify_edite_user_with_json_data(self):<br/>        result = []<br/>        try:<br/>            self.row = 11<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = edite_user_json_data_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            user_id = response_list[3]<br/>            self.act_msg = self.json_response[&quot;message&quot;]<br/>            self.exp_msg = Read_Expected_users_Response_msg().edit_user_success_msg(user_id)<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_10&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_10&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_10&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:423: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_users_api.py:65 test_Users_Test_10  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Users_Module_API/test_users_api.py::Test_Users_api::test_Users_Test_11</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000028EE9FA4AD0&gt;<br/><br/>    def verify_get_users_api(self):<br/>        result = []<br/>        try:<br/>            self.row = 12<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:235: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 12, time = &#x27;start_time&#x27;, sheet_name = &#x27;Users_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Users_Test_Results&#x27;<br/>row_num = 12, column_no = 9, data = &#x27;15:32:27&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA0E5FD0&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Users_Module_API.test_users_api.Test_Users_api object at 0x0000028EE9F11850&gt;<br/><br/>    def test_Users_Test_11(self):<br/>        self.logger.info(&quot;test_Users_Test_11  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Users_API_Methods(self.logger).verify_get_users_api():<br/><br/>All_API_Test_Cases_Package\Users_Module_API\test_users_api.py:73: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000028EE9FA4AD0&gt;<br/><br/>    def verify_get_users_api(self):<br/>        result = []<br/>        try:<br/>            self.row = 12<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_user_request()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_11&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_11&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_11&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:256: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_users_api.py:72 test_Users_Test_11  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Users_Module_API/test_users_api.py::Test_Users_api::test_Users_Test_12</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000028EEA43D1D0&gt;<br/><br/>    def verify_get_user_by_account_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 13<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:266: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 13, time = &#x27;start_time&#x27;, sheet_name = &#x27;Users_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Users_Test_Results&#x27;<br/>row_num = 13, column_no = 9, data = &#x27;15:32:27&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA049B90&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Users_Module_API.test_users_api.Test_Users_api object at 0x0000028EE9F10D50&gt;<br/><br/>    def test_Users_Test_12(self):<br/>        self.logger.info(&quot;test_Users_Test_12  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Users_API_Methods(self.logger).verify_get_user_by_account_id():<br/><br/>All_API_Test_Cases_Package\Users_Module_API\test_users_api.py:80: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000028EEA43D1D0&gt;<br/><br/>    def verify_get_user_by_account_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 13<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_user_request_by_account_id()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_12&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_12&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_12&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:287: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_users_api.py:79 test_Users_Test_12  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Users_Module_API/test_users_api.py::Test_Users_api::test_Users_Test_13</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000028EEA0E5990&gt;<br/><br/>    def verify_get_user_by_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 14<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:297: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 14, time = &#x27;start_time&#x27;, sheet_name = &#x27;Users_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Users_Test_Results&#x27;<br/>row_num = 14, column_no = 9, data = &#x27;15:32:27&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA26C390&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Users_Module_API.test_users_api.Test_Users_api object at 0x0000028EE9F10410&gt;<br/><br/>    def test_Users_Test_13(self):<br/>        self.logger.info(&quot;test_Users_Test_13  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Users_API_Methods(self.logger).verify_get_user_by_id():<br/><br/>All_API_Test_Cases_Package\Users_Module_API\test_users_api.py:87: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000028EEA0E5990&gt;<br/><br/>    def verify_get_user_by_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 14<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_user_by_id_request()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_13&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_13&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_13&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:318: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_users_api.py:86 test_Users_Test_13  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Users_Module_API/test_users_api.py::Test_Users_api::test_Users_Test_14</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000028EEA513410&gt;<br/><br/>    def verify_get_user_info(self):<br/>        result = []<br/>        try:<br/>            self.row = 15<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:433: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 15, time = &#x27;start_time&#x27;, sheet_name = &#x27;Users_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Users_Test_Results&#x27;<br/>row_num = 15, column_no = 9, data = &#x27;15:32:27&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA334310&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Users_Module_API.test_users_api.Test_Users_api object at 0x0000028EE9E708D0&gt;<br/><br/>    def test_Users_Test_14(self):<br/>        self.logger.info(&quot;test_Users_Test_14  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Users_API_Methods(self.logger).verify_get_user_info():<br/><br/>All_API_Test_Cases_Package\Users_Module_API\test_users_api.py:94: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000028EEA513410&gt;<br/><br/>    def verify_get_user_info(self):<br/>        result = []<br/>        try:<br/>            self.row = 15<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_user_info_request()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_14&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_14&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_14&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:454: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_users_api.py:93 test_Users_Test_14  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Users_Module_API/test_users_api.py::Test_Users_api::test_Users_Test_15</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000028EEA4BF250&gt;<br/><br/>    def verify_get_service_user_true(self):<br/>        result = []<br/>        try:<br/>            self.row = 16<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:464: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 16, time = &#x27;start_time&#x27;, sheet_name = &#x27;Users_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Users_Test_Results&#x27;<br/>row_num = 16, column_no = 9, data = &#x27;15:32:28&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA26E5D0&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Users_Module_API.test_users_api.Test_Users_api object at 0x0000028EE9E706D0&gt;<br/><br/>    def test_Users_Test_15(self):<br/>        self.logger.info(&quot;test_Users_Test_15  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Users_API_Methods(self.logger).verify_get_service_user_true():<br/><br/>All_API_Test_Cases_Package\Users_Module_API\test_users_api.py:101: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000028EEA4BF250&gt;<br/><br/>    def verify_get_service_user_true(self):<br/>        result = []<br/>        try:<br/>            self.row = 16<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_service_user_true_request()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response) and validate_response_is_service_user(self.json_response):<br/>                excel_result(self.row, &quot;Test_15&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_15&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_15&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:485: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_users_api.py:100 test_Users_Test_15  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Users_Module_API/test_users_api.py::Test_Users_api::test_Users_Test_16</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000028EEA335590&gt;<br/><br/>    def verify_get_service_user_false(self):<br/>        result = []<br/>        try:<br/>            self.row = 17<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:495: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 17, time = &#x27;start_time&#x27;, sheet_name = &#x27;Users_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Users_Test_Results&#x27;<br/>row_num = 17, column_no = 9, data = &#x27;15:32:28&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EE9FA9D90&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Users_Module_API.test_users_api.Test_Users_api object at 0x0000028EE9E72D10&gt;<br/><br/>    def test_Users_Test_16(self):<br/>        self.logger.info(&quot;test_Users_Test_16  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Users_API_Methods(self.logger).verify_get_service_user_false():<br/><br/>All_API_Test_Cases_Package\Users_Module_API\test_users_api.py:108: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000028EEA335590&gt;<br/><br/>    def verify_get_service_user_false(self):<br/>        result = []<br/>        try:<br/>            self.row = 17<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_service_user_false_request()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response) and validate_response_is_not_service_user(self.json_response):<br/>                excel_result(self.row, &quot;Test_16&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_16&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_16&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:516: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_users_api.py:107 test_Users_Test_16  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Users_Module_API/test_users_api.py::Test_Users_api::test_Users_Test_17</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000028EEA04A6D0&gt;<br/><br/>    def verify_get_users_alert_schedule(self):<br/>        result = []<br/>        try:<br/>            self.row = 18<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:526: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 18, time = &#x27;start_time&#x27;, sheet_name = &#x27;Users_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Users_Test_Results&#x27;<br/>row_num = 18, column_no = 9, data = &#x27;15:32:28&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA26E1D0&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Users_Module_API.test_users_api.Test_Users_api object at 0x0000028EE9F07B10&gt;<br/><br/>    def test_Users_Test_17(self):<br/>        self.logger.info(&quot;test_Users_Test_17  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Users_API_Methods(self.logger).verify_get_users_alert_schedule():<br/><br/>All_API_Test_Cases_Package\Users_Module_API\test_users_api.py:115: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000028EEA04A6D0&gt;<br/><br/>    def verify_get_users_alert_schedule(self):<br/>        result = []<br/>        try:<br/>            self.row = 18<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            data = get_user_id_or_account_id()<br/>            user_id = data[0]<br/>            response_list = get_users_alert_schedule_request(user_id)<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response) and validate_alert_schedule(self.json_response, user_id):<br/>                excel_result(self.row, &quot;Test_17&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_17&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_17&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:549: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_users_api.py:114 test_Users_Test_17  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Users_Module_API/test_users_api.py::Test_Users_api::test_Users_Test_18</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000028EEA4BED10&gt;<br/><br/>    def verify_delete_user_from_system(self):<br/>        result = []<br/>        try:<br/>            self.row = 19<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:559: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 19, time = &#x27;start_time&#x27;, sheet_name = &#x27;Users_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Users_Test_Results&#x27;<br/>row_num = 19, column_no = 9, data = &#x27;15:32:28&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA334410&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Users_Module_API.test_users_api.Test_Users_api object at 0x0000028EE9F07050&gt;<br/><br/>    def test_Users_Test_18(self):<br/>        self.logger.info(&quot;test_Users_Test_18  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Users_API_Methods(self.logger).verify_delete_user_from_system():<br/><br/>All_API_Test_Cases_Package\Users_Module_API\test_users_api.py:122: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000028EEA4BED10&gt;<br/><br/>    def verify_delete_user_from_system(self):<br/>        result = []<br/>        try:<br/>            self.row = 19<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            data = user_create_request(2)<br/>            user_id = data[3]<br/>            ex_msg = Read_Expected_users_Response_msg().delete_user_success_msg(user_id)<br/>            response_list = get_delete_user_from_system_request(user_id)<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            ac_msg = self.json_response[&quot;message&quot;]<br/>            if response_validation(self.response) and ex_msg == ac_msg:<br/>                excel_result(self.row, &quot;Test_18&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_18&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_18&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:584: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_users_api.py:121 test_Users_Test_18  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Users_Module_API/test_users_api.py::Test_Users_api::test_Users_Test_19</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000028EEA0ADAD0&gt;<br/><br/>    def verify_delete_user(self):<br/>        result = []<br/>        try:<br/>            self.row = 20<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:594: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 20, time = &#x27;start_time&#x27;, sheet_name = &#x27;Users_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Users_Test_Results&#x27;<br/>row_num = 20, column_no = 9, data = &#x27;15:32:29&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EE9E75510&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Users_Module_API.test_users_api.Test_Users_api object at 0x0000028EE9F064D0&gt;<br/><br/>    def test_Users_Test_19(self):<br/>        self.logger.info(&quot;test_Users_Test_19  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Users_API_Methods(self.logger).verify_delete_user():<br/><br/>All_API_Test_Cases_Package\Users_Module_API\test_users_api.py:129: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000028EEA0ADAD0&gt;<br/><br/>    def verify_delete_user(self):<br/>        result = []<br/>        try:<br/>            self.row = 20<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            data = user_create_request(2)<br/>            user_id = data[3]<br/>            ex_msg = Read_Expected_users_Response_msg().delete_user_success_msg(user_id)<br/>            response_list = get_delete_user_request(user_id)<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            ac_msg = self.json_response[&quot;message&quot;]<br/>            if response_validation(self.response) and ex_msg == ac_msg:<br/>                excel_result(self.row, &quot;Test_19&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_19&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_19&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:619: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_users_api.py:128 test_Users_Test_19  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Visitors_Search_Module_API/test_visitors_search_api.py::Test_visitors_search_api::test_Visitors_Test_01</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x0000028EEA4E0F90&gt;<br/><br/>    def verify_post_start_search(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:28: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 2, time = &#x27;start_time&#x27;, sheet_name = &#x27;Visitor_Search_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Visitor_Search_Test_Results&#x27;<br/>row_num = 2, column_no = 9, data = &#x27;15:32:29&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA03B290&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Visitors_Search_Module_API.test_visitors_search_api.Test_visitors_search_api object at 0x0000028EE9EE9110&gt;<br/><br/>    def test_Visitors_Test_01(self):<br/>        self.logger.info(&quot;test_visitor_search_Test_01  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Visitors_Search_API_Methods(self.logger).verify_post_start_search():<br/><br/>All_API_Test_Cases_Package\Visitors_Search_Module_API\test_visitors_search_api.py:10: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x0000028EEA4E0F90&gt;<br/><br/>    def verify_post_start_search(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = start_search_request()<br/>    <br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>    <br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:52: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>[Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_visitors_search_api.py:9 test_visitor_search_Test_01  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Visitors_Search_Module_API/test_visitors_search_api.py::Test_visitors_search_api::test_Visitors_Test_02</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x0000028EEA2F7B50&gt;<br/><br/>    def verify_get_fed_search_status(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:62: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 3, time = &#x27;start_time&#x27;, sheet_name = &#x27;Visitor_Search_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Visitor_Search_Test_Results&#x27;<br/>row_num = 3, column_no = 9, data = &#x27;15:32:29&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA1C8C50&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Visitors_Search_Module_API.test_visitors_search_api.Test_visitors_search_api object at 0x0000028EE9EEA3D0&gt;<br/><br/>    def test_Visitors_Test_02(self):<br/>        self.logger.info(&quot;test_visitor_search_Test_02  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Visitors_Search_API_Methods(self.logger).verify_get_fed_search_status():<br/><br/>All_API_Test_Cases_Package\Visitors_Search_Module_API\test_visitors_search_api.py:17: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x0000028EEA2F7B50&gt;<br/><br/>    def verify_get_fed_search_status(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            job_id = start_search_request()[3]<br/>            response_list = fed_search_status_request(job_id)<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:85: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>[Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_visitors_search_api.py:16 test_visitor_search_Test_02  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Visitors_Search_Module_API/test_visitors_search_api.py::Test_visitors_search_api::test_Visitors_Test_03</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x0000028EEA6CC510&gt;<br/><br/>    def verify_get_visitor_image_by_image_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 4, time = &#x27;start_time&#x27;, sheet_name = &#x27;Visitor_Search_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Visitor_Search_Test_Results&#x27;<br/>row_num = 4, column_no = 9, data = &#x27;15:32:29&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA087250&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Visitors_Search_Module_API.test_visitors_search_api.Test_visitors_search_api object at 0x0000028EE9EEBC50&gt;<br/><br/>    def test_Visitors_Test_03(self):<br/>        self.logger.info(&quot;test_visitor_search_Test_03  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Visitors_Search_API_Methods(self.logger).verify_get_visitor_image_by_image_id():<br/><br/>All_API_Test_Cases_Package\Visitors_Search_Module_API\test_visitors_search_api.py:24: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x0000028EEA6CC510&gt;<br/><br/>    def verify_get_visitor_image_by_image_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            job_id = start_search_request()[3]<br/>            image_id = fed_search_status_request(job_id)[1][&quot;matched&quot;][0][&quot;id&quot;]<br/>            response_list = get_visitor_image_by_image_id(image_id)<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;,<br/>                                                                              self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;,<br/>                                                                              self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                         self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:121: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>[Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_visitors_search_api.py:23 test_visitor_search_Test_03  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Visitors_Search_Module_API/test_visitors_search_api.py::Test_visitors_search_api::test_Visitors_Test_04</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x0000028EEA20B4D0&gt;<br/><br/>    def verify_identify_alien_federated(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:132: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 5, time = &#x27;start_time&#x27;, sheet_name = &#x27;Visitor_Search_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Visitor_Search_Test_Results&#x27;<br/>row_num = 5, column_no = 9, data = &#x27;15:32:29&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA512D10&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Visitors_Search_Module_API.test_visitors_search_api.Test_visitors_search_api object at 0x0000028EE9EE81D0&gt;<br/><br/>    def test_Visitors_Test_04(self):<br/>        self.logger.info(&quot;test_visitor_search_Test_04  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Visitors_Search_API_Methods(self.logger).verify_identify_alien_federated():<br/><br/>All_API_Test_Cases_Package\Visitors_Search_Module_API\test_visitors_search_api.py:31: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x0000028EEA20B4D0&gt;<br/><br/>    def verify_identify_alien_federated(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = identify_alien_federated_request()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;,<br/>                                                                              self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;,<br/>                                                                              self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                         self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:156: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>[Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_visitors_search_api.py:30 test_visitor_search_Test_04  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Visitors_Search_Module_API/test_visitors_search_api.py::Test_visitors_search_api::test_Visitors_Test_05</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x0000028EEA219950&gt;<br/><br/>    def verify_identify_delete_federated(self):<br/>        result = []<br/>        try:<br/>            self.row = 6<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:167: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 6, time = &#x27;start_time&#x27;, sheet_name = &#x27;Visitor_Search_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Visitor_Search_Test_Results&#x27;<br/>row_num = 6, column_no = 9, data = &#x27;15:32:30&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA085650&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Visitors_Search_Module_API.test_visitors_search_api.Test_visitors_search_api object at 0x0000028EE9EE9490&gt;<br/><br/>    def test_Visitors_Test_05(self):<br/>        self.logger.info(&quot;test_visitor_search_Test_05  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Visitors_Search_API_Methods(self.logger).verify_identify_delete_federated():<br/><br/>All_API_Test_Cases_Package\Visitors_Search_Module_API\test_visitors_search_api.py:38: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x0000028EEA219950&gt;<br/><br/>    def verify_identify_delete_federated(self):<br/>        result = []<br/>        try:<br/>            self.row = 6<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            job_id = start_search_request()[3]<br/>            response_list = delete_alien_federated_request(job_id)<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;,<br/>                                                                              self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;,<br/>                                                                              self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                         self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:192: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>[Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_visitors_search_api.py:37 test_visitor_search_Test_05  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Visitors_Search_Module_API/test_visitors_search_api.py::Test_visitors_search_api::test_Visitors_Test_06</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x0000028EEA1EF190&gt;<br/><br/>    def verify_get_alien_image(self):<br/>        result = []<br/>        try:<br/>            self.row = 7<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:203: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 7, time = &#x27;start_time&#x27;, sheet_name = &#x27;Visitor_Search_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Visitor_Search_Test_Results&#x27;<br/>row_num = 7, column_no = 9, data = &#x27;15:32:30&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA039310&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Visitors_Search_Module_API.test_visitors_search_api.Test_visitors_search_api object at 0x0000028EE9EE8690&gt;<br/><br/>    def test_Visitors_Test_06(self):<br/>        self.logger.info(&quot;test_visitor_search_Test_06  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Visitors_Search_API_Methods(self.logger).verify_get_alien_image():<br/><br/>All_API_Test_Cases_Package\Visitors_Search_Module_API\test_visitors_search_api.py:45: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x0000028EEA1EF190&gt;<br/><br/>    def verify_get_alien_image(self):<br/>        result = []<br/>        try:<br/>            self.row = 7<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            job_id = start_search_request()[3]<br/>            image_id = fed_search_status_request(job_id)[1][&quot;matched&quot;][0][&quot;id&quot;]<br/>            response_list = get_alien_image_by_image_id(image_id)<br/>            self.response = response_list<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;,<br/>                                                                              self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;,<br/>                                                                              self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                         self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:228: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>[Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_visitors_search_api.py:44 test_visitor_search_Test_06  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Visitors_Search_Module_API/test_visitors_search_api.py::Test_visitors_search_api::test_Visitors_Test_07</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x0000028EEA380B50&gt;<br/><br/>    def verify_identify_alien_federated_status(self):<br/>        result = []<br/>        try:<br/>            self.row = 8<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:239: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 8, time = &#x27;start_time&#x27;, sheet_name = &#x27;Visitor_Search_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Visitor_Search_Test_Results&#x27;<br/>row_num = 8, column_no = 9, data = &#x27;15:32:30&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EE9FAD390&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Visitors_Search_Module_API.test_visitors_search_api.Test_visitors_search_api object at 0x0000028EE9EE8A90&gt;<br/><br/>    def test_Visitors_Test_07(self):<br/>        self.logger.info(&quot;test_visitor_search_Test_07  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Visitors_Search_API_Methods(self.logger).verify_identify_alien_federated_status():<br/><br/>All_API_Test_Cases_Package\Visitors_Search_Module_API\test_visitors_search_api.py:52: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x0000028EEA380B50&gt;<br/><br/>    def verify_identify_alien_federated_status(self):<br/>        result = []<br/>        try:<br/>            self.row = 8<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            job_id = start_search_request()[3]<br/>            response_list = get_identify_alien_federated_status(job_id)<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_07&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;,<br/>                                                                              self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_07&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;,<br/>                                                                              self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_07&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                         self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:264: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>[Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_visitors_search_api.py:51 test_visitor_search_Test_07  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Visitors_Search_Module_API/test_visitors_search_api.py::Test_visitors_search_api::test_Visitors_Test_08</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x0000028EEA0E6310&gt;<br/><br/>    def verify_query_alien_face_info(self):<br/>        result = []<br/>        try:<br/>            self.row = 9<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:275: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 9, time = &#x27;start_time&#x27;, sheet_name = &#x27;Visitor_Search_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Visitor_Search_Test_Results&#x27;<br/>row_num = 9, column_no = 9, data = &#x27;15:32:30&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA0F9A10&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Visitors_Search_Module_API.test_visitors_search_api.Test_visitors_search_api object at 0x0000028EE9EEAA50&gt;<br/><br/>    def test_Visitors_Test_08(self):<br/>        self.logger.info(&quot;test_visitor_search_Test_08  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Visitors_Search_API_Methods(self.logger).verify_query_alien_face_info():<br/><br/>All_API_Test_Cases_Package\Visitors_Search_Module_API\test_visitors_search_api.py:59: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x0000028EEA0E6310&gt;<br/><br/>    def verify_query_alien_face_info(self):<br/>        result = []<br/>        try:<br/>            self.row = 9<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            job_id = start_search_request()[3]<br/>            image_id = fed_search_status_request(job_id)[1][&quot;matched&quot;][0][&quot;id&quot;]<br/>            response_list = get_query_alien_face_info(image_id)<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;,<br/>                                                                              self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;,<br/>                                                                              self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                         self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:301: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>[Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_visitors_search_api.py:58 test_visitor_search_Test_08  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Visitors_Search_Module_API/test_visitors_search_api.py::Test_visitors_search_api::test_Visitors_Test_09</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x0000028EEA45D850&gt;<br/><br/>    def verify_identify_cancel_federated(self):<br/>        result = []<br/>        try:<br/>            self.row = 10<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:312: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 10, time = &#x27;start_time&#x27;, sheet_name = &#x27;Visitor_Search_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Visitor_Search_Test_Results&#x27;<br/>row_num = 10, column_no = 9, data = &#x27;15:32:30&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA264B50&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Visitors_Search_Module_API.test_visitors_search_api.Test_visitors_search_api object at 0x0000028EE9E90810&gt;<br/><br/>    def test_Visitors_Test_09(self):<br/>        self.logger.info(&quot;test_visitor_search_Test_09  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Visitors_Search_API_Methods(self.logger).verify_identify_cancel_federated():<br/><br/>All_API_Test_Cases_Package\Visitors_Search_Module_API\test_visitors_search_api.py:66: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x0000028EEA45D850&gt;<br/><br/>    def verify_identify_cancel_federated(self):<br/>        result = []<br/>        try:<br/>            self.row = 10<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = identify_cancel_federated_request()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            print(self.json_response)<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_09&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;,<br/>                                                                              self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_09&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;,<br/>                                                                              self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_09&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                         self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:337: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>[Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_visitors_search_api.py:65 test_visitor_search_Test_09  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Visitors_Search_Module_API/test_visitors_search_api.py::Test_visitors_search_api::test_Visitors_Test_10</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x0000028EEA09FB10&gt;<br/><br/>    def verify_query_alien_federated_identification_log(self):<br/>        result = []<br/>        try:<br/>            self.row = 11<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:348: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 11, time = &#x27;start_time&#x27;, sheet_name = &#x27;Visitor_Search_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Visitor_Search_Test_Results&#x27;<br/>row_num = 11, column_no = 9, data = &#x27;15:32:30&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA8144D0&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Visitors_Search_Module_API.test_visitors_search_api.Test_visitors_search_api object at 0x0000028EE9E90410&gt;<br/><br/>    def test_Visitors_Test_10(self):<br/>        self.logger.info(&quot;test_visitor_search_Test_10  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Visitors_Search_API_Methods(self.logger).verify_query_alien_federated_identification_log():<br/><br/>All_API_Test_Cases_Package\Visitors_Search_Module_API\test_visitors_search_api.py:73: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x0000028EEA09FB10&gt;<br/><br/>    def verify_query_alien_federated_identification_log(self):<br/>        result = []<br/>        try:<br/>            self.row = 11<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_query_alien_federated_identification_log()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            print(self.json_response)<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_10&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;,<br/>                                                                              self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_10&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;,<br/>                                                                              self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_10&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                         self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:373: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>[Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_visitors_search_api.py:72 test_visitor_search_Test_10  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Visitors_Search_Module_API/test_visitors_search_api.py::Test_visitors_search_api::test_Visitors_Test_11</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x0000028EEA03AB50&gt;<br/><br/>    def verify_visitor_search(self):<br/>        result = []<br/>        try:<br/>            self.row = 12<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:384: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 12, time = &#x27;start_time&#x27;, sheet_name = &#x27;Visitor_Search_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Visitor_Search_Test_Results&#x27;<br/>row_num = 12, column_no = 9, data = &#x27;15:32:30&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA039950&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Visitors_Search_Module_API.test_visitors_search_api.Test_visitors_search_api object at 0x0000028EE9E920D0&gt;<br/><br/>    def test_Visitors_Test_11(self):<br/>        self.logger.info(&quot;test_visitor_search_Test_11  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Visitors_Search_API_Methods(self.logger).verify_visitor_search():<br/><br/>All_API_Test_Cases_Package\Visitors_Search_Module_API\test_visitors_search_api.py:80: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x0000028EEA03AB50&gt;<br/><br/>    def verify_visitor_search(self):<br/>        result = []<br/>        try:<br/>            self.row = 12<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = visitor_search_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            print(self.json_response)<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_11&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;,<br/>                                                                              self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_11&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;,<br/>                                                                              self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_11&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                         self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:410: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>[Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_visitors_search_api.py:79 test_visitor_search_Test_11  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Visitors_Search_Module_API/test_visitors_search_api.py::Test_visitors_search_api::test_Visitors_Test_12</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x0000028EEA6CD790&gt;<br/><br/>    def verify_visitor_count_by_zone(self):<br/>        result = []<br/>        try:<br/>            self.row = 13<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:421: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 13, time = &#x27;start_time&#x27;, sheet_name = &#x27;Visitor_Search_Test_Results&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Visitor_Search_Test_Results&#x27;<br/>row_num = 13, column_no = 9, data = &#x27;15:32:30&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA815310&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Visitors_Search_Module_API.test_visitors_search_api.Test_visitors_search_api object at 0x0000028EE9E92D90&gt;<br/><br/>    def test_Visitors_Test_12(self):<br/>        self.logger.info(&quot;test_visitor_search_Test_12  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Visitors_Search_API_Methods(self.logger).verify_visitor_count_by_zone():<br/><br/>All_API_Test_Cases_Package\Visitors_Search_Module_API\test_visitors_search_api.py:87: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x0000028EEA6CD790&gt;<br/><br/>    def verify_visitor_count_by_zone(self):<br/>        result = []<br/>        try:<br/>            self.row = 13<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_verify_visitor_count_by_zone()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            print(self.json_response)<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_12&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;,<br/>                                                                              self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_12&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;,<br/>                                                                              self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_12&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                         self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:446: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>[Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_visitors_search_api.py:86 test_visitor_search_Test_12  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Zones_Module_API/test_zones_api.py::Test_Zones_api::test_Zones_Test_01</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Zones_Module_API.Zones_API_Methods.Zones_API_Methods object at 0x0000028EEA049950&gt;<br/><br/>    def verify_get_all_zones(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Zones_Module_API\Zones_API_Methods.py:23: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 2, time = &#x27;start_time&#x27;, sheet_name = &#x27;Zones_Test_Result&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Zones_Test_Result&#x27;<br/>row_num = 2, column_no = 9, data = &#x27;15:32:30&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA4E2110&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Zones_Module_API.test_zones_api.Test_Zones_api object at 0x0000028EE9EEB050&gt;<br/><br/>    def test_Zones_Test_01(self):<br/>        self.logger.info(&quot;test_Zones_Test_01  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Zones_API_Methods(self.logger).verify_get_all_zones():<br/><br/>All_API_Test_Cases_Package\Zones_Module_API\test_zones_api.py:10: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Zones_Module_API.Zones_API_Methods.Zones_API_Methods object at 0x0000028EEA049950&gt;<br/><br/>    def verify_get_all_zones(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_all_zones()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            print(response_list)<br/>            for x in range(len(self.json_response[&quot;zoneInfo&quot;][&quot;zones&quot;])):<br/>                result.append(self.json_response[&quot;zoneInfo&quot;][&quot;zones&quot;][x][&quot;zoneId&quot;] != &quot;&quot;)<br/>    <br/>            if response_validation(self.response) and False not in result:<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Zones_Module_API\Zones_API_Methods.py:51: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>[Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_zones_api.py:9 test_Zones_Test_01  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/Zones_Module_API/test_zones_api.py::Test_Zones_api::test_Zones_Test_02</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Zones_Module_API.Zones_API_Methods.Zones_API_Methods object at 0x0000028EEA1D3610&gt;<br/><br/>    def verify_get_zone_by_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>&gt;           time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/><br/>All_API_Methods_Package\Zones_Module_API\Zones_API_Methods.py:61: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 3, time = &#x27;start_time&#x27;, sheet_name = &#x27;Zones_Test_Result&#x27;<br/><br/>    def time_entry(row_no, time, sheet_name):<br/>        global start, end<br/>        if time == &quot;start_time&quot;:<br/>            start = XLUtils.getCurrentTime()<br/>&gt;           XLUtils.writeData(API_Base_Utilities.report_excel_path, sheet_name, row_no, 9, start)<br/><br/>API_Utilities\Api_Base.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, sheet_name = &#x27;Zones_Test_Result&#x27;<br/>row_num = 3, column_no = 9, data = &#x27;15:32:31&#x27;<br/><br/>    def writeData(file, sheet_name, row_num, column_no, data):<br/>&gt;       workbook = openpyxl.load_workbook(file)<br/><br/>Config_Package\Excel_Config_Files\XLUtils.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,<br/>                      data_only=False, keep_links=True, rich_text=False):<br/>        &quot;&quot;&quot;Open the given filename and return the workbook<br/>    <br/>        :param filename: the path to open or a file-like object<br/>        :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`<br/>    <br/>        :param read_only: optimised for reading, content cannot be edited<br/>        :type read_only: bool<br/>    <br/>        :param keep_vba: preserve vba content (this does NOT mean you can use it)<br/>        :type keep_vba: bool<br/>    <br/>        :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet<br/>        :type data_only: bool<br/>    <br/>        :param keep_links: whether links to external workbooks should be preserved. The default is True<br/>        :type keep_links: bool<br/>    <br/>        :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False<br/>        :type rich_text: bool<br/>    <br/>        :rtype: :class:`openpyxl.workbook.Workbook`<br/>    <br/>        .. note::<br/>    <br/>            When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`<br/>            and the returned workbook will be read-only.<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       reader = ExcelReader(filename, read_only, keep_vba,<br/>                             data_only, keep_links, rich_text)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:344: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;openpyxl.reader.excel.ExcelReader object at 0x0000028EEA0E5010&gt;<br/>fn = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;, read_only = False, keep_vba = False<br/>data_only = False, keep_links = True, rich_text = False<br/><br/>    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,<br/>                 data_only=False, keep_links=True, rich_text=False):<br/>&gt;       self.archive = _validate_archive(fn)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:123: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>filename = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/><br/>    def _validate_archive(filename):<br/>        &quot;&quot;&quot;<br/>        Does a first check whether filename is a string or a file-like<br/>        object. If it is a string representing a filename, a check is done<br/>        for supported formats by checking the given file-extension. If the<br/>        file-extension is not in SUPPORTED_FORMATS an InvalidFileException<br/>        will raised. Otherwise the filename (resp. file-like object) will<br/>        forwarded to zipfile.ZipFile returning a ZipFile-Instance.<br/>        &quot;&quot;&quot;<br/>        is_file_like = hasattr(filename, &#x27;read&#x27;)<br/>        if not is_file_like:<br/>            file_format = os.path.splitext(filename)[-1].lower()<br/>            if file_format not in SUPPORTED_FORMATS:<br/>                if file_format == &#x27;.xls&#x27;:<br/>                    msg = (&#x27;openpyxl does not support the old .xls file format, &#x27;<br/>                           &#x27;please use xlrd to read this file, or convert it to &#x27;<br/>                           &#x27;the more recent .xlsx file format.&#x27;)<br/>                elif file_format == &#x27;.xlsb&#x27;:<br/>                    msg = (&#x27;openpyxl does not support binary format .xlsb, &#x27;<br/>                           &#x27;please convert this file to .xlsx format if you want &#x27;<br/>                           &#x27;to open it with openpyxl&#x27;)<br/>                else:<br/>                    msg = (&#x27;openpyxl does not support %s file format, &#x27;<br/>                           &#x27;please check you can open &#x27;<br/>                           &#x27;it with Excel first. &#x27;<br/>                           &#x27;Supported formats are: %s&#x27;) % (file_format,<br/>                                                           &#x27;,&#x27;.join(SUPPORTED_FORMATS))<br/>                raise InvalidFileException(msg)<br/>    <br/>&gt;       archive = ZipFile(filename, &#x27;r&#x27;)<br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\site-packages\openpyxl\reader\excel.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;zipfile.ZipFile [closed]&gt;, file = &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;<br/>mode = &#x27;r&#x27;, compression = 0, allowZip64 = True, compresslevel = None<br/><br/>    def __init__(self, file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True,<br/>                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):<br/>        &quot;&quot;&quot;Open the ZIP file with mode read &#x27;r&#x27;, write &#x27;w&#x27;, exclusive create &#x27;x&#x27;,<br/>        or append &#x27;a&#x27;.&quot;&quot;&quot;<br/>        if mode not in (&#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;a&#x27;):<br/>            raise ValueError(&quot;ZipFile requires mode &#x27;r&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, or &#x27;a&#x27;&quot;)<br/>    <br/>        _check_compression(compression)<br/>    <br/>        self._allowZip64 = allowZip64<br/>        self._didModify = False<br/>        self.debug = 0  # Level of printing: 0 through 3<br/>        self.NameToInfo = {}    # Find file info given name<br/>        self.filelist = []      # List of ZipInfo instances for archive<br/>        self.compression = compression  # Method of compression<br/>        self.compresslevel = compresslevel<br/>        self.mode = mode<br/>        self.pwd = None<br/>        self._comment = b&#x27;&#x27;<br/>        self._strict_timestamps = strict_timestamps<br/>        self.metadata_encoding = metadata_encoding<br/>    <br/>        # Check that we don&#x27;t try to write with nonconforming codecs<br/>        if self.metadata_encoding and mode != &#x27;r&#x27;:<br/>            raise ValueError(<br/>                &quot;metadata_encoding is only supported for reading files&quot;)<br/>    <br/>        # Check if we were passed a file-like object<br/>        if isinstance(file, os.PathLike):<br/>            file = os.fspath(file)<br/>        if isinstance(file, str):<br/>            # No, it&#x27;s a filename<br/>            self._filePassed = 0<br/>            self.filename = file<br/>            modeDict = {&#x27;r&#x27; : &#x27;rb&#x27;, &#x27;w&#x27;: &#x27;w+b&#x27;, &#x27;x&#x27;: &#x27;x+b&#x27;, &#x27;a&#x27; : &#x27;r+b&#x27;,<br/>                        &#x27;r+b&#x27;: &#x27;w+b&#x27;, &#x27;w+b&#x27;: &#x27;wb&#x27;, &#x27;x+b&#x27;: &#x27;xb&#x27;}<br/>            filemode = modeDict[mode]<br/>            while True:<br/>                try:<br/>&gt;                   self.fp = io.open(file, filemode)<br/><span class="error">E                   FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;</span><br/><br/>C:\Users\Dell\AppData\Local\Programs\Python\Python311\Lib\zipfile.py:1284: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.Zones_Module_API.test_zones_api.Test_Zones_api object at 0x0000028EE9EEAD90&gt;<br/><br/>    def test_Zones_Test_02(self):<br/>        self.logger.info(&quot;test_Zones_Test_01  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Zones_API_Methods(self.logger).verify_get_zone_by_id():<br/><br/>All_API_Test_Cases_Package\Zones_Module_API\test_zones_api.py:17: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Zones_Module_API.Zones_API_Methods.Zones_API_Methods object at 0x0000028EEA1D3610&gt;<br/><br/>    def verify_get_zone_by_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            ex_zone_id = get_all_zones()[1][&quot;zoneInfo&quot;][&quot;zones&quot;][0][&quot;zoneId&quot;]<br/>            response_list = get_single_zone_by_id(ex_zone_id)<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            ac_zones_id = self.json_response[&quot;zoneInfo&quot;][&quot;zones&quot;][0][&quot;zoneId&quot;]<br/>            print(response_list)<br/>            if response_validation(self.response) and ex_zone_id == ac_zones_id:<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Zones_Module_API\Zones_API_Methods.py:88: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>[Errno 2] No such file or directory: &#x27;D:\\FaceFirst Project\\Facefirst_API_Framework\\FF_Automation_Script_13_09_2023\\Reports\\API_Excel_Report\\API_excel_report.xlsx&#x27;
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_zones_api.py:16 test_Zones_Test_01  : Execution Started &gt;&gt;<br/></div></td></tr></tbody></table></body></html>