<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <title>token_issue_list_API.html</title>
    <link href="assets/style.css" rel="stylesheet" type="text/css"/></head>
  <body onLoad="init()">
    <script>/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
 * You can obtain one at http://mozilla.org/MPL/2.0/. */


function toArray(iter) {
    if (iter === null) {
        return null;
    }
    return Array.prototype.slice.call(iter);
}

function find(selector, elem) { // eslint-disable-line no-redeclare
    if (!elem) {
        elem = document;
    }
    return elem.querySelector(selector);
}

function findAll(selector, elem) {
    if (!elem) {
        elem = document;
    }
    return toArray(elem.querySelectorAll(selector));
}

function sortColumn(elem) {
    toggleSortStates(elem);
    const colIndex = toArray(elem.parentNode.childNodes).indexOf(elem);
    let key;
    if (elem.classList.contains('result')) {
        key = keyResult;
    } else if (elem.classList.contains('links')) {
        key = keyLink;
    } else {
        key = keyAlpha;
    }
    sortTable(elem, key(colIndex));
}

function showAllExtras() { // eslint-disable-line no-unused-vars
    findAll('.col-result').forEach(showExtras);
}

function hideAllExtras() { // eslint-disable-line no-unused-vars
    findAll('.col-result').forEach(hideExtras);
}

function showExtras(colresultElem) {
    const extras = colresultElem.parentNode.nextElementSibling;
    const expandcollapse = colresultElem.firstElementChild;
    extras.classList.remove('collapsed');
    expandcollapse.classList.remove('expander');
    expandcollapse.classList.add('collapser');
}

function hideExtras(colresultElem) {
    const extras = colresultElem.parentNode.nextElementSibling;
    const expandcollapse = colresultElem.firstElementChild;
    extras.classList.add('collapsed');
    expandcollapse.classList.remove('collapser');
    expandcollapse.classList.add('expander');
}

function showFilters() {
    let visibleString = getQueryParameter('visible') || 'all';
    visibleString = visibleString.toLowerCase();
    const checkedItems = visibleString.split(',');

    const filterItems = document.getElementsByClassName('filter');
    for (let i = 0; i < filterItems.length; i++) {
        filterItems[i].hidden = false;

        if (visibleString != 'all') {
            filterItems[i].checked = checkedItems.includes(filterItems[i].getAttribute('data-test-result'));
            filterTable(filterItems[i]);
        }
    }
}

function addCollapse() {
    // Add links for show/hide all
    const resulttable = find('table#results-table');
    const showhideall = document.createElement('p');
    showhideall.innerHTML = '<a href="javascript:showAllExtras()">Show all details</a> / ' +
                            '<a href="javascript:hideAllExtras()">Hide all details</a>';
    resulttable.parentElement.insertBefore(showhideall, resulttable);

    // Add show/hide link to each result
    findAll('.col-result').forEach(function(elem) {
        const collapsed = getQueryParameter('collapsed') || 'Passed';
        const extras = elem.parentNode.nextElementSibling;
        const expandcollapse = document.createElement('span');
        if (extras.classList.contains('collapsed')) {
            expandcollapse.classList.add('expander');
        } else if (collapsed.includes(elem.innerHTML)) {
            extras.classList.add('collapsed');
            expandcollapse.classList.add('expander');
        } else {
            expandcollapse.classList.add('collapser');
        }
        elem.appendChild(expandcollapse);

        elem.addEventListener('click', function(event) {
            if (event.currentTarget.parentNode.nextElementSibling.classList.contains('collapsed')) {
                showExtras(event.currentTarget);
            } else {
                hideExtras(event.currentTarget);
            }
        });
    });
}

function getQueryParameter(name) {
    const match = RegExp('[?&]' + name + '=([^&]*)').exec(window.location.search);
    return match && decodeURIComponent(match[1].replace(/\+/g, ' '));
}

function init () { // eslint-disable-line no-unused-vars
    resetSortHeaders();

    addCollapse();

    showFilters();

    sortColumn(find('.initial-sort'));

    findAll('.sortable').forEach(function(elem) {
        elem.addEventListener('click',
            function() {
                sortColumn(elem);
            }, false);
    });
}

function sortTable(clicked, keyFunc) {
    const rows = findAll('.results-table-row');
    const reversed = !clicked.classList.contains('asc');
    const sortedRows = sort(rows, keyFunc, reversed);
    /* Whole table is removed here because browsers acts much slower
     * when appending existing elements.
     */
    const thead = document.getElementById('results-table-head');
    document.getElementById('results-table').remove();
    const parent = document.createElement('table');
    parent.id = 'results-table';
    parent.appendChild(thead);
    sortedRows.forEach(function(elem) {
        parent.appendChild(elem);
    });
    document.getElementsByTagName('BODY')[0].appendChild(parent);
}

function sort(items, keyFunc, reversed) {
    const sortArray = items.map(function(item, i) {
        return [keyFunc(item), i];
    });

    sortArray.sort(function(a, b) {
        const keyA = a[0];
        const keyB = b[0];

        if (keyA == keyB) return 0;

        if (reversed) {
            return keyA < keyB ? 1 : -1;
        } else {
            return keyA > keyB ? 1 : -1;
        }
    });

    return sortArray.map(function(item) {
        const index = item[1];
        return items[index];
    });
}

function keyAlpha(colIndex) {
    return function(elem) {
        return elem.childNodes[1].childNodes[colIndex].firstChild.data.toLowerCase();
    };
}

function keyLink(colIndex) {
    return function(elem) {
        const dataCell = elem.childNodes[1].childNodes[colIndex].firstChild;
        return dataCell == null ? '' : dataCell.innerText.toLowerCase();
    };
}

function keyResult(colIndex) {
    return function(elem) {
        const strings = ['Error', 'Failed', 'Rerun', 'XFailed', 'XPassed',
            'Skipped', 'Passed'];
        return strings.indexOf(elem.childNodes[1].childNodes[colIndex].firstChild.data);
    };
}

function resetSortHeaders() {
    findAll('.sort-icon').forEach(function(elem) {
        elem.parentNode.removeChild(elem);
    });
    findAll('.sortable').forEach(function(elem) {
        const icon = document.createElement('div');
        icon.className = 'sort-icon';
        icon.textContent = 'vvv';
        elem.insertBefore(icon, elem.firstChild);
        elem.classList.remove('desc', 'active');
        elem.classList.add('asc', 'inactive');
    });
}

function toggleSortStates(elem) {
    //if active, toggle between asc and desc
    if (elem.classList.contains('active')) {
        elem.classList.toggle('asc');
        elem.classList.toggle('desc');
    }

    //if inactive, reset all other functions and add ascending active
    if (elem.classList.contains('inactive')) {
        resetSortHeaders();
        elem.classList.remove('inactive');
        elem.classList.add('active');
    }
}

function isAllRowsHidden(value) {
    return value.hidden == false;
}

function filterTable(elem) { // eslint-disable-line no-unused-vars
    const outcomeAtt = 'data-test-result';
    const outcome = elem.getAttribute(outcomeAtt);
    const classOutcome = outcome + ' results-table-row';
    const outcomeRows = document.getElementsByClassName(classOutcome);

    for(let i = 0; i < outcomeRows.length; i++){
        outcomeRows[i].hidden = !elem.checked;
    }

    const rows = findAll('.results-table-row').filter(isAllRowsHidden);
    const allRowsHidden = rows.length == 0 ? true : false;
    const notFoundMessage = document.getElementById('not-found-message');
    notFoundMessage.hidden = !allRowsHidden;
}
</script>
    <h1>token_issue_list_API.html</h1>
    <p>Report generated on 16-Nov-2023 at 13:03:29 by <a href="https://pypi.python.org/pypi/pytest-html">pytest-html</a> v3.2.0</p>
    <h2>Environment</h2>
    <table id="environment">
      <tr>
        <td>JAVA_HOME</td>
        <td>C:\Program Files\Java\jdk-17</td></tr>
      <tr>
        <td>Packages</td>
        <td>{"pluggy": "1.0.0", "pytest": "7.2.1"}</td></tr>
      <tr>
        <td>Platform</td>
        <td>Windows-10-10.0.19045-SP0</td></tr>
      <tr>
        <td>Plugins</td>
        <td>{"allure-pytest": "2.12.0", "html": "3.2.0", "metadata": "2.0.4"}</td></tr>
      <tr>
        <td>Python</td>
        <td>3.11.4</td></tr></table>
    <h2>Summary</h2>
    <p>131 tests ran in 655.29 seconds. </p>
    <p class="filter" hidden="true">(Un)check the boxes to filter the results.</p><input checked="true" class="filter" data-test-result="passed" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="passed">11 passed</span>, <input checked="true" class="filter" data-test-result="skipped" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="skipped">0 skipped</span>, <input checked="true" class="filter" data-test-result="failed" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="failed">120 failed</span>, <input checked="true" class="filter" data-test-result="error" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="error">0 errors</span>, <input checked="true" class="filter" data-test-result="xfailed" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="xfailed">0 expected failures</span>, <input checked="true" class="filter" data-test-result="xpassed" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="xpassed">0 unexpected passes</span>
    <h2>Results</h2>
    <table id="results-table">
      <thead id="results-table-head">
        <tr>
          <th class="sortable result initial-sort" col="result">Result</th>
          <th class="sortable" col="name">Test</th>
          <th class="sortable" col="duration">Duration</th>
          <th class="sortable links" col="links">Links</th></tr>
        <tr hidden="true" id="not-found-message">
          <th colspan="4">No results found. Try to check the filters</th></tr></thead>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/C_Users_Module_API/test_users_api.py::Test_Users_api::test_Users_Test_01</td>
          <td class="col-duration">7.30</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000024728FF9B10&gt;<br/><br/>    def verify_create_user_with_valid_information_in_enabled_mode(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = user_create_request(self.row)<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:28: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 2<br/><br/>    def user_create_request(row_no):<br/>        token = login_token()<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().users_endpoint()}&quot;<br/>        data = users_test_data(row_no)<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        form_data = {&quot;auth_params&quot;: data[0], &quot;company&quot;: data[1], &quot;title&quot;: data[2], &quot;department&quot;: data[3],<br/>                     &quot;enabled&quot;: data[4], &quot;fname&quot;: data[5], &quot;mname&quot;: data[6], &quot;lname&quot;: data[7],<br/>                     &quot;addr1&quot;: data[8], &quot;addr2&quot;: data[9], &quot;city&quot;: data[10], &quot;state&quot;: data[11],<br/>                     &quot;zip&quot;: data[12], &quot;email&quot;: data[13], &quot;aemail&quot;: data[14], &quot;hphone&quot;: data[15],<br/>                     &quot;wphone&quot;: data[16], &quot;fphone&quot;: data[17], &quot;aphone&quot;: data[18], &quot;phone_type&quot;: data[19],<br/>                     &quot;provider&quot;: data[20], &quot;timezone&quot;: data[21], &quot;urole_id&quot;: select_user_role(),<br/>&gt;                    &quot;region_id&quot;: select_region(), &quot;username&quot;: f&quot;{data[24]}{random_number()}&quot;, &quot;password&quot;: data[25]}<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:639: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def select_region():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_region_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:854: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.C_Users_Module_API.test_users_api.Test_Users_api object at 0x00000247288FAE90&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Users_Module_API\test_users_api.py:10: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000024728FF9B10&gt;<br/><br/>    def verify_create_user_with_valid_information_in_enabled_mode(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = user_create_request(self.row)<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.act_msg = self.json_response[&quot;status&quot;]<br/>            self.exp_msg = Read_Expected_users_Response_msg().users_success_msg()<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:51: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_users_api.py:9 test_Users_Test_01  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/C_Users_Module_API/test_users_api.py::Test_Users_api::test_Users_Test_02</td>
          <td class="col-duration">7.35</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x000002472916C050&gt;<br/><br/>    def verify_create_user_with_mandatory_information_in_enabled_mode(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = user_create_request(self.row)<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:62: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 3<br/><br/>    def user_create_request(row_no):<br/>        token = login_token()<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().users_endpoint()}&quot;<br/>        data = users_test_data(row_no)<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        form_data = {&quot;auth_params&quot;: data[0], &quot;company&quot;: data[1], &quot;title&quot;: data[2], &quot;department&quot;: data[3],<br/>                     &quot;enabled&quot;: data[4], &quot;fname&quot;: data[5], &quot;mname&quot;: data[6], &quot;lname&quot;: data[7],<br/>                     &quot;addr1&quot;: data[8], &quot;addr2&quot;: data[9], &quot;city&quot;: data[10], &quot;state&quot;: data[11],<br/>                     &quot;zip&quot;: data[12], &quot;email&quot;: data[13], &quot;aemail&quot;: data[14], &quot;hphone&quot;: data[15],<br/>                     &quot;wphone&quot;: data[16], &quot;fphone&quot;: data[17], &quot;aphone&quot;: data[18], &quot;phone_type&quot;: data[19],<br/>                     &quot;provider&quot;: data[20], &quot;timezone&quot;: data[21], &quot;urole_id&quot;: select_user_role(),<br/>&gt;                    &quot;region_id&quot;: select_region(), &quot;username&quot;: f&quot;{data[24]}{random_number()}&quot;, &quot;password&quot;: data[25]}<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:639: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def select_region():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_region_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:854: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.C_Users_Module_API.test_users_api.Test_Users_api object at 0x00000247288FA6D0&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Users_Module_API\test_users_api.py:17: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x000002472916C050&gt;<br/><br/>    def verify_create_user_with_mandatory_information_in_enabled_mode(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = user_create_request(self.row)<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.act_msg = self.json_response[&quot;status&quot;]<br/>            self.exp_msg = Read_Expected_users_Response_msg().users_success_msg()<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:87: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_users_api.py:16 test_Users_Test_02  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/C_Users_Module_API/test_users_api.py::Test_Users_api::test_Users_Test_03</td>
          <td class="col-duration">7.10</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000024728F877D0&gt;<br/><br/>    def verify_create_user_with_valid_information_in_disabled_mode(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = user_create_request(self.row)<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:98: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 4<br/><br/>    def user_create_request(row_no):<br/>        token = login_token()<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().users_endpoint()}&quot;<br/>        data = users_test_data(row_no)<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        form_data = {&quot;auth_params&quot;: data[0], &quot;company&quot;: data[1], &quot;title&quot;: data[2], &quot;department&quot;: data[3],<br/>                     &quot;enabled&quot;: data[4], &quot;fname&quot;: data[5], &quot;mname&quot;: data[6], &quot;lname&quot;: data[7],<br/>                     &quot;addr1&quot;: data[8], &quot;addr2&quot;: data[9], &quot;city&quot;: data[10], &quot;state&quot;: data[11],<br/>                     &quot;zip&quot;: data[12], &quot;email&quot;: data[13], &quot;aemail&quot;: data[14], &quot;hphone&quot;: data[15],<br/>                     &quot;wphone&quot;: data[16], &quot;fphone&quot;: data[17], &quot;aphone&quot;: data[18], &quot;phone_type&quot;: data[19],<br/>                     &quot;provider&quot;: data[20], &quot;timezone&quot;: data[21], &quot;urole_id&quot;: select_user_role(),<br/>&gt;                    &quot;region_id&quot;: select_region(), &quot;username&quot;: f&quot;{data[24]}{random_number()}&quot;, &quot;password&quot;: data[25]}<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:639: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def select_region():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_region_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:854: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.C_Users_Module_API.test_users_api.Test_Users_api object at 0x00000247288F9BD0&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Users_Module_API\test_users_api.py:24: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000024728F877D0&gt;<br/><br/>    def verify_create_user_with_valid_information_in_disabled_mode(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = user_create_request(self.row)<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.act_msg = self.json_response[&quot;status&quot;]<br/>            self.exp_msg = Read_Expected_users_Response_msg().users_success_msg()<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:123: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_users_api.py:23 test_Users_Test_03  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/C_Users_Module_API/test_users_api.py::Test_Users_api::test_Users_Test_04</td>
          <td class="col-duration">7.14</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x00000247289C27D0&gt;<br/><br/>    def verify_create_user_with_mandatory_fields_in_disable_mode(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = user_create_request(self.row)<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:134: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 5<br/><br/>    def user_create_request(row_no):<br/>        token = login_token()<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().users_endpoint()}&quot;<br/>        data = users_test_data(row_no)<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        form_data = {&quot;auth_params&quot;: data[0], &quot;company&quot;: data[1], &quot;title&quot;: data[2], &quot;department&quot;: data[3],<br/>                     &quot;enabled&quot;: data[4], &quot;fname&quot;: data[5], &quot;mname&quot;: data[6], &quot;lname&quot;: data[7],<br/>                     &quot;addr1&quot;: data[8], &quot;addr2&quot;: data[9], &quot;city&quot;: data[10], &quot;state&quot;: data[11],<br/>                     &quot;zip&quot;: data[12], &quot;email&quot;: data[13], &quot;aemail&quot;: data[14], &quot;hphone&quot;: data[15],<br/>                     &quot;wphone&quot;: data[16], &quot;fphone&quot;: data[17], &quot;aphone&quot;: data[18], &quot;phone_type&quot;: data[19],<br/>                     &quot;provider&quot;: data[20], &quot;timezone&quot;: data[21], &quot;urole_id&quot;: select_user_role(),<br/>&gt;                    &quot;region_id&quot;: select_region(), &quot;username&quot;: f&quot;{data[24]}{random_number()}&quot;, &quot;password&quot;: data[25]}<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:639: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def select_region():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_region_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:854: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.C_Users_Module_API.test_users_api.Test_Users_api object at 0x00000247288FA910&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Users_Module_API\test_users_api.py:31: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x00000247289C27D0&gt;<br/><br/>    def verify_create_user_with_mandatory_fields_in_disable_mode(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = user_create_request(self.row)<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.act_msg = self.json_response[&quot;status&quot;]<br/>            self.exp_msg = Read_Expected_users_Response_msg().users_success_msg()<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:157: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_users_api.py:30 test_Users_Test_04  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/C_Users_Module_API/test_users_api.py::Test_Users_api::test_Users_Test_06</td>
          <td class="col-duration">3.68</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000024728A96990&gt;<br/><br/>    def verify_users_update_alert_schedule(self):<br/>        result = []<br/>        try:<br/>            self.row = 7<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = users_update_alert_schedule_request()<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:329: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def users_update_alert_schedule_request():<br/>        token = login_token()<br/>&gt;       data_id = get_user_request()<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:694: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_user_request():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_users_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:730: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.C_Users_Module_API.test_users_api.Test_Users_api object at 0x00000247288F3FD0&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Users_Module_API\test_users_api.py:38: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000024728A96990&gt;<br/><br/>    def verify_users_update_alert_schedule(self):<br/>        result = []<br/>        try:<br/>            self.row = 7<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = users_update_alert_schedule_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.act_msg = self.json_response[&quot;data&quot;]<br/>            self.exp_msg = Read_Expected_users_Response_msg().user_update_alert_schedule_msg()<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:352: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_users_api.py:37 test_Users_Test_06  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/C_Users_Module_API/test_users_api.py::Test_Users_api::test_Users_Test_07</td>
          <td class="col-duration">6.54</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x00000247292366D0&gt;<br/><br/>    def verify_create_users_using_json(self):<br/>        result = []<br/>        try:<br/>            self.row = 8<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = create_users_using_json()<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:363: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_users_using_json():<br/>        token = login_token()<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_users_endpoint()}&quot;<br/>        data = create_user_test_data(9)<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>&gt;       id_data = get_user_request()<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:753: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_user_request():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_users_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:730: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.C_Users_Module_API.test_users_api.Test_Users_api object at 0x00000247288F3450&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Users_Module_API\test_users_api.py:45: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x00000247292366D0&gt;<br/><br/>    def verify_create_users_using_json(self):<br/>        result = []<br/>        try:<br/>            self.row = 8<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = create_users_using_json()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.act_msg = self.json_response[&quot;status&quot;]<br/>            self.exp_msg = Read_Expected_users_Response_msg().user_create_msg()<br/>            act_username = self.json_response[&quot;userName&quot;]<br/>            exp_username = response_list[3]<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg and act_username == exp_username:<br/>                excel_result(self.row, &quot;Test_07&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_07&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_07&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:388: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_users_api.py:44 test_Users_Test_07  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/C_Users_Module_API/test_users_api.py::Test_Users_api::test_Users_Test_08</td>
          <td class="col-duration">7.06</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000024729086CD0&gt;<br/><br/>    def verify_edit_user_with_mandatory_information(self):<br/>        result = []<br/>        try:<br/>            self.row = 9<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = edite_user_request()<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:168: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def edite_user_request():<br/>&gt;       data = user_create_request(2)<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:650: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 2<br/><br/>    def user_create_request(row_no):<br/>        token = login_token()<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().users_endpoint()}&quot;<br/>        data = users_test_data(row_no)<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        form_data = {&quot;auth_params&quot;: data[0], &quot;company&quot;: data[1], &quot;title&quot;: data[2], &quot;department&quot;: data[3],<br/>                     &quot;enabled&quot;: data[4], &quot;fname&quot;: data[5], &quot;mname&quot;: data[6], &quot;lname&quot;: data[7],<br/>                     &quot;addr1&quot;: data[8], &quot;addr2&quot;: data[9], &quot;city&quot;: data[10], &quot;state&quot;: data[11],<br/>                     &quot;zip&quot;: data[12], &quot;email&quot;: data[13], &quot;aemail&quot;: data[14], &quot;hphone&quot;: data[15],<br/>                     &quot;wphone&quot;: data[16], &quot;fphone&quot;: data[17], &quot;aphone&quot;: data[18], &quot;phone_type&quot;: data[19],<br/>                     &quot;provider&quot;: data[20], &quot;timezone&quot;: data[21], &quot;urole_id&quot;: select_user_role(),<br/>&gt;                    &quot;region_id&quot;: select_region(), &quot;username&quot;: f&quot;{data[24]}{random_number()}&quot;, &quot;password&quot;: data[25]}<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:639: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def select_region():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_region_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:854: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.C_Users_Module_API.test_users_api.Test_Users_api object at 0x00000247288F3E50&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Users_Module_API\test_users_api.py:52: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000024729086CD0&gt;<br/><br/>    def verify_edit_user_with_mandatory_information(self):<br/>        result = []<br/>        try:<br/>            self.row = 9<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = edite_user_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.act_msg = self.json_response[&quot;message&quot;]<br/>            self.exp_msg = f&quot;User  {self.json_response[&#x27;data&#x27;]} is updated.&quot;<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:191: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_users_api.py:51 test_Users_Test_08  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/C_Users_Module_API/test_users_api.py::Test_Users_api::test_Users_Test_09</td>
          <td class="col-duration">8.34</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000024728DA6F90&gt;<br/><br/>    def verify_edit_user_password(self):<br/>        result = []<br/>        try:<br/>            self.row = 9<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = edit_user_password()<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:202: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def edit_user_password():<br/>        token = login_token()<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().put_user_password_endpoint()}&quot;<br/>&gt;       r_data = user_create_request(2)<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:774: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 2<br/><br/>    def user_create_request(row_no):<br/>        token = login_token()<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().users_endpoint()}&quot;<br/>        data = users_test_data(row_no)<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        form_data = {&quot;auth_params&quot;: data[0], &quot;company&quot;: data[1], &quot;title&quot;: data[2], &quot;department&quot;: data[3],<br/>                     &quot;enabled&quot;: data[4], &quot;fname&quot;: data[5], &quot;mname&quot;: data[6], &quot;lname&quot;: data[7],<br/>                     &quot;addr1&quot;: data[8], &quot;addr2&quot;: data[9], &quot;city&quot;: data[10], &quot;state&quot;: data[11],<br/>                     &quot;zip&quot;: data[12], &quot;email&quot;: data[13], &quot;aemail&quot;: data[14], &quot;hphone&quot;: data[15],<br/>                     &quot;wphone&quot;: data[16], &quot;fphone&quot;: data[17], &quot;aphone&quot;: data[18], &quot;phone_type&quot;: data[19],<br/>                     &quot;provider&quot;: data[20], &quot;timezone&quot;: data[21], &quot;urole_id&quot;: select_user_role(),<br/>&gt;                    &quot;region_id&quot;: select_region(), &quot;username&quot;: f&quot;{data[24]}{random_number()}&quot;, &quot;password&quot;: data[25]}<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:639: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def select_region():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_region_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:854: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.C_Users_Module_API.test_users_api.Test_Users_api object at 0x00000247288FBCD0&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Users_Module_API\test_users_api.py:59: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000024728DA6F90&gt;<br/><br/>    def verify_edit_user_password(self):<br/>        result = []<br/>        try:<br/>            self.row = 9<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = edit_user_password()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.act_msg = self.json_response[&quot;message&quot;]<br/>            self.exp_msg = Read_Expected_users_Response_msg().edit_password_success_msg()<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:225: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_users_api.py:58 test_Users_Test_09  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/C_Users_Module_API/test_users_api.py::Test_Users_api::test_Users_Test_10</td>
          <td class="col-duration">6.89</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x00000247293A8B50&gt;<br/><br/>    def verify_edite_user_with_json_data(self):<br/>        result = []<br/>        try:<br/>            self.row = 11<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = edite_user_json_data_request()<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:399: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def edite_user_json_data_request():<br/>&gt;       data = user_create_request(2)<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:671: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 2<br/><br/>    def user_create_request(row_no):<br/>        token = login_token()<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().users_endpoint()}&quot;<br/>        data = users_test_data(row_no)<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        form_data = {&quot;auth_params&quot;: data[0], &quot;company&quot;: data[1], &quot;title&quot;: data[2], &quot;department&quot;: data[3],<br/>                     &quot;enabled&quot;: data[4], &quot;fname&quot;: data[5], &quot;mname&quot;: data[6], &quot;lname&quot;: data[7],<br/>                     &quot;addr1&quot;: data[8], &quot;addr2&quot;: data[9], &quot;city&quot;: data[10], &quot;state&quot;: data[11],<br/>                     &quot;zip&quot;: data[12], &quot;email&quot;: data[13], &quot;aemail&quot;: data[14], &quot;hphone&quot;: data[15],<br/>                     &quot;wphone&quot;: data[16], &quot;fphone&quot;: data[17], &quot;aphone&quot;: data[18], &quot;phone_type&quot;: data[19],<br/>                     &quot;provider&quot;: data[20], &quot;timezone&quot;: data[21], &quot;urole_id&quot;: select_user_role(),<br/>&gt;                    &quot;region_id&quot;: select_region(), &quot;username&quot;: f&quot;{data[24]}{random_number()}&quot;, &quot;password&quot;: data[25]}<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:639: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def select_region():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_region_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:854: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.C_Users_Module_API.test_users_api.Test_Users_api object at 0x000002472890B890&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Users_Module_API\test_users_api.py:66: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x00000247293A8B50&gt;<br/><br/>    def verify_edite_user_with_json_data(self):<br/>        result = []<br/>        try:<br/>            self.row = 11<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = edite_user_json_data_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            user_id = response_list[3]<br/>            self.act_msg = self.json_response[&quot;message&quot;]<br/>            self.exp_msg = Read_Expected_users_Response_msg().edit_user_success_msg(user_id)<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_10&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_10&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_10&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:423: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_users_api.py:65 test_Users_Test_10  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/C_Users_Module_API/test_users_api.py::Test_Users_api::test_Users_Test_11</td>
          <td class="col-duration">2.46</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x00000247288F9650&gt;<br/><br/>    def verify_get_users_api(self):<br/>        result = []<br/>        try:<br/>            self.row = 12<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = get_user_request()<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:236: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_user_request():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_users_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:730: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.C_Users_Module_API.test_users_api.Test_Users_api object at 0x00000247288F3B10&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Users_Module_API\test_users_api.py:73: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x00000247288F9650&gt;<br/><br/>    def verify_get_users_api(self):<br/>        result = []<br/>        try:<br/>            self.row = 12<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_user_request()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_11&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_11&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_11&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:256: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_users_api.py:72 test_Users_Test_11  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/C_Users_Module_API/test_users_api.py::Test_Users_api::test_Users_Test_12</td>
          <td class="col-duration">2.40</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000024729235310&gt;<br/><br/>    def verify_get_user_by_account_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 13<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = get_user_request_by_account_id()<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:267: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_user_request_by_account_id():<br/>&gt;       data = get_user_request()<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:714: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_user_request():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_users_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:730: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.C_Users_Module_API.test_users_api.Test_Users_api object at 0x00000247288F3350&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Users_Module_API\test_users_api.py:80: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000024729235310&gt;<br/><br/>    def verify_get_user_by_account_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 13<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_user_request_by_account_id()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_12&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_12&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_12&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:287: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_users_api.py:79 test_Users_Test_12  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/C_Users_Module_API/test_users_api.py::Test_Users_api::test_Users_Test_13</td>
          <td class="col-duration">2.58</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000024728F887D0&gt;<br/><br/>    def verify_get_user_by_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 14<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = get_user_by_id_request()<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:298: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_user_by_id_request():<br/>&gt;       data = get_user_request()<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:737: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_user_request():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_users_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:730: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.C_Users_Module_API.test_users_api.Test_Users_api object at 0x00000247288F26D0&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Users_Module_API\test_users_api.py:87: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000024728F887D0&gt;<br/><br/>    def verify_get_user_by_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 14<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_user_by_id_request()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_13&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_13&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_13&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:318: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_users_api.py:86 test_Users_Test_13  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/C_Users_Module_API/test_users_api.py::Test_Users_api::test_Users_Test_14</td>
          <td class="col-duration">2.39</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000024728C60F50&gt;<br/><br/>    def verify_get_user_info(self):<br/>        result = []<br/>        try:<br/>            self.row = 15<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = get_user_info_request()<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:434: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_user_info_request():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_user_info_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:864: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.C_Users_Module_API.test_users_api.Test_Users_api object at 0x00000247288F2410&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Users_Module_API\test_users_api.py:94: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000024728C60F50&gt;<br/><br/>    def verify_get_user_info(self):<br/>        result = []<br/>        try:<br/>            self.row = 15<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_user_info_request()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_14&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_14&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_14&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:454: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_users_api.py:93 test_Users_Test_14  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/C_Users_Module_API/test_users_api.py::Test_Users_api::test_Users_Test_15</td>
          <td class="col-duration">2.41</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000024728B96910&gt;<br/><br/>    def verify_get_service_user_true(self):<br/>        result = []<br/>        try:<br/>            self.row = 16<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = get_service_user_true_request()<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:465: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_service_user_true_request():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_service_user_true_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:873: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.C_Users_Module_API.test_users_api.Test_Users_api object at 0x00000247288F1BD0&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Users_Module_API\test_users_api.py:101: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000024728B96910&gt;<br/><br/>    def verify_get_service_user_true(self):<br/>        result = []<br/>        try:<br/>            self.row = 16<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_service_user_true_request()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response) and validate_response_is_service_user(self.json_response):<br/>                excel_result(self.row, &quot;Test_15&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_15&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_15&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:485: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_users_api.py:100 test_Users_Test_15  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/C_Users_Module_API/test_users_api.py::Test_Users_api::test_Users_Test_16</td>
          <td class="col-duration">2.52</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000024728B3D850&gt;<br/><br/>    def verify_get_service_user_false(self):<br/>        result = []<br/>        try:<br/>            self.row = 17<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = get_service_user_false_request()<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:496: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_service_user_false_request():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_service_user_false_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:889: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.C_Users_Module_API.test_users_api.Test_Users_api object at 0x00000247288F1110&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Users_Module_API\test_users_api.py:108: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000024728B3D850&gt;<br/><br/>    def verify_get_service_user_false(self):<br/>        result = []<br/>        try:<br/>            self.row = 17<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_service_user_false_request()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response) and validate_response_is_not_service_user(self.json_response):<br/>                excel_result(self.row, &quot;Test_16&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_16&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_16&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:516: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_users_api.py:107 test_Users_Test_16  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/C_Users_Module_API/test_users_api.py::Test_Users_api::test_Users_Test_17</td>
          <td class="col-duration">2.48</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000024729397510&gt;<br/><br/>    def verify_get_users_alert_schedule(self):<br/>        result = []<br/>        try:<br/>            self.row = 18<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           data = get_user_id_or_account_id()<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:527: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_user_id_or_account_id():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_users_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:905: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.C_Users_Module_API.test_users_api.Test_Users_api object at 0x00000247288F04D0&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Users_Module_API\test_users_api.py:115: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000024729397510&gt;<br/><br/>    def verify_get_users_alert_schedule(self):<br/>        result = []<br/>        try:<br/>            self.row = 18<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            data = get_user_id_or_account_id()<br/>            user_id = data[0]<br/>            response_list = get_users_alert_schedule_request(user_id)<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response) and validate_alert_schedule(self.json_response, user_id):<br/>                excel_result(self.row, &quot;Test_17&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_17&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_17&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:549: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_users_api.py:114 test_Users_Test_17  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/C_Users_Module_API/test_users_api.py::Test_Users_api::test_Users_Test_18</td>
          <td class="col-duration">7.21</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x00000247291C8FD0&gt;<br/><br/>    def verify_delete_user_from_system(self):<br/>        result = []<br/>        try:<br/>            self.row = 19<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           data = user_create_request(2)<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:560: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 2<br/><br/>    def user_create_request(row_no):<br/>        token = login_token()<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().users_endpoint()}&quot;<br/>        data = users_test_data(row_no)<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        form_data = {&quot;auth_params&quot;: data[0], &quot;company&quot;: data[1], &quot;title&quot;: data[2], &quot;department&quot;: data[3],<br/>                     &quot;enabled&quot;: data[4], &quot;fname&quot;: data[5], &quot;mname&quot;: data[6], &quot;lname&quot;: data[7],<br/>                     &quot;addr1&quot;: data[8], &quot;addr2&quot;: data[9], &quot;city&quot;: data[10], &quot;state&quot;: data[11],<br/>                     &quot;zip&quot;: data[12], &quot;email&quot;: data[13], &quot;aemail&quot;: data[14], &quot;hphone&quot;: data[15],<br/>                     &quot;wphone&quot;: data[16], &quot;fphone&quot;: data[17], &quot;aphone&quot;: data[18], &quot;phone_type&quot;: data[19],<br/>                     &quot;provider&quot;: data[20], &quot;timezone&quot;: data[21], &quot;urole_id&quot;: select_user_role(),<br/>&gt;                    &quot;region_id&quot;: select_region(), &quot;username&quot;: f&quot;{data[24]}{random_number()}&quot;, &quot;password&quot;: data[25]}<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:639: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def select_region():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_region_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:854: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.C_Users_Module_API.test_users_api.Test_Users_api object at 0x00000247288F1F90&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Users_Module_API\test_users_api.py:122: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x00000247291C8FD0&gt;<br/><br/>    def verify_delete_user_from_system(self):<br/>        result = []<br/>        try:<br/>            self.row = 19<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            data = user_create_request(2)<br/>            user_id = data[3]<br/>            ex_msg = Read_Expected_users_Response_msg().delete_user_success_msg(user_id)<br/>            response_list = get_delete_user_from_system_request(user_id)<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            ac_msg = self.json_response[&quot;message&quot;]<br/>            if response_validation(self.response) and ex_msg == ac_msg:<br/>                excel_result(self.row, &quot;Test_18&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_18&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_18&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:584: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_users_api.py:121 test_Users_Test_18  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/C_Users_Module_API/test_users_api.py::Test_Users_api::test_Users_Test_19</td>
          <td class="col-duration">7.42</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000024728E4E1D0&gt;<br/><br/>    def verify_delete_user(self):<br/>        result = []<br/>        try:<br/>            self.row = 20<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           data = user_create_request(2)<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:595: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 2<br/><br/>    def user_create_request(row_no):<br/>        token = login_token()<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().users_endpoint()}&quot;<br/>        data = users_test_data(row_no)<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        form_data = {&quot;auth_params&quot;: data[0], &quot;company&quot;: data[1], &quot;title&quot;: data[2], &quot;department&quot;: data[3],<br/>                     &quot;enabled&quot;: data[4], &quot;fname&quot;: data[5], &quot;mname&quot;: data[6], &quot;lname&quot;: data[7],<br/>                     &quot;addr1&quot;: data[8], &quot;addr2&quot;: data[9], &quot;city&quot;: data[10], &quot;state&quot;: data[11],<br/>                     &quot;zip&quot;: data[12], &quot;email&quot;: data[13], &quot;aemail&quot;: data[14], &quot;hphone&quot;: data[15],<br/>                     &quot;wphone&quot;: data[16], &quot;fphone&quot;: data[17], &quot;aphone&quot;: data[18], &quot;phone_type&quot;: data[19],<br/>                     &quot;provider&quot;: data[20], &quot;timezone&quot;: data[21], &quot;urole_id&quot;: select_user_role(),<br/>&gt;                    &quot;region_id&quot;: select_region(), &quot;username&quot;: f&quot;{data[24]}{random_number()}&quot;, &quot;password&quot;: data[25]}<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:639: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def select_region():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_region_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:854: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.C_Users_Module_API.test_users_api.Test_Users_api object at 0x00000247288E6290&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Users_Module_API\test_users_api.py:129: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Users_Module_API.Users_API_Methods.Users_API_Methods object at 0x0000024728E4E1D0&gt;<br/><br/>    def verify_delete_user(self):<br/>        result = []<br/>        try:<br/>            self.row = 20<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            data = user_create_request(2)<br/>            user_id = data[3]<br/>            ex_msg = Read_Expected_users_Response_msg().delete_user_success_msg(user_id)<br/>            response_list = get_delete_user_request(user_id)<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            ac_msg = self.json_response[&quot;message&quot;]<br/>            if response_validation(self.response) and ex_msg == ac_msg:<br/>                excel_result(self.row, &quot;Test_19&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_19&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_19&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:619: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_users_api.py:128 test_Users_Test_19  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/D_Enrollment_Data_Module_API/test_enrollment_data_api.py::Test_Enrollment_Data_api::test_Enrollment_Data_Test_01</td>
          <td class="col-duration">2.50</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;All_API_Methods_Package.Enrollment_Data_Module_API.Enrollment_Data_API_Methods.Enrollment_Data_API_Methods object at 0x000002472918CFD0&gt;<br/><br/>    def verify_get_enrollment_data_by_enrollment_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            token = login_token()<br/>            # case_id = create_enrollment_request()[3]<br/>&gt;           case_id = get_case_id(token)<br/><br/>All_API_Methods_Package\Enrollment_Data_Module_API\Enrollment_Data_API_Methods.py:27: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>token = &#x27;&#x27;<br/><br/>    def get_case_id(token):<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &#x27;Content-Type&#x27;: &#x27;application/json&#x27;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_all_enrollment_endpoint()}&quot;<br/>        request_body = {&quot;DetailLevel&quot;: 3, &quot;Offset&quot;: 0, &quot;count&quot;: 20, &quot;Ascending&quot;: 0, &quot;IsExact&quot;: False}<br/>        request_data = json.dumps(request_body)<br/>        response_str = requests.post(url, headers=headers, data=request_data)<br/>        response_json = response_str.json()<br/>&gt;       case_Id = response_json[&quot;caseInfo&quot;][&quot;cases&quot;][0][&quot;caseId&quot;]<br/><span class="error">E       IndexError: list index out of range</span><br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:631: IndexError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.D_Enrollment_Data_Module_API.test_enrollment_data_api.Test_Enrollment_Data_api object at 0x00000247288E4350&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Enrollment_Data_Module_API\test_enrollment_data_api.py:10: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Data_Module_API.Enrollment_Data_API_Methods.Enrollment_Data_API_Methods object at 0x000002472918CFD0&gt;<br/><br/>    def verify_get_enrollment_data_by_enrollment_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            token = login_token()<br/>            # case_id = create_enrollment_request()[3]<br/>            case_id = get_case_id(token)<br/>            print(case_id)<br/>            response_list = get_enrollment_data_by_enrollment_id_request(case_id)<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row,&quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row,&quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row,&quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Enrollment_Data_Module_API\Enrollment_Data_API_Methods.py:50: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>list index out of range
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_enrollment_data_api.py:9 test_Enrollment_Data_Test_01  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/D_Enrollment_Data_Module_API/test_enrollment_data_api.py::Test_Enrollment_Data_api::test_Enrollment_Data_Test_02</td>
          <td class="col-duration">2.48</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Data_Module_API.Enrollment_Data_API_Methods.Enrollment_Data_API_Methods object at 0x0000024727537890&gt;<br/><br/>    def verify_get_enrollment_data_by_page_number_and_batch_size(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = get_enrollment_data_by_page_number_and_batch_size_request()<br/><br/>All_API_Methods_Package\Enrollment_Data_Module_API\Enrollment_Data_API_Methods.py:61: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_enrollment_data_by_page_number_and_batch_size_request():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}&quot; \<br/>              f&quot;{Read_API_Endpoints().get_enrollment_data_by_page_number_and_batch_size_request_endpoint()}&quot;<br/>        print(url)<br/>        query_param = {<br/>            &quot;pageNumber&quot;: 0,<br/>            &quot;batchSize&quot;: 5,<br/>        }<br/>        response_str = requests.get(url, headers=headers, params=query_param)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Enrollment_Data_Module_API\Enrollment_Data_API_Methods.py:141: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.D_Enrollment_Data_Module_API.test_enrollment_data_api.Test_Enrollment_Data_api object at 0x00000247288D43D0&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Enrollment_Data_Module_API\test_enrollment_data_api.py:17: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Data_Module_API.Enrollment_Data_API_Methods.Enrollment_Data_API_Methods object at 0x0000024727537890&gt;<br/><br/>    def verify_get_enrollment_data_by_page_number_and_batch_size(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_enrollment_data_by_page_number_and_batch_size_request()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row,&quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row,&quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row,&quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Enrollment_Data_Module_API\Enrollment_Data_API_Methods.py:82: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>https://ff-india-qa10.eastus2.cloudapp.azure.com/api/internal/EnrollmentData
Expecting value: line 1 column 1 (char 0)
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_enrollment_data_api.py:16 test_Enrollment_Data_Test_02  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/D_Enrollment_Data_Module_API/test_enrollment_data_api.py::Test_Enrollment_Data_api::test_Enrollment_Data_Test_03</td>
          <td class="col-duration">2.45</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Data_Module_API.Enrollment_Data_API_Methods.Enrollment_Data_API_Methods object at 0x000002472916E710&gt;<br/><br/>    def verify_get_enrollment_data_count(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = get_enrollment_data_count_request()<br/><br/>All_API_Methods_Package\Enrollment_Data_Module_API\Enrollment_Data_API_Methods.py:93: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_enrollment_data_count_request():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_enrollment_data_count_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Enrollment_Data_Module_API\Enrollment_Data_API_Methods.py:150: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.D_Enrollment_Data_Module_API.test_enrollment_data_api.Test_Enrollment_Data_api object at 0x00000247288D54D0&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Enrollment_Data_Module_API\test_enrollment_data_api.py:24: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Data_Module_API.Enrollment_Data_API_Methods.Enrollment_Data_API_Methods object at 0x000002472916E710&gt;<br/><br/>    def verify_get_enrollment_data_count(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_enrollment_data_count_request()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row,&quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row,&quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row,&quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Enrollment_Data_Module_API\Enrollment_Data_API_Methods.py:114: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>Expecting value: line 1 column 1 (char 0)
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_enrollment_data_api.py:23 test_Enrollment_Data_Test_03  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/D_Enrollment_Group_Data_Module_API/test_enrollment_group_data_api.py::Test_Enrollment_Group_Datat_api::test_Enrollment_Group_Data_Test_01</td>
          <td class="col-duration">2.45</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Group_Data_Module_API.Enrollment_Group_Data_API_Methods.Enrollment_Group_Data_API_Methods object at 0x0000024729258690&gt;<br/><br/>    def verify_get_enrollment_group_data_by_enrollment_group_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           c_group_id = get_all_enrollment_group_request()[1][2][&quot;id&quot;]<br/><br/>All_API_Methods_Package\Enrollment_Group_Data_Module_API\Enrollment_Group_Data_API_Methods.py:26: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_all_enrollment_group_request():<br/>        token = login_token()<br/>        print(token)<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_all_enrollment_group_endpoint()}&quot;<br/>        print(url)<br/>        response_str = requests.get(url, headers=headers)<br/>        print(response_str)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:439: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.D_Enrollment_Group_Data_Module_API.test_enrollment_group_data_api.Test_Enrollment_Group_Datat_api object at 0x00000247288F0250&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Enrollment_Group_Data_Module_API\test_enrollment_group_data_api.py:11: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Group_Data_Module_API.Enrollment_Group_Data_API_Methods.Enrollment_Group_Data_API_Methods object at 0x0000024729258690&gt;<br/><br/>    def verify_get_enrollment_group_data_by_enrollment_group_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            c_group_id = get_all_enrollment_group_request()[1][2][&quot;id&quot;]<br/>            print(c_group_id)<br/>            response_list = get_enrollment_group_data_by_enrollment_group_id_request(c_group_id)<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row,&quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row,&quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row,&quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Enrollment_Group_Data_Module_API\Enrollment_Group_Data_API_Methods.py:49: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>
https://ff-india-qa10.eastus2.cloudapp.azure.com/api/EnrollmentGroups
&lt;Response [401]&gt;
Expecting value: line 1 column 1 (char 0)
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_enrollment_group_data_api.py:10 test_Enrollment_Group_Data_Test_01  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/D_Enrollment_Group_Data_Module_API/test_enrollment_group_data_api.py::Test_Enrollment_Group_Datat_api::test_Enrollment_Group_Data_Test_02</td>
          <td class="col-duration">2.50</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Group_Data_Module_API.Enrollment_Group_Data_API_Methods.Enrollment_Group_Data_API_Methods object at 0x0000024728E23510&gt;<br/><br/>    def verify_get_enrollment_group_data_by_page_number_and_batch_size(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = get_enrollment_group_data_by_page_number_and_batch_size_request()<br/><br/>All_API_Methods_Package\Enrollment_Group_Data_Module_API\Enrollment_Group_Data_API_Methods.py:60: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_enrollment_group_data_by_page_number_and_batch_size_request():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}&quot; \<br/>                  f&quot;{Read_API_Endpoints().get_enrollment_group_data_by_page_number_and_batch_size_endpoint()}&quot;<br/>        print(url)<br/>        query_param = {<br/>                &quot;pageNumber&quot;: 0,<br/>                &quot;batchSize&quot;: 5,<br/>            }<br/>        response_str = requests.get(url, headers=headers, params=query_param)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Enrollment_Group_Data_Module_API\Enrollment_Group_Data_API_Methods.py:141: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.D_Enrollment_Group_Data_Module_API.test_enrollment_group_data_api.Test_Enrollment_Group_Datat_api object at 0x00000247288F2D90&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Enrollment_Group_Data_Module_API\test_enrollment_group_data_api.py:18: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Group_Data_Module_API.Enrollment_Group_Data_API_Methods.Enrollment_Group_Data_API_Methods object at 0x0000024728E23510&gt;<br/><br/>    def verify_get_enrollment_group_data_by_page_number_and_batch_size(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_enrollment_group_data_by_page_number_and_batch_size_request()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row,&quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row,&quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row,&quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Enrollment_Group_Data_Module_API\Enrollment_Group_Data_API_Methods.py:81: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>https://ff-india-qa10.eastus2.cloudapp.azure.com/api/internal/EnrollmentGroupData
Expecting value: line 1 column 1 (char 0)
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_enrollment_group_data_api.py:17 test_Enrollment_Group_Data_Test_02  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/D_Enrollment_Group_Data_Module_API/test_enrollment_group_data_api.py::Test_Enrollment_Group_Datat_api::test_Enrollment_Group_Data_Test_03</td>
          <td class="col-duration">2.45</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Group_Data_Module_API.Enrollment_Group_Data_API_Methods.Enrollment_Group_Data_API_Methods object at 0x00000247292F6210&gt;<br/><br/>    def verify_get_enrollment_group_data_count(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = get_enrollment_group_data_count_request()<br/><br/>All_API_Methods_Package\Enrollment_Group_Data_Module_API\Enrollment_Group_Data_API_Methods.py:92: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_enrollment_group_data_count_request():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_enrollment_group_data_count_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Enrollment_Group_Data_Module_API\Enrollment_Group_Data_API_Methods.py:150: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.D_Enrollment_Group_Data_Module_API.test_enrollment_group_data_api.Test_Enrollment_Group_Datat_api object at 0x00000247288D4F50&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Enrollment_Group_Data_Module_API\test_enrollment_group_data_api.py:25: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Group_Data_Module_API.Enrollment_Group_Data_API_Methods.Enrollment_Group_Data_API_Methods object at 0x00000247292F6210&gt;<br/><br/>    def verify_get_enrollment_group_data_count(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_enrollment_group_data_count_request()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row,&quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row,&quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row,&quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Enrollment_Group_Data_Module_API\Enrollment_Group_Data_API_Methods.py:113: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>Expecting value: line 1 column 1 (char 0)
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_enrollment_group_data_api.py:24 test_Enrollment_Group_Data_Test_03  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/D_Enrollment_Group_Module_API/test_enrollment_group_api.py::Test_enrollment_group_api::test_enrollment_group_Test_01</td>
          <td class="col-duration">2.51</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x000002472915A150&gt;<br/><br/>    def verify_the_get_all_enrollment_group(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = get_all_enrollment_group_request()<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:30: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_all_enrollment_group_request():<br/>        token = login_token()<br/>        print(token)<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_all_enrollment_group_endpoint()}&quot;<br/>        print(url)<br/>        response_str = requests.get(url, headers=headers)<br/>        print(response_str)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:439: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.D_Enrollment_Group_Module_API.test_enrollment_group_api.Test_enrollment_group_api object at 0x00000247288D6350&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Enrollment_Group_Module_API\test_enrollment_group_api.py:11: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x000002472915A150&gt;<br/><br/>    def verify_the_get_all_enrollment_group(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_all_enrollment_group_request()<br/>            self.response = response_list[0]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:51: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>
https://ff-india-qa10.eastus2.cloudapp.azure.com/api/EnrollmentGroups
&lt;Response [401]&gt;
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_enrollment_group_api.py:10 test_enrollment_group_Test_01  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/D_Enrollment_Group_Module_API/test_enrollment_group_api.py::Test_enrollment_group_api::test_enrollment_group_Test_02</td>
          <td class="col-duration">3.18</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x000002472903E910&gt;<br/><br/>    def verify_the_enrollment_groups_is_created_with_valid_data(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = create_enrollment_group_request(self.row)<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:62: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 3<br/><br/>    def create_enrollment_group_request(row_no):<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>        data = create_enrollment_group_test_data(row_no)<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_enrollment_group_endpoint()}&quot;<br/>        name = f&quot;{data[0]}{random_number()}&quot;<br/>        request_body = {&quot;name&quot;: name, &quot;description&quot;: data[1], &quot;faceThreshold&quot;: data[2], &quot;maskedFaceThreshold&quot;: data[3],<br/>                        &quot;eventsSuppressionInterval&quot;: data[4], &quot;priority&quot;: data[5], &quot;seriousOffender&quot;: data[6],<br/>                        &quot;alertHexColor&quot;: data[7], &quot;activeThreat&quot;: data[8]}<br/>        request_data = json.dumps(request_body)<br/>        response_str = requests.post(url, data=request_data, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:455: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.D_Enrollment_Group_Module_API.test_enrollment_group_api.Test_enrollment_group_api object at 0x00000247288D5CD0&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Enrollment_Group_Module_API\test_enrollment_group_api.py:18: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x000002472903E910&gt;<br/><br/>    def verify_the_enrollment_groups_is_created_with_valid_data(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = create_enrollment_group_request(self.row)<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.act_msg = self.json_response[&quot;message&quot;]<br/>            exp_id = response_list[3]<br/>            self.exp_msg = Read_Expected_Enrollment_Group_Response_msg().create_enrollment_group_msg(exp_id)<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:88: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_enrollment_group_api.py:17 test_enrollment_group_Test_02  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/D_Enrollment_Group_Module_API/test_enrollment_group_api.py::Test_enrollment_group_api::test_enrollment_group_Test_03</td>
          <td class="col-duration">4.50</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x0000024728E13310&gt;<br/><br/>    def verify_the_get_single_enrollment_group(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = get_enrollment_group_by_id()<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:99: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_enrollment_group_by_id():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>&gt;       data = create_enrollment_group_request(3)<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:588: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 3<br/><br/>    def create_enrollment_group_request(row_no):<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>        data = create_enrollment_group_test_data(row_no)<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_enrollment_group_endpoint()}&quot;<br/>        name = f&quot;{data[0]}{random_number()}&quot;<br/>        request_body = {&quot;name&quot;: name, &quot;description&quot;: data[1], &quot;faceThreshold&quot;: data[2], &quot;maskedFaceThreshold&quot;: data[3],<br/>                        &quot;eventsSuppressionInterval&quot;: data[4], &quot;priority&quot;: data[5], &quot;seriousOffender&quot;: data[6],<br/>                        &quot;alertHexColor&quot;: data[7], &quot;activeThreat&quot;: data[8]}<br/>        request_data = json.dumps(request_body)<br/>        response_str = requests.post(url, data=request_data, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:455: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.D_Enrollment_Group_Module_API.test_enrollment_group_api.Test_enrollment_group_api object at 0x00000247288D4110&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Enrollment_Group_Module_API\test_enrollment_group_api.py:25: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x0000024728E13310&gt;<br/><br/>    def verify_the_get_single_enrollment_group(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_enrollment_group_by_id()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:122: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_enrollment_group_api.py:24 test_enrollment_group_Test_03  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/D_Enrollment_Group_Module_API/test_enrollment_group_api.py::Test_enrollment_group_api::test_enrollment_group_Test_04</td>
          <td class="col-duration">4.45</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x0000024728883F90&gt;<br/><br/>    def verify_the_update_enrollment_group(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = update_enrollment_group_request(self.row)<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:133: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 5<br/><br/>    def update_enrollment_group_request(row_no):<br/>        token = login_token()<br/>&gt;       res = create_enrollment_group_request(3)<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:560: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 3<br/><br/>    def create_enrollment_group_request(row_no):<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>        data = create_enrollment_group_test_data(row_no)<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_enrollment_group_endpoint()}&quot;<br/>        name = f&quot;{data[0]}{random_number()}&quot;<br/>        request_body = {&quot;name&quot;: name, &quot;description&quot;: data[1], &quot;faceThreshold&quot;: data[2], &quot;maskedFaceThreshold&quot;: data[3],<br/>                        &quot;eventsSuppressionInterval&quot;: data[4], &quot;priority&quot;: data[5], &quot;seriousOffender&quot;: data[6],<br/>                        &quot;alertHexColor&quot;: data[7], &quot;activeThreat&quot;: data[8]}<br/>        request_data = json.dumps(request_body)<br/>        response_str = requests.post(url, data=request_data, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:455: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.D_Enrollment_Group_Module_API.test_enrollment_group_api.Test_enrollment_group_api object at 0x00000247288D7D50&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Enrollment_Group_Module_API\test_enrollment_group_api.py:32: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x0000024728883F90&gt;<br/><br/>    def verify_the_update_enrollment_group(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = update_enrollment_group_request(self.row)<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.act_msg = self.json_response[&quot;message&quot;]<br/>            act_group_id = self.json_response[&quot;data&quot;]<br/>            exp_group_id = response_list[3]<br/>            self.exp_msg = Read_Expected_Enrollment_Group_Response_msg().update_enrollment_group_msg()<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg and act_group_id == exp_group_id:<br/>                excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:160: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_enrollment_group_api.py:31 test_enrollment_group_Test_04  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/D_Enrollment_Group_Module_API/test_enrollment_group_api.py::Test_enrollment_group_api::test_enrollment_group_Test_05</td>
          <td class="col-duration">4.41</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x0000024728C5CC10&gt;<br/><br/>    def verify_remove_a_single_Enrollment_Group_from_collection(self):<br/>        result = []<br/>        try:<br/>            self.row = 6<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = delete_enrollment_group()<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:171: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def delete_enrollment_group():<br/>        token = login_token()<br/>&gt;       res = create_enrollment_group_request(3)<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:576: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 3<br/><br/>    def create_enrollment_group_request(row_no):<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>        data = create_enrollment_group_test_data(row_no)<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_enrollment_group_endpoint()}&quot;<br/>        name = f&quot;{data[0]}{random_number()}&quot;<br/>        request_body = {&quot;name&quot;: name, &quot;description&quot;: data[1], &quot;faceThreshold&quot;: data[2], &quot;maskedFaceThreshold&quot;: data[3],<br/>                        &quot;eventsSuppressionInterval&quot;: data[4], &quot;priority&quot;: data[5], &quot;seriousOffender&quot;: data[6],<br/>                        &quot;alertHexColor&quot;: data[7], &quot;activeThreat&quot;: data[8]}<br/>        request_data = json.dumps(request_body)<br/>        response_str = requests.post(url, data=request_data, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:455: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.D_Enrollment_Group_Module_API.test_enrollment_group_api.Test_enrollment_group_api object at 0x00000247288D33D0&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Enrollment_Group_Module_API\test_enrollment_group_api.py:39: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x0000024728C5CC10&gt;<br/><br/>    def verify_remove_a_single_Enrollment_Group_from_collection(self):<br/>        result = []<br/>        try:<br/>            self.row = 6<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = delete_enrollment_group()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            self.act_msg = self.json_response[&quot;message&quot;]<br/>            exp_id = response_list[2]<br/>            self.exp_msg = Read_Expected_Enrollment_Group_Response_msg().delete_enrollment_group_msg(exp_id)<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:196: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_enrollment_group_api.py:38 test_enrollment_group_Test_05  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/D_Enrollment_Group_Module_API/test_enrollment_group_api.py::Test_enrollment_group_api::test_enrollment_group_Test_06</td>
          <td class="col-duration">4.46</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x0000024728C8DD50&gt;<br/><br/>    def verify_create_enrollment_group_with_addCaseGroupZone(self):<br/>        result = []<br/>        try:<br/>            self.row = 7<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = create_enrollment_group_with_addCaseGroupZone_request()<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:207: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_enrollment_group_with_addCaseGroupZone_request():<br/>        token = login_token()<br/>&gt;       data = create_enrollment_group_request(3)<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:463: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 3<br/><br/>    def create_enrollment_group_request(row_no):<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>        data = create_enrollment_group_test_data(row_no)<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_enrollment_group_endpoint()}&quot;<br/>        name = f&quot;{data[0]}{random_number()}&quot;<br/>        request_body = {&quot;name&quot;: name, &quot;description&quot;: data[1], &quot;faceThreshold&quot;: data[2], &quot;maskedFaceThreshold&quot;: data[3],<br/>                        &quot;eventsSuppressionInterval&quot;: data[4], &quot;priority&quot;: data[5], &quot;seriousOffender&quot;: data[6],<br/>                        &quot;alertHexColor&quot;: data[7], &quot;activeThreat&quot;: data[8]}<br/>        request_data = json.dumps(request_body)<br/>        response_str = requests.post(url, data=request_data, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:455: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.D_Enrollment_Group_Module_API.test_enrollment_group_api.Test_enrollment_group_api object at 0x00000247288D2C10&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Enrollment_Group_Module_API\test_enrollment_group_api.py:46: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x0000024728C8DD50&gt;<br/><br/>    def verify_create_enrollment_group_with_addCaseGroupZone(self):<br/>        result = []<br/>        try:<br/>            self.row = 7<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = create_enrollment_group_with_addCaseGroupZone_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.act_msg = self.json_response[&quot;result&quot;][&quot;message&quot;]<br/>            account_id = response_list[3]<br/>            cGroupId = response_list[4]<br/>            self.exp_msg = Read_Expected_Enrollment_Group_Response_msg(). \<br/>                create_enrollment_group_with_addCaseGroupZone_msg(cGroupId, account_id)<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:235: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_enrollment_group_api.py:45 test_enrollment_group_Test_06  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/D_Enrollment_Group_Module_API/test_enrollment_group_api.py::Test_enrollment_group_api::test_enrollment_group_Test_07</td>
          <td class="col-duration">4.50</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x0000024729375E10&gt;<br/><br/>    def verify_removeCaseGroupZone(self):<br/>        result = []<br/>        try:<br/>            self.row = 8<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = remove_enrollment_group_with_removeCaseGroupZone_request()<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:246: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def remove_enrollment_group_with_removeCaseGroupZone_request():<br/>        token = login_token()<br/>&gt;       data = create_enrollment_group_request(3)<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:495: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 3<br/><br/>    def create_enrollment_group_request(row_no):<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>        data = create_enrollment_group_test_data(row_no)<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_enrollment_group_endpoint()}&quot;<br/>        name = f&quot;{data[0]}{random_number()}&quot;<br/>        request_body = {&quot;name&quot;: name, &quot;description&quot;: data[1], &quot;faceThreshold&quot;: data[2], &quot;maskedFaceThreshold&quot;: data[3],<br/>                        &quot;eventsSuppressionInterval&quot;: data[4], &quot;priority&quot;: data[5], &quot;seriousOffender&quot;: data[6],<br/>                        &quot;alertHexColor&quot;: data[7], &quot;activeThreat&quot;: data[8]}<br/>        request_data = json.dumps(request_body)<br/>        response_str = requests.post(url, data=request_data, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:455: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.D_Enrollment_Group_Module_API.test_enrollment_group_api.Test_enrollment_group_api object at 0x00000247288D1150&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Enrollment_Group_Module_API\test_enrollment_group_api.py:53: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x0000024729375E10&gt;<br/><br/>    def verify_removeCaseGroupZone(self):<br/>        result = []<br/>        try:<br/>            self.row = 8<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = remove_enrollment_group_with_removeCaseGroupZone_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.act_msg = self.json_response[&quot;result&quot;][&quot;message&quot;]<br/>            account_id = response_list[3]<br/>            cGroupId = response_list[4]<br/>            self.exp_msg = Read_Expected_Enrollment_Group_Response_msg(). \<br/>                removeCaseGroupZone_msg(cGroupId, account_id)<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_07&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_07&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_07&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:274: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_enrollment_group_api.py:52 test_enrollment_group_Test_07  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/D_Enrollment_Group_Module_API/test_enrollment_group_api.py::Test_enrollment_group_api::test_enrollment_group_Test_08</td>
          <td class="col-duration">4.60</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x0000024726F73F50&gt;<br/><br/>    def verify_addCaseGroupCase(self):<br/>        result = []<br/>        try:<br/>            self.row = 9<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = create_enrollment_group_with_verify_addCaseGroupCase_request()<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:285: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_enrollment_group_with_verify_addCaseGroupCase_request():<br/>        token = login_token()<br/>&gt;       data = create_enrollment_group_request(3)<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:480: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 3<br/><br/>    def create_enrollment_group_request(row_no):<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>        data = create_enrollment_group_test_data(row_no)<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_enrollment_group_endpoint()}&quot;<br/>        name = f&quot;{data[0]}{random_number()}&quot;<br/>        request_body = {&quot;name&quot;: name, &quot;description&quot;: data[1], &quot;faceThreshold&quot;: data[2], &quot;maskedFaceThreshold&quot;: data[3],<br/>                        &quot;eventsSuppressionInterval&quot;: data[4], &quot;priority&quot;: data[5], &quot;seriousOffender&quot;: data[6],<br/>                        &quot;alertHexColor&quot;: data[7], &quot;activeThreat&quot;: data[8]}<br/>        request_data = json.dumps(request_body)<br/>        response_str = requests.post(url, data=request_data, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:455: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.D_Enrollment_Group_Module_API.test_enrollment_group_api.Test_enrollment_group_api object at 0x00000247288D3610&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Enrollment_Group_Module_API\test_enrollment_group_api.py:60: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x0000024726F73F50&gt;<br/><br/>    def verify_addCaseGroupCase(self):<br/>        result = []<br/>        try:<br/>            self.row = 9<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = create_enrollment_group_with_verify_addCaseGroupCase_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.act_msg = self.json_response[&quot;result&quot;][&quot;message&quot;]<br/>            account_id = response_list[3]<br/>            cGroupId = response_list[4]<br/>            self.exp_msg = Read_Expected_Enrollment_Group_Response_msg().addCaseGroupCase_msg(cGroupId, account_id)<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:310: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_enrollment_group_api.py:59 test_enrollment_group_Test_08  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/D_Enrollment_Group_Module_API/test_enrollment_group_api.py::Test_enrollment_group_api::test_enrollment_group_Test_09</td>
          <td class="col-duration">4.47</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x00000247293E8F50&gt;<br/><br/>    def verify_removeCaseGroupCase(self):<br/>        result = []<br/>        try:<br/>            self.row = 10<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = remove_enrollment_group_with_removeCaseGroupCase_request()<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:321: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def remove_enrollment_group_with_removeCaseGroupCase_request():<br/>        token = login_token()<br/>&gt;       data = create_enrollment_group_request(3)<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:511: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 3<br/><br/>    def create_enrollment_group_request(row_no):<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>        data = create_enrollment_group_test_data(row_no)<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_enrollment_group_endpoint()}&quot;<br/>        name = f&quot;{data[0]}{random_number()}&quot;<br/>        request_body = {&quot;name&quot;: name, &quot;description&quot;: data[1], &quot;faceThreshold&quot;: data[2], &quot;maskedFaceThreshold&quot;: data[3],<br/>                        &quot;eventsSuppressionInterval&quot;: data[4], &quot;priority&quot;: data[5], &quot;seriousOffender&quot;: data[6],<br/>                        &quot;alertHexColor&quot;: data[7], &quot;activeThreat&quot;: data[8]}<br/>        request_data = json.dumps(request_body)<br/>        response_str = requests.post(url, data=request_data, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:455: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.D_Enrollment_Group_Module_API.test_enrollment_group_api.Test_enrollment_group_api object at 0x00000247288D1550&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Enrollment_Group_Module_API\test_enrollment_group_api.py:67: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x00000247293E8F50&gt;<br/><br/>    def verify_removeCaseGroupCase(self):<br/>        result = []<br/>        try:<br/>            self.row = 10<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = remove_enrollment_group_with_removeCaseGroupCase_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.act_msg = self.json_response[&quot;result&quot;][&quot;message&quot;]<br/>            account_id = response_list[3]<br/>            cGroupId = response_list[4]<br/>            self.exp_msg = Read_Expected_Enrollment_Group_Response_msg().removeCaseGroupCase_msg(cGroupId, account_id)<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_09&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_09&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_09&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:348: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_enrollment_group_api.py:66 test_enrollment_group_Test_09  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/D_Enrollment_Group_Module_API/test_enrollment_group_api.py::Test_enrollment_group_api::test_enrollment_group_Test_10</td>
          <td class="col-duration">4.34</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x0000024729476F90&gt;<br/><br/>    def verify_addAlertGroupCase(self):<br/>        result = []<br/>        try:<br/>            self.row = 11<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = remove_enrollment_group_with_addAlertGroupCase_request()<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:359: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def remove_enrollment_group_with_addAlertGroupCase_request():<br/>        token = login_token()<br/>&gt;       data = create_enrollment_group_request(3)<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:526: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 3<br/><br/>    def create_enrollment_group_request(row_no):<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>        data = create_enrollment_group_test_data(row_no)<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_enrollment_group_endpoint()}&quot;<br/>        name = f&quot;{data[0]}{random_number()}&quot;<br/>        request_body = {&quot;name&quot;: name, &quot;description&quot;: data[1], &quot;faceThreshold&quot;: data[2], &quot;maskedFaceThreshold&quot;: data[3],<br/>                        &quot;eventsSuppressionInterval&quot;: data[4], &quot;priority&quot;: data[5], &quot;seriousOffender&quot;: data[6],<br/>                        &quot;alertHexColor&quot;: data[7], &quot;activeThreat&quot;: data[8]}<br/>        request_data = json.dumps(request_body)<br/>        response_str = requests.post(url, data=request_data, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:455: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.D_Enrollment_Group_Module_API.test_enrollment_group_api.Test_enrollment_group_api object at 0x00000247288D37D0&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Enrollment_Group_Module_API\test_enrollment_group_api.py:74: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x0000024729476F90&gt;<br/><br/>    def verify_addAlertGroupCase(self):<br/>        result = []<br/>        try:<br/>            self.row = 11<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = remove_enrollment_group_with_addAlertGroupCase_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.act_msg = self.json_response[&quot;result&quot;][&quot;message&quot;]<br/>            cGroupId = response_list[4]<br/>            self.exp_msg = Read_Expected_Enrollment_Group_Response_msg().addAlertGroupCase_msg(cGroupId)<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_10&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_10&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_10&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:385: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_enrollment_group_api.py:73 test_enrollment_group_Test_10  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/D_Enrollment_Group_Module_API/test_enrollment_group_api.py::Test_enrollment_group_api::test_enrollment_group_Test_11</td>
          <td class="col-duration">5.68</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x0000024728D3F490&gt;<br/><br/>    def verify_removeAlertGroupCase(self):<br/>        result = []<br/>        try:<br/>            self.row = 12<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = remove_enrollment_group_with_removeAlertGroupCase_request()<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:396: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def remove_enrollment_group_with_removeAlertGroupCase_request():<br/>        token = login_token()<br/>&gt;       data = remove_enrollment_group_with_addAlertGroupCase_request()<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:544: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def remove_enrollment_group_with_addAlertGroupCase_request():<br/>        token = login_token()<br/>&gt;       data = create_enrollment_group_request(3)<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:526: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 3<br/><br/>    def create_enrollment_group_request(row_no):<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>        data = create_enrollment_group_test_data(row_no)<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_enrollment_group_endpoint()}&quot;<br/>        name = f&quot;{data[0]}{random_number()}&quot;<br/>        request_body = {&quot;name&quot;: name, &quot;description&quot;: data[1], &quot;faceThreshold&quot;: data[2], &quot;maskedFaceThreshold&quot;: data[3],<br/>                        &quot;eventsSuppressionInterval&quot;: data[4], &quot;priority&quot;: data[5], &quot;seriousOffender&quot;: data[6],<br/>                        &quot;alertHexColor&quot;: data[7], &quot;activeThreat&quot;: data[8]}<br/>        request_data = json.dumps(request_body)<br/>        response_str = requests.post(url, data=request_data, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:455: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.D_Enrollment_Group_Module_API.test_enrollment_group_api.Test_enrollment_group_api object at 0x00000247288D1810&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Enrollment_Group_Module_API\test_enrollment_group_api.py:81: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Enrollment_Group_Module_API.Enrollment_Group_API_Methods.Enrollment_Group_API_Methods object at 0x0000024728D3F490&gt;<br/><br/>    def verify_removeAlertGroupCase(self):<br/>        result = []<br/>        try:<br/>            self.row = 12<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = remove_enrollment_group_with_removeAlertGroupCase_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.act_msg = self.json_response[&quot;result&quot;][&quot;message&quot;]<br/>            cGroupId = response_list[4]<br/>            self.exp_msg = Read_Expected_Enrollment_Group_Response_msg().removeAlertGroupCase_msg(cGroupId)<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_11&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_11&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_11&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:422: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_enrollment_group_api.py:80 test_enrollment_group_Test_11  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/E_Notification_Groups_Module_APi/test_notification_groups_api.py::Test_Notification_groups_api::test_Notification_Groups_Test_01</td>
          <td class="col-duration">2.48</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Notification_groups_Module_API.Notification_Groups_Methods.Notification_Groups_API_Methods object at 0x00000247294EE1D0&gt;<br/><br/>    def verify_create_notification_group_with_users_enrollment_group_zones(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = create_notification_group_with_users_enrollment_group_zones()<br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:32: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_notification_group_with_users_enrollment_group_zones():<br/>&gt;       user_info_list = get_user_info()<br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:460: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_user_info():<br/>        &quot;&quot;&quot;<br/>        0. accountId<br/>        1. regionId<br/>        2. userName<br/>        3. userId<br/>        4. userRoleId<br/>        :return:<br/>        &quot;&quot;&quot;<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_main_user_info()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:610: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.E_Notification_Groups_Module_APi.test_notification_groups_api.Test_Notification_groups_api object at 0x00000247288B6D10&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Notification_Groups_Module_APi\test_notification_groups_api.py:13: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Notification_groups_Module_API.Notification_Groups_Methods.Notification_Groups_API_Methods object at 0x00000247294EE1D0&gt;<br/><br/>    def verify_create_notification_group_with_users_enrollment_group_zones(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = create_notification_group_with_users_enrollment_group_zones()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            alert_id = self.json_response[&quot;data&quot;]<br/>            self.act_msg = self.json_response[&quot;message&quot;]<br/>            print(response_list)<br/>            self.exp_msg = Read_Expected_Notification_Groups_Response_msg().notification_created_success_msg(alert_id)<br/>            if response_validation(self.response) and self.exp_msg == self.act_msg:<br/>                excel_result(self.row,&quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row,&quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:58: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>Expecting value: line 1 column 1 (char 0)
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_notification_groups_api.py:11 test_Notification_Groups_Test_01  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/E_Notification_Groups_Module_APi/test_notification_groups_api.py::Test_Notification_groups_api::test_Notification_Groups_Test_02</td>
          <td class="col-duration">2.58</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Notification_groups_Module_API.Notification_Groups_Methods.Notification_Groups_API_Methods object at 0x000002472927E1D0&gt;<br/><br/>    def verify_create_notification_group_without_users_enrollment_group_and_zones(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = create_notification_group_without_users_enrollment_group_zones()<br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:69: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_notification_group_without_users_enrollment_group_zones():<br/>&gt;       user_info_list = get_user_info()<br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:477: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_user_info():<br/>        &quot;&quot;&quot;<br/>        0. accountId<br/>        1. regionId<br/>        2. userName<br/>        3. userId<br/>        4. userRoleId<br/>        :return:<br/>        &quot;&quot;&quot;<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_main_user_info()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:610: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.E_Notification_Groups_Module_APi.test_notification_groups_api.Test_Notification_groups_api object at 0x00000247288B4190&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Notification_Groups_Module_APi\test_notification_groups_api.py:21: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Notification_groups_Module_API.Notification_Groups_Methods.Notification_Groups_API_Methods object at 0x000002472927E1D0&gt;<br/><br/>    def verify_create_notification_group_without_users_enrollment_group_and_zones(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = create_notification_group_without_users_enrollment_group_zones()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            alert_id = self.json_response[&quot;data&quot;]<br/>            self.act_msg = self.json_response[&quot;message&quot;]<br/>            print(response_list)<br/>            self.exp_msg = Read_Expected_Notification_Groups_Response_msg().notification_created_success_msg(alert_id)<br/>            if response_validation(self.response) and self.exp_msg == self.act_msg:<br/>                excel_result(self.row,&quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row,&quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:95: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>Expecting value: line 1 column 1 (char 0)
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_notification_groups_api.py:19 test_Notification_Groups_Test_02  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/E_Notification_Groups_Module_APi/test_notification_groups_api.py::Test_Notification_groups_api::test_Notification_Groups_Test_03</td>
          <td class="col-duration">2.47</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Notification_groups_Module_API.Notification_Groups_Methods.Notification_Groups_API_Methods object at 0x00000247180D7E90&gt;<br/><br/>    def verify_get_all_alert_groups(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = get_all_notification_groups()<br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:106: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_all_notification_groups():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_all_alert_groups_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:510: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.E_Notification_Groups_Module_APi.test_notification_groups_api.Test_Notification_groups_api object at 0x00000247288B6AD0&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Notification_Groups_Module_APi\test_notification_groups_api.py:29: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Notification_groups_Module_API.Notification_Groups_Methods.Notification_Groups_API_Methods object at 0x00000247180D7E90&gt;<br/><br/>    def verify_get_all_alert_groups(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_all_notification_groups()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            print(response_list)<br/>            if response_validation(self.response):<br/>                excel_result(self.row,&quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row,&quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row,&quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:128: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>Expecting value: line 1 column 1 (char 0)
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_notification_groups_api.py:27 test_Notification_Groups_Test_03  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/E_Notification_Groups_Module_APi/test_notification_groups_api.py::Test_Notification_groups_api::test_Notification_Groups_Test_04</td>
          <td class="col-duration">2.48</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Notification_groups_Module_API.Notification_Groups_Methods.Notification_Groups_API_Methods object at 0x0000024718186990&gt;<br/><br/>    def verify_get_single_alert_group_using_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           post_response_list = create_notification_group_without_users_enrollment_group_zones()<br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:139: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_notification_group_without_users_enrollment_group_zones():<br/>&gt;       user_info_list = get_user_info()<br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:477: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_user_info():<br/>        &quot;&quot;&quot;<br/>        0. accountId<br/>        1. regionId<br/>        2. userName<br/>        3. userId<br/>        4. userRoleId<br/>        :return:<br/>        &quot;&quot;&quot;<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_main_user_info()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:610: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.E_Notification_Groups_Module_APi.test_notification_groups_api.Test_Notification_groups_api object at 0x00000247288B6310&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Notification_Groups_Module_APi\test_notification_groups_api.py:37: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Notification_groups_Module_API.Notification_Groups_Methods.Notification_Groups_API_Methods object at 0x0000024718186990&gt;<br/><br/>    def verify_get_single_alert_group_using_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            post_response_list = create_notification_group_without_users_enrollment_group_zones()<br/>            alert_id = post_response_list[2][&quot;data&quot;]<br/>            ex_alert_name = post_response_list[3]<br/>            response_list = get_notification_group_using_id(alert_id)<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            ac_alert_name = self.json_response[&quot;agroupinfo&quot;][&quot;agroups&quot;][0][&quot;name&quot;]<br/>            print(response_list)<br/>            if response_validation(self.response) and ex_alert_name == ac_alert_name:<br/>                excel_result(self.row,&quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row,&quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row,&quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:165: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>Expecting value: line 1 column 1 (char 0)
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_notification_groups_api.py:35 test_Notification_Groups_Test_04  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/E_Notification_Groups_Module_APi/test_notification_groups_api.py::Test_Notification_groups_api::test_Notification_Groups_Test_05</td>
          <td class="col-duration">2.70</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Notification_groups_Module_API.Notification_Groups_Methods.Notification_Groups_API_Methods object at 0x0000024728BF65D0&gt;<br/><br/>    def modify_alert_group(self):<br/>        result = []<br/>        try:<br/>            self.row = 6<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           post_response_list = create_notification_group_without_users_enrollment_group_zones()<br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:176: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_notification_group_without_users_enrollment_group_zones():<br/>&gt;       user_info_list = get_user_info()<br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:477: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_user_info():<br/>        &quot;&quot;&quot;<br/>        0. accountId<br/>        1. regionId<br/>        2. userName<br/>        3. userId<br/>        4. userRoleId<br/>        :return:<br/>        &quot;&quot;&quot;<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_main_user_info()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:610: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.E_Notification_Groups_Module_APi.test_notification_groups_api.Test_Notification_groups_api object at 0x00000247288B4AD0&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Notification_Groups_Module_APi\test_notification_groups_api.py:45: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Notification_groups_Module_API.Notification_Groups_Methods.Notification_Groups_API_Methods object at 0x0000024728BF65D0&gt;<br/><br/>    def modify_alert_group(self):<br/>        result = []<br/>        try:<br/>            self.row = 6<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            post_response_list = create_notification_group_without_users_enrollment_group_zones()<br/>            print(post_response_list)<br/>            alert_id = post_response_list[2][&quot;data&quot;]<br/>            alert_name = post_response_list[3]<br/>            print(alert_id)<br/>            print(alert_name)<br/>            response_list = edit_alert_group_request(alert_id,alert_name)<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            print(&quot;response_list&quot;,response_list)<br/>            ex_update_msg = Read_Expected_Notification_Groups_Response_msg().notification_updated_success_msg(alert_id)<br/>            ac_update_msg = response_list[2][&quot;message&quot;]<br/>            if response_validation(self.response) and ex_update_msg == ac_update_msg:<br/>                excel_result(self.row,&quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row,&quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row,&quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:207: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>Expecting value: line 1 column 1 (char 0)
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_notification_groups_api.py:43 test_Notification_Groups_Test_05  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/E_Notification_Groups_Module_APi/test_notification_groups_api.py::Test_Notification_groups_api::test_Notification_Groups_Test_06</td>
          <td class="col-duration">2.60</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Notification_groups_Module_API.Notification_Groups_Methods.Notification_Groups_API_Methods object at 0x0000024718186210&gt;<br/><br/>    def verify_add_user_to_alert_group(self):<br/>        result = []<br/>        try:<br/>            self.row = 7<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           user_info_list = get_user_info()<br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:218: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_user_info():<br/>        &quot;&quot;&quot;<br/>        0. accountId<br/>        1. regionId<br/>        2. userName<br/>        3. userId<br/>        4. userRoleId<br/>        :return:<br/>        &quot;&quot;&quot;<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_main_user_info()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:610: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.E_Notification_Groups_Module_APi.test_notification_groups_api.Test_Notification_groups_api object at 0x00000247288B6C10&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Notification_Groups_Module_APi\test_notification_groups_api.py:53: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Notification_groups_Module_API.Notification_Groups_Methods.Notification_Groups_API_Methods object at 0x0000024718186210&gt;<br/><br/>    def verify_add_user_to_alert_group(self):<br/>        result = []<br/>        try:<br/>            self.row = 7<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            user_info_list = get_user_info()<br/>            post_response_list = create_notification_group_without_users_enrollment_group_zones()<br/>            print(post_response_list)<br/>            alert_id = post_response_list[2][&quot;data&quot;]<br/>            print(alert_id)<br/>            response_list = add_user_to_alert_group_request(alert_id)<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            print(&quot;response_list&quot;,response_list)<br/>            ex_update_msg = Read_Expected_Notification_Groups_Response_msg().user_added_to_notification_success_msg(user_info_list[3], alert_id)<br/>            ac_update_msg = response_list[2][&quot;result&quot;][&quot;message&quot;]<br/>            self.exp_msg = Read_Expected_Notification_Groups_Response_msg().user_added_to_notification_status_success_msg()<br/>            self.act_msg = response_list[2][&quot;result&quot;][&quot;status&quot;]<br/>    <br/>            if response_validation(self.response) and ex_update_msg == ac_update_msg and self.exp_msg == self.act_msg:<br/>                excel_result(self.row,&quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row,&quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row,&quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:251: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>Expecting value: line 1 column 1 (char 0)
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_notification_groups_api.py:51 test_Notification_Groups_Test_06  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/E_Notification_Groups_Module_APi/test_notification_groups_api.py::Test_Notification_groups_api::test_Notification_Groups_Test_07</td>
          <td class="col-duration">2.55</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Notification_groups_Module_API.Notification_Groups_Methods.Notification_Groups_API_Methods object at 0x0000024728D4FF90&gt;<br/><br/>    def verify_remove_user_from_alert_group(self):<br/>        result = []<br/>        try:<br/>            self.row = 8<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           user_info_list = get_user_info()<br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:262: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_user_info():<br/>        &quot;&quot;&quot;<br/>        0. accountId<br/>        1. regionId<br/>        2. userName<br/>        3. userId<br/>        4. userRoleId<br/>        :return:<br/>        &quot;&quot;&quot;<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_main_user_info()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:610: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.E_Notification_Groups_Module_APi.test_notification_groups_api.Test_Notification_groups_api object at 0x00000247288B5AD0&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Notification_Groups_Module_APi\test_notification_groups_api.py:61: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Notification_groups_Module_API.Notification_Groups_Methods.Notification_Groups_API_Methods object at 0x0000024728D4FF90&gt;<br/><br/>    def verify_remove_user_from_alert_group(self):<br/>        result = []<br/>        try:<br/>            self.row = 8<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            user_info_list = get_user_info()<br/>            post_response_list = create_notification_group_without_users_enrollment_group_zones()<br/>            print(post_response_list)<br/>            alert_id = post_response_list[2][&quot;data&quot;]<br/>            print(alert_id)<br/>            add_user_to_alert_group_request(alert_id)<br/>            response_list = remove_user_from_alert_group_request(alert_id)<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            print(&quot;response_list&quot;,response_list)<br/>            ex_update_msg = Read_Expected_Notification_Groups_Response_msg().user_removed_from_notification_success_msg(user_info_list[3], alert_id)<br/>            ac_update_msg = response_list[2][&quot;result&quot;][&quot;message&quot;]<br/>            self.exp_msg = Read_Expected_Notification_Groups_Response_msg().user_removed_from_notification_status_success_msg()<br/>            self.act_msg = response_list[2][&quot;result&quot;][&quot;status&quot;]<br/>    <br/>            if response_validation(self.response) and ex_update_msg == ac_update_msg and self.exp_msg == self.act_msg:<br/>                excel_result(self.row,&quot;Test_07&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row,&quot;Test_07&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row,&quot;Test_07&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:296: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>Expecting value: line 1 column 1 (char 0)
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_notification_groups_api.py:59 test_Notification_Groups_Test_07  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/E_Notification_Groups_Module_APi/test_notification_groups_api.py::Test_Notification_groups_api::test_Notification_Groups_Test_08</td>
          <td class="col-duration">2.53</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Notification_groups_Module_API.Notification_Groups_Methods.Notification_Groups_API_Methods object at 0x00000247293D7BD0&gt;<br/><br/>    def verify_delete_alert_group(self):<br/>        result = []<br/>        try:<br/>            self.row = 9<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           post_response_list = create_notification_group_without_users_enrollment_group_zones()<br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:307: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_notification_group_without_users_enrollment_group_zones():<br/>&gt;       user_info_list = get_user_info()<br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:477: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_user_info():<br/>        &quot;&quot;&quot;<br/>        0. accountId<br/>        1. regionId<br/>        2. userName<br/>        3. userId<br/>        4. userRoleId<br/>        :return:<br/>        &quot;&quot;&quot;<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_main_user_info()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:610: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.E_Notification_Groups_Module_APi.test_notification_groups_api.Test_Notification_groups_api object at 0x00000247288B5210&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Notification_Groups_Module_APi\test_notification_groups_api.py:69: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Notification_groups_Module_API.Notification_Groups_Methods.Notification_Groups_API_Methods object at 0x00000247293D7BD0&gt;<br/><br/>    def verify_delete_alert_group(self):<br/>        result = []<br/>        try:<br/>            self.row = 9<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            post_response_list = create_notification_group_without_users_enrollment_group_zones()<br/>            print(post_response_list)<br/>            alert_id = post_response_list[2][&quot;data&quot;]<br/>            print(alert_id)<br/>            get_response_list = get_notification_group_using_id(alert_id)<br/>            alert_name = get_response_list[1][&quot;agroupinfo&quot;][&quot;agroups&quot;][0][&quot;name&quot;]<br/>            response_list = get_delete_user_request(alert_id)<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            print(&quot;response_list&quot;,response_list)<br/>            self.exp_msg = Read_Expected_Notification_Groups_Response_msg().notification_delete_msg(alert_name,alert_id)<br/>            self.act_msg = self.json_response[&quot;message&quot;]<br/>    <br/>            if response_validation(self.response) and self.exp_msg == self.act_msg:<br/>                excel_result(self.row,&quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row,&quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row,&quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:338: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>Expecting value: line 1 column 1 (char 0)
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_notification_groups_api.py:67 test_Notification_Groups_Test_08  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/E_Notification_Groups_Module_APi/test_notification_groups_api.py::Test_Notification_groups_api::test_Notification_Groups_Test_09</td>
          <td class="col-duration">2.53</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Notification_groups_Module_API.Notification_Groups_Methods.Notification_Groups_API_Methods object at 0x00000247289F5B90&gt;<br/><br/>    def verify_notification_group_should_not_be_duplicate(self):<br/>        result = []<br/>        try:<br/>            self.row = 10<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           post_response_list = create_notification_group_without_users_enrollment_group_zones()<br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:349: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_notification_group_without_users_enrollment_group_zones():<br/>&gt;       user_info_list = get_user_info()<br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:477: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_user_info():<br/>        &quot;&quot;&quot;<br/>        0. accountId<br/>        1. regionId<br/>        2. userName<br/>        3. userId<br/>        4. userRoleId<br/>        :return:<br/>        &quot;&quot;&quot;<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_main_user_info()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:610: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.E_Notification_Groups_Module_APi.test_notification_groups_api.Test_Notification_groups_api object at 0x00000247288B45D0&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Notification_Groups_Module_APi\test_notification_groups_api.py:77: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Notification_groups_Module_API.Notification_Groups_Methods.Notification_Groups_API_Methods object at 0x00000247289F5B90&gt;<br/><br/>    def verify_notification_group_should_not_be_duplicate(self):<br/>        result = []<br/>        try:<br/>            self.row = 10<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            post_response_list = create_notification_group_without_users_enrollment_group_zones()<br/>            print(post_response_list)<br/>            alert_id = post_response_list[2][&quot;data&quot;]<br/>            print(alert_id)<br/>            alert_name = post_response_list[3]<br/>            post_duplicate_response_list = create_duplicate_notification_group(alert_name)<br/>            self.r_body = post_duplicate_response_list[0]<br/>            self.response = post_duplicate_response_list[1]<br/>            self.json_response = post_duplicate_response_list[2]<br/>            print(&quot;response_list&quot;,post_duplicate_response_list)<br/>    <br/>            if invalid_response_validation(self.response):<br/>                excel_result(self.row,&quot;Test_09&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row,&quot;Test_09&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row,&quot;Test_09&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:378: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>Expecting value: line 1 column 1 (char 0)
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_notification_groups_api.py:75 test_Notification_Groups_Test_09  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/E_Notification_Groups_Module_APi/test_notification_groups_api.py::Test_Notification_groups_api::test_Notification_Groups_Test_10</td>
          <td class="col-duration">2.57</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Notification_groups_Module_API.Notification_Groups_Methods.Notification_Groups_API_Methods object at 0x0000024728CECF10&gt;<br/><br/>    def verify_add_enrollment_group_to_notification_group(self):<br/>        result = []<br/>        try:<br/>            self.row = 11<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           enrollment_id = get_enrollment_group_id()<br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:389: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_enrollment_group_id():<br/>        &quot;&quot;&quot;<br/>        caseGroupIdsUserIds<br/>        :return: caseGroupIdsUserIds<br/>        &quot;&quot;&quot;<br/>        token = login_token()<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().post_case_group()}&quot;<br/>        data = create_case_groups_test_data(4)<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>        enrollment_name = f&quot;{data[0]}{random_number()}&quot;<br/>        request_body = {&quot;name&quot;: enrollment_name, &quot;description&quot;: data[1], &quot;faceThreshold&quot;: data[2], &quot;maskedFaceThreshold&quot;: data[3],<br/>                        &quot;eventsSuppressionInterval&quot;: data[4], &quot;priority&quot;: data[5], &quot;seriousOffender&quot;: data[6], &quot;alertHexColor&quot;: data[7], &quot;activeThreat&quot;: data[8]}<br/>        request_data = json.dumps(request_body)<br/>        response_str = requests.post(url, data=request_data, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:642: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.E_Notification_Groups_Module_APi.test_notification_groups_api.Test_Notification_groups_api object at 0x00000247288AF410&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Notification_Groups_Module_APi\test_notification_groups_api.py:85: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Notification_groups_Module_API.Notification_Groups_Methods.Notification_Groups_API_Methods object at 0x0000024728CECF10&gt;<br/><br/>    def verify_add_enrollment_group_to_notification_group(self):<br/>        result = []<br/>        try:<br/>            self.row = 11<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            enrollment_id = get_enrollment_group_id()<br/>            response_list = create_notification_group_without_users_enrollment_group_zones()<br/>            alert_id = response_list[2][&quot;data&quot;]<br/>            add_enrollment_resp_list = add_enrollment_to_alert_group_request(enrollment_id, alert_id)<br/>            self.r_body = add_enrollment_resp_list[0]<br/>            self.response = add_enrollment_resp_list[1]<br/>            self.json_response = add_enrollment_resp_list[2]<br/>            self.act_msg = self.json_response[&quot;result&quot;][&quot;status&quot;]<br/>            print(response_list)<br/>            if response_validation(self.response):<br/>                excel_result(self.row,&quot;Test_10&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_10&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row,&quot;Test_10&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Notification_groups_Module_API\Notification_Groups_Methods.py:416: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>Expecting value: line 1 column 1 (char 0)
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_notification_groups_api.py:83 test_Notification_Groups_Test_10  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/F_Account_Module_API/test_account_api.py::Test_Account_api::test_Account_Test_01</td>
          <td class="col-duration">2.48</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Account_Module_API.Account_API_Methods.Account_API_Methods object at 0x00000247290ACD50&gt;<br/><br/>    def verify_get_all_account(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = get_all_account()<br/><br/>All_API_Methods_Package\Account_Module_API\Account_API_Methods.py:24: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_all_account():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_all_account_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Account_Module_API\Account_API_Methods.py:131: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.F_Account_Module_API.test_account_api.Test_Account_api object at 0x00000247288AD690&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Account_Module_API\test_account_api.py:10: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Account_Module_API.Account_API_Methods.Account_API_Methods object at 0x00000247290ACD50&gt;<br/><br/>    def verify_get_all_account(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_all_account()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            print(response_list)<br/>            for x in range(len(self.json_response)):<br/>                result.append(self.json_response[x][&quot;accountId&quot;] != &quot;&quot;)<br/>    <br/>            if response_validation(self.response) and False not in result:<br/>                excel_result(self.row,&quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row,&quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row,&quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Account_Module_API\Account_API_Methods.py:49: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>Expecting value: line 1 column 1 (char 0)
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_account_api.py:9 test_Account_Test_01  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/F_Account_Module_API/test_account_api.py::Test_Account_api::test_Account_Test_02</td>
          <td class="col-duration">2.42</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Account_Module_API.Account_API_Methods.Account_API_Methods object at 0x0000024728DE1A10&gt;<br/><br/>    def verify_get_account_by_account_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           ex_account_id = get_all_account()[1][0][&quot;accountId&quot;]<br/><br/>All_API_Methods_Package\Account_Module_API\Account_API_Methods.py:60: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_all_account():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_all_account_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Account_Module_API\Account_API_Methods.py:131: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.F_Account_Module_API.test_account_api.Test_Account_api object at 0x00000247288AC050&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Account_Module_API\test_account_api.py:17: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Account_Module_API.Account_API_Methods.Account_API_Methods object at 0x0000024728DE1A10&gt;<br/><br/>    def verify_get_account_by_account_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            ex_account_id = get_all_account()[1][0][&quot;accountId&quot;]<br/>            response_list = get_single_account_by_account_id(ex_account_id)<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            ac_account_id = self.json_response[&quot;accountId&quot;]<br/>            print(response_list)<br/>            if response_validation(self.response) and ex_account_id == ac_account_id:<br/>                excel_result(self.row,&quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row,&quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row,&quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Account_Module_API\Account_API_Methods.py:84: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>Expecting value: line 1 column 1 (char 0)
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_account_api.py:16 test_Account_Test_02  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/F_Account_Module_API/test_account_api.py::Test_Account_api::test_Account_Test_03</td>
          <td class="col-duration">2.52</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Account_Module_API.Account_API_Methods.Account_API_Methods object at 0x0000024729151650&gt;<br/><br/>    def verify_account_stations_by_account_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           account_id = get_all_account()[1][0][&quot;accountId&quot;]<br/><br/>All_API_Methods_Package\Account_Module_API\Account_API_Methods.py:95: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_all_account():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_all_account_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Account_Module_API\Account_API_Methods.py:131: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.F_Account_Module_API.test_account_api.Test_Account_api object at 0x00000247288AC490&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Account_Module_API\test_account_api.py:24: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Account_Module_API.Account_API_Methods.Account_API_Methods object at 0x0000024729151650&gt;<br/><br/>    def verify_account_stations_by_account_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            account_id = get_all_account()[1][0][&quot;accountId&quot;]<br/>            print(&quot;account_id&quot;,account_id)<br/>            response_list = get_account_stations_by_account_id(account_id)<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            print(response_list)<br/>            if response_validation(self.response):<br/>                excel_result(self.row,&quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row,&quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row,&quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Account_Module_API\Account_API_Methods.py:119: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>Expecting value: line 1 column 1 (char 0)
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_account_api.py:23 test_Account_Test_03  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/G_Notes_Module_API/test_notes_api.py::Test_notes_api::test_notes_Test_01</td>
          <td class="col-duration">5.36</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x000002472934D310&gt;<br/><br/>    def verify_create_notes(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = create_notes_request()<br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:30: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_notes_request():<br/>        token = login_token()<br/>        image_path = f&quot;{Path(__file__).parent.parent.parent}\\API_Test_Data\\image.png&quot;<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_notes_endpoint()}&quot;<br/>        data = create_enrollment_data(2)<br/>        request_body = {&quot;gender&quot;: data[0], &quot;build&quot;: data[1], &quot;bodyMarkings&quot;: data[2], &quot;narrativeDesc&quot;: data[3],<br/>                        &quot;action&quot;: data[4], &quot;storeId&quot;: data[5], &quot;caseNumber&quot;: data[6],<br/>                        &quot;timeIncident&quot;: data[7], &quot;reportedBy&quot;: data[8], &quot;reportedLoss&quot;: data[9],<br/>                        &quot;caseEventType&quot;: data[10],<br/>                        &quot;activityType&quot;: data[11], &quot;heightType&quot;: data[12], &quot;methodOffence&quot;: data[13],<br/>&gt;                       &quot;ProfileId&quot;: get_profile_id(), &quot;ClearGeo&quot;: data[15], &quot;geo&quot;: data[16],<br/>                        }<br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:409: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_profile_id():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}api/Profiles&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:426: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.G_Notes_Module_API.test_notes_api.Test_notes_api object at 0x00000247288AC250&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Notes_Module_API\test_notes_api.py:10: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x000002472934D310&gt;<br/><br/>    def verify_create_notes(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = create_notes_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            note_id = self.json_response[&quot;data&quot;][&quot;id&quot;]<br/>            self.exp_msg = Read_notes_Response_msg().create_notes_success_msg(note_id)<br/>            self.act_msg = self.json_response[&quot;data&quot;][&quot;message&quot;]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:54: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_notes_api.py:9 test_notes_Test_01  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/G_Notes_Module_API/test_notes_api.py::Test_notes_api::test_notes_Test_02</td>
          <td class="col-duration">5.40</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x00000247289BBAD0&gt;<br/><br/>    def verify_get_notes_using_note_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           ex_note_id = create_notes_request()[2][&quot;data&quot;][&quot;id&quot;]<br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:65: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_notes_request():<br/>        token = login_token()<br/>        image_path = f&quot;{Path(__file__).parent.parent.parent}\\API_Test_Data\\image.png&quot;<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_notes_endpoint()}&quot;<br/>        data = create_enrollment_data(2)<br/>        request_body = {&quot;gender&quot;: data[0], &quot;build&quot;: data[1], &quot;bodyMarkings&quot;: data[2], &quot;narrativeDesc&quot;: data[3],<br/>                        &quot;action&quot;: data[4], &quot;storeId&quot;: data[5], &quot;caseNumber&quot;: data[6],<br/>                        &quot;timeIncident&quot;: data[7], &quot;reportedBy&quot;: data[8], &quot;reportedLoss&quot;: data[9],<br/>                        &quot;caseEventType&quot;: data[10],<br/>                        &quot;activityType&quot;: data[11], &quot;heightType&quot;: data[12], &quot;methodOffence&quot;: data[13],<br/>&gt;                       &quot;ProfileId&quot;: get_profile_id(), &quot;ClearGeo&quot;: data[15], &quot;geo&quot;: data[16],<br/>                        }<br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:409: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_profile_id():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}api/Profiles&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:426: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.G_Notes_Module_API.test_notes_api.Test_notes_api object at 0x00000247180D6F50&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Notes_Module_API\test_notes_api.py:17: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x00000247289BBAD0&gt;<br/><br/>    def verify_get_notes_using_note_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            ex_note_id = create_notes_request()[2][&quot;data&quot;][&quot;id&quot;]<br/>            response_list = get_notes_using_id(ex_note_id)<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            ac_notes_id = self.json_response[&quot;notesInfo&quot;][&quot;notes&quot;][0][&quot;noteID&quot;]<br/>            self.act_msg = ac_notes_id<br/>            if response_validation(self.response) and ex_note_id == ac_notes_id:<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:88: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_notes_api.py:16 test_notes_Test_02  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/G_Notes_Module_API/test_notes_api.py::Test_notes_api::test_notes_Test_03</td>
          <td class="col-duration">5.59</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x0000024728908ED0&gt;<br/><br/>    def verify_update_notes(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           note_id = create_notes_request()[2][&quot;data&quot;][&quot;id&quot;]<br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:99: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_notes_request():<br/>        token = login_token()<br/>        image_path = f&quot;{Path(__file__).parent.parent.parent}\\API_Test_Data\\image.png&quot;<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_notes_endpoint()}&quot;<br/>        data = create_enrollment_data(2)<br/>        request_body = {&quot;gender&quot;: data[0], &quot;build&quot;: data[1], &quot;bodyMarkings&quot;: data[2], &quot;narrativeDesc&quot;: data[3],<br/>                        &quot;action&quot;: data[4], &quot;storeId&quot;: data[5], &quot;caseNumber&quot;: data[6],<br/>                        &quot;timeIncident&quot;: data[7], &quot;reportedBy&quot;: data[8], &quot;reportedLoss&quot;: data[9],<br/>                        &quot;caseEventType&quot;: data[10],<br/>                        &quot;activityType&quot;: data[11], &quot;heightType&quot;: data[12], &quot;methodOffence&quot;: data[13],<br/>&gt;                       &quot;ProfileId&quot;: get_profile_id(), &quot;ClearGeo&quot;: data[15], &quot;geo&quot;: data[16],<br/>                        }<br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:409: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_profile_id():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}api/Profiles&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:426: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.G_Notes_Module_API.test_notes_api.Test_notes_api object at 0x00000247288A7F10&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Notes_Module_API\test_notes_api.py:24: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x0000024728908ED0&gt;<br/><br/>    def verify_update_notes(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            note_id = create_notes_request()[2][&quot;data&quot;][&quot;id&quot;]<br/>            response_list = edit_notes_request(note_id)<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.exp_msg = Read_notes_Response_msg().update_notes_success_msg()<br/>            self.act_msg = self.json_response[&quot;result&quot;][&quot;message&quot;]<br/>            if response_validation(self.response) and self.exp_msg == self.act_msg:<br/>                excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:123: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_notes_api.py:23 test_notes_Test_03  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/G_Notes_Module_API/test_notes_api.py::Test_notes_api::test_notes_Test_04</td>
          <td class="col-duration">5.15</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x00000247292DFB10&gt;<br/><br/>    def verify_delete_notes_using_note_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           note_id = create_notes_request()[2][&quot;data&quot;][&quot;id&quot;]<br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:134: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_notes_request():<br/>        token = login_token()<br/>        image_path = f&quot;{Path(__file__).parent.parent.parent}\\API_Test_Data\\image.png&quot;<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_notes_endpoint()}&quot;<br/>        data = create_enrollment_data(2)<br/>        request_body = {&quot;gender&quot;: data[0], &quot;build&quot;: data[1], &quot;bodyMarkings&quot;: data[2], &quot;narrativeDesc&quot;: data[3],<br/>                        &quot;action&quot;: data[4], &quot;storeId&quot;: data[5], &quot;caseNumber&quot;: data[6],<br/>                        &quot;timeIncident&quot;: data[7], &quot;reportedBy&quot;: data[8], &quot;reportedLoss&quot;: data[9],<br/>                        &quot;caseEventType&quot;: data[10],<br/>                        &quot;activityType&quot;: data[11], &quot;heightType&quot;: data[12], &quot;methodOffence&quot;: data[13],<br/>&gt;                       &quot;ProfileId&quot;: get_profile_id(), &quot;ClearGeo&quot;: data[15], &quot;geo&quot;: data[16],<br/>                        }<br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:409: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_profile_id():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}api/Profiles&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:426: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.G_Notes_Module_API.test_notes_api.Test_notes_api object at 0x00000247288A5110&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Notes_Module_API\test_notes_api.py:31: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x00000247292DFB10&gt;<br/><br/>    def verify_delete_notes_using_note_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            note_id = create_notes_request()[2][&quot;data&quot;][&quot;id&quot;]<br/>            response_list = delete_notes_request(note_id)<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            self.exp_msg = Read_notes_Response_msg().delete_notes_success_msg(note_id)<br/>            self.act_msg = self.json_response[&quot;message&quot;]<br/>            if response_validation(self.response) and self.exp_msg == self.act_msg:<br/>                excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:157: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_notes_api.py:30 test_notes_Test_04  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/G_Notes_Module_API/test_notes_api.py::Test_notes_api::test_notes_Test_05</td>
          <td class="col-duration">5.18</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x0000024728F79A90&gt;<br/><br/>    def verify_clear_notes(self):<br/>        result = []<br/>        try:<br/>            self.row = 6<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           note_id = create_notes_request()[2][&quot;data&quot;][&quot;id&quot;]<br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:168: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_notes_request():<br/>        token = login_token()<br/>        image_path = f&quot;{Path(__file__).parent.parent.parent}\\API_Test_Data\\image.png&quot;<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_notes_endpoint()}&quot;<br/>        data = create_enrollment_data(2)<br/>        request_body = {&quot;gender&quot;: data[0], &quot;build&quot;: data[1], &quot;bodyMarkings&quot;: data[2], &quot;narrativeDesc&quot;: data[3],<br/>                        &quot;action&quot;: data[4], &quot;storeId&quot;: data[5], &quot;caseNumber&quot;: data[6],<br/>                        &quot;timeIncident&quot;: data[7], &quot;reportedBy&quot;: data[8], &quot;reportedLoss&quot;: data[9],<br/>                        &quot;caseEventType&quot;: data[10],<br/>                        &quot;activityType&quot;: data[11], &quot;heightType&quot;: data[12], &quot;methodOffence&quot;: data[13],<br/>&gt;                       &quot;ProfileId&quot;: get_profile_id(), &quot;ClearGeo&quot;: data[15], &quot;geo&quot;: data[16],<br/>                        }<br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:409: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_profile_id():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}api/Profiles&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:426: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.G_Notes_Module_API.test_notes_api.Test_notes_api object at 0x00000247288A7FD0&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Notes_Module_API\test_notes_api.py:38: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x0000024728F79A90&gt;<br/><br/>    def verify_clear_notes(self):<br/>        result = []<br/>        try:<br/>            self.row = 6<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            note_id = create_notes_request()[2][&quot;data&quot;][&quot;id&quot;]<br/>            response_list = clear_notes_request(note_id)<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.exp_msg = Read_notes_Response_msg().clear_notes_success_msg()<br/>            self.act_msg = self.json_response[&quot;result&quot;][&quot;message&quot;]<br/>            if response_validation(self.response) and self.exp_msg == self.act_msg:<br/>                excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:192: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_notes_api.py:37 test_notes_Test_05  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/G_Notes_Module_API/test_notes_api.py::Test_notes_api::test_notes_Test_06</td>
          <td class="col-duration">8.58</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x0000024728E0E1D0&gt;<br/><br/>    def verify_add_image_to_note_using_note_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 7<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           note_id = create_notes_request()[2][&quot;data&quot;][&quot;id&quot;]<br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:203: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_notes_request():<br/>        token = login_token()<br/>        image_path = f&quot;{Path(__file__).parent.parent.parent}\\API_Test_Data\\image.png&quot;<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_notes_endpoint()}&quot;<br/>        data = create_enrollment_data(2)<br/>        request_body = {&quot;gender&quot;: data[0], &quot;build&quot;: data[1], &quot;bodyMarkings&quot;: data[2], &quot;narrativeDesc&quot;: data[3],<br/>                        &quot;action&quot;: data[4], &quot;storeId&quot;: data[5], &quot;caseNumber&quot;: data[6],<br/>                        &quot;timeIncident&quot;: data[7], &quot;reportedBy&quot;: data[8], &quot;reportedLoss&quot;: data[9],<br/>                        &quot;caseEventType&quot;: data[10],<br/>                        &quot;activityType&quot;: data[11], &quot;heightType&quot;: data[12], &quot;methodOffence&quot;: data[13],<br/>&gt;                       &quot;ProfileId&quot;: get_profile_id(), &quot;ClearGeo&quot;: data[15], &quot;geo&quot;: data[16],<br/>                        }<br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:409: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_profile_id():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}api/Profiles&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:426: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.G_Notes_Module_API.test_notes_api.Test_notes_api object at 0x00000247288A71D0&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Notes_Module_API\test_notes_api.py:45: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x0000024728E0E1D0&gt;<br/><br/>    def verify_add_image_to_note_using_note_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 7<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            note_id = create_notes_request()[2][&quot;data&quot;][&quot;id&quot;]<br/>            response_list = add_image_request(note_id)<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.exp_msg = Read_notes_Response_msg().add_image_to_notes_success_msg()<br/>            self.act_msg = self.json_response[&quot;result&quot;][&quot;status&quot;]<br/>            if response_validation(self.response) and self.exp_msg == self.act_msg:<br/>                excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:227: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_notes_api.py:44 test_notes_Test_06  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/G_Notes_Module_API/test_notes_api.py::Test_notes_api::test_notes_Test_07</td>
          <td class="col-duration">6.26</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x0000024728D861D0&gt;<br/><br/>    def verify_get_image_using_note_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 8<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           note_id = create_notes_request()[2][&quot;data&quot;][&quot;id&quot;]<br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:238: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_notes_request():<br/>        token = login_token()<br/>        image_path = f&quot;{Path(__file__).parent.parent.parent}\\API_Test_Data\\image.png&quot;<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_notes_endpoint()}&quot;<br/>        data = create_enrollment_data(2)<br/>        request_body = {&quot;gender&quot;: data[0], &quot;build&quot;: data[1], &quot;bodyMarkings&quot;: data[2], &quot;narrativeDesc&quot;: data[3],<br/>                        &quot;action&quot;: data[4], &quot;storeId&quot;: data[5], &quot;caseNumber&quot;: data[6],<br/>                        &quot;timeIncident&quot;: data[7], &quot;reportedBy&quot;: data[8], &quot;reportedLoss&quot;: data[9],<br/>                        &quot;caseEventType&quot;: data[10],<br/>                        &quot;activityType&quot;: data[11], &quot;heightType&quot;: data[12], &quot;methodOffence&quot;: data[13],<br/>&gt;                       &quot;ProfileId&quot;: get_profile_id(), &quot;ClearGeo&quot;: data[15], &quot;geo&quot;: data[16],<br/>                        }<br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:409: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_profile_id():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}api/Profiles&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:426: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.G_Notes_Module_API.test_notes_api.Test_notes_api object at 0x00000247288A6110&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Notes_Module_API\test_notes_api.py:52: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x0000024728D861D0&gt;<br/><br/>    def verify_get_image_using_note_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 8<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            note_id = create_notes_request()[2][&quot;data&quot;][&quot;id&quot;]<br/>            self.response = get_image_using_note_id(note_id)<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_07&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_07&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_07&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:257: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_notes_api.py:51 test_notes_Test_07  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/G_Notes_Module_API/test_notes_api.py::Test_notes_api::test_notes_Test_08</td>
          <td class="col-duration">5.20</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x00000247290ACFD0&gt;<br/><br/>    def verify_delete_image_using_note_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 9<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           note_id = create_notes_request()[2][&quot;data&quot;][&quot;id&quot;]<br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:268: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_notes_request():<br/>        token = login_token()<br/>        image_path = f&quot;{Path(__file__).parent.parent.parent}\\API_Test_Data\\image.png&quot;<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_notes_endpoint()}&quot;<br/>        data = create_enrollment_data(2)<br/>        request_body = {&quot;gender&quot;: data[0], &quot;build&quot;: data[1], &quot;bodyMarkings&quot;: data[2], &quot;narrativeDesc&quot;: data[3],<br/>                        &quot;action&quot;: data[4], &quot;storeId&quot;: data[5], &quot;caseNumber&quot;: data[6],<br/>                        &quot;timeIncident&quot;: data[7], &quot;reportedBy&quot;: data[8], &quot;reportedLoss&quot;: data[9],<br/>                        &quot;caseEventType&quot;: data[10],<br/>                        &quot;activityType&quot;: data[11], &quot;heightType&quot;: data[12], &quot;methodOffence&quot;: data[13],<br/>&gt;                       &quot;ProfileId&quot;: get_profile_id(), &quot;ClearGeo&quot;: data[15], &quot;geo&quot;: data[16],<br/>                        }<br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:409: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_profile_id():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}api/Profiles&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:426: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.G_Notes_Module_API.test_notes_api.Test_notes_api object at 0x00000247288A5950&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Notes_Module_API\test_notes_api.py:59: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x00000247290ACFD0&gt;<br/><br/>    def verify_delete_image_using_note_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 9<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            note_id = create_notes_request()[2][&quot;data&quot;][&quot;id&quot;]<br/>            image_id = get_notes_using_id(note_id)[1][&quot;notesInfo&quot;][&quot;notes&quot;][0][&quot;imageIDs&quot;][0]<br/>            response_list = delete_image_request(note_id, image_id)<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.exp_msg = Read_notes_Response_msg().delete_image_to_notes_success_msg(note_id)<br/>            self.act_msg = self.json_response[&quot;message&quot;]<br/>            if response_validation(self.response) and self.exp_msg == self.act_msg:<br/>                excel_result(self.row, &quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:293: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_notes_api.py:58 test_notes_Test_08  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/G_Notes_Module_API/test_notes_api.py::Test_notes_api::test_notes_Test_09</td>
          <td class="col-duration">5.62</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x0000024729068290&gt;<br/><br/>    def verify_notes_search(self):<br/>        result = []<br/>        try:<br/>            self.row = 10<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           create_notes_request()<br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:304: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_notes_request():<br/>        token = login_token()<br/>        image_path = f&quot;{Path(__file__).parent.parent.parent}\\API_Test_Data\\image.png&quot;<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_notes_endpoint()}&quot;<br/>        data = create_enrollment_data(2)<br/>        request_body = {&quot;gender&quot;: data[0], &quot;build&quot;: data[1], &quot;bodyMarkings&quot;: data[2], &quot;narrativeDesc&quot;: data[3],<br/>                        &quot;action&quot;: data[4], &quot;storeId&quot;: data[5], &quot;caseNumber&quot;: data[6],<br/>                        &quot;timeIncident&quot;: data[7], &quot;reportedBy&quot;: data[8], &quot;reportedLoss&quot;: data[9],<br/>                        &quot;caseEventType&quot;: data[10],<br/>                        &quot;activityType&quot;: data[11], &quot;heightType&quot;: data[12], &quot;methodOffence&quot;: data[13],<br/>&gt;                       &quot;ProfileId&quot;: get_profile_id(), &quot;ClearGeo&quot;: data[15], &quot;geo&quot;: data[16],<br/>                        }<br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:409: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_profile_id():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}api/Profiles&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:426: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.G_Notes_Module_API.test_notes_api.Test_notes_api object at 0x00000247288A5910&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Notes_Module_API\test_notes_api.py:66: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x0000024729068290&gt;<br/><br/>    def verify_notes_search(self):<br/>        result = []<br/>        try:<br/>            self.row = 10<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            create_notes_request()<br/>            response_list = notes_search_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_09&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_09&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_09&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:326: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_notes_api.py:65 test_notes_Test_09  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/G_Notes_Module_API/test_notes_api.py::Test_notes_api::test_notes_Test_10</td>
          <td class="col-duration">5.34</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x0000024728A96710&gt;<br/><br/>    def verify_notes_aggregates_by_geospatial(self):<br/>        result = []<br/>        try:<br/>            self.row = 11<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           create_notes_request()<br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_notes_request():<br/>        token = login_token()<br/>        image_path = f&quot;{Path(__file__).parent.parent.parent}\\API_Test_Data\\image.png&quot;<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_notes_endpoint()}&quot;<br/>        data = create_enrollment_data(2)<br/>        request_body = {&quot;gender&quot;: data[0], &quot;build&quot;: data[1], &quot;bodyMarkings&quot;: data[2], &quot;narrativeDesc&quot;: data[3],<br/>                        &quot;action&quot;: data[4], &quot;storeId&quot;: data[5], &quot;caseNumber&quot;: data[6],<br/>                        &quot;timeIncident&quot;: data[7], &quot;reportedBy&quot;: data[8], &quot;reportedLoss&quot;: data[9],<br/>                        &quot;caseEventType&quot;: data[10],<br/>                        &quot;activityType&quot;: data[11], &quot;heightType&quot;: data[12], &quot;methodOffence&quot;: data[13],<br/>&gt;                       &quot;ProfileId&quot;: get_profile_id(), &quot;ClearGeo&quot;: data[15], &quot;geo&quot;: data[16],<br/>                        }<br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:409: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_profile_id():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}api/Profiles&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:426: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.G_Notes_Module_API.test_notes_api.Test_notes_api object at 0x00000247288A4310&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Notes_Module_API\test_notes_api.py:73: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x0000024728A96710&gt;<br/><br/>    def verify_notes_aggregates_by_geospatial(self):<br/>        result = []<br/>        try:<br/>            self.row = 11<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            create_notes_request()<br/>            response_list = aggregates_by_geospatial_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_10&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_10&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_10&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:359: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_notes_api.py:72 test_notes_Test_10  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/G_Notes_Module_API/test_notes_api.py::Test_notes_api::test_notes_Test_11</td>
          <td class="col-duration">8.86</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x0000024728B3B190&gt;<br/><br/>    def verify_get_by_enrollment(self):<br/>        result = []<br/>        try:<br/>            self.row = 12<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           case_id = create_notes_to_a_person_request()[3]<br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:370: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_notes_to_a_person_request():<br/>&gt;       case_id = create_enrollment_request()[3]<br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:618: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_enrollment_request():<br/>        token = login_token()<br/>        image_path = f&quot;{Path(__file__).parent.parent.parent}\\API_Test_Data\\image.png&quot;<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_enrollment_endpoint()}&quot;<br/>        data = create_enrollment_data(2)<br/>&gt;       request_body = {&quot;CgroupId&quot;: get_C_group_Id(), &quot;OptOut&quot;: data[1], &quot;Basis&quot;: data[2], &quot;Action&quot;: data[3],<br/>                        &quot;ActivityType&quot;: data[4], &quot;BodyMarkings&quot;: data[5], &quot;Build&quot;: data[6],<br/>                        &quot;CaseEventType&quot;: data[7], &quot;CaseNumber&quot;: data[8], &quot;Enabled&quot;: data[9], &quot;Gender&quot;: data[10],<br/>                        &quot;HeightType&quot;: data[11], &quot;MethodOffence&quot;: data[12], &quot;NarrativeDesc&quot;: data[13],<br/>                        &quot;ProfileId&quot;: get_profile_id(), &quot;ReportedBy&quot;: data[15], &quot;ReportedLoss&quot;: data[16],<br/>                        &quot;StoreId&quot;: data[17], &quot;TimeIncident&quot;: data[18], &quot;RegionId&quot;: select_region()}<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:455: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_C_group_Id():<br/>&gt;       data = create_enrollment_group_with_addCaseGroupZone_request()<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:698: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_enrollment_group_with_addCaseGroupZone_request():<br/>        token = login_token()<br/>&gt;       data = create_enrollment_group_request(3)<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:463: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 3<br/><br/>    def create_enrollment_group_request(row_no):<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>        data = create_enrollment_group_test_data(row_no)<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_enrollment_group_endpoint()}&quot;<br/>        name = f&quot;{data[0]}{random_number()}&quot;<br/>        request_body = {&quot;name&quot;: name, &quot;description&quot;: data[1], &quot;faceThreshold&quot;: data[2], &quot;maskedFaceThreshold&quot;: data[3],<br/>                        &quot;eventsSuppressionInterval&quot;: data[4], &quot;priority&quot;: data[5], &quot;seriousOffender&quot;: data[6],<br/>                        &quot;alertHexColor&quot;: data[7], &quot;activeThreat&quot;: data[8]}<br/>        request_data = json.dumps(request_body)<br/>        response_str = requests.post(url, data=request_data, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:455: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.G_Notes_Module_API.test_notes_api.Test_notes_api object at 0x00000247288A7910&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Notes_Module_API\test_notes_api.py:80: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Notes_Module_API.Notes_API_methods.Notes_API_Methods object at 0x0000024728B3B190&gt;<br/><br/>    def verify_get_by_enrollment(self):<br/>        result = []<br/>        try:<br/>            self.row = 12<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            case_id = create_notes_to_a_person_request()[3]<br/>            response_list = get_by_enrollment_request(case_id)<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_11&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_11&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_11&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Notes_Module_API\Notes_API_methods.py:392: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_notes_api.py:79 test_notes_Test_11  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/H_Zones_Module_API/test_zones_api.py::Test_Zones_api::test_Zones_Test_01</td>
          <td class="col-duration">2.48</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Zones_Module_API.Zones_API_Methods.Zones_API_Methods object at 0x0000024729119810&gt;<br/><br/>    def verify_get_all_zones(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = get_all_zones()<br/><br/>All_API_Methods_Package\Zones_Module_API\Zones_API_Methods.py:24: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_all_zones():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_all_zones_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Zones_Module_API\Zones_API_Methods.py:100: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.H_Zones_Module_API.test_zones_api.Test_Zones_api object at 0x0000024728898E10&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Zones_Module_API\test_zones_api.py:10: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Zones_Module_API.Zones_API_Methods.Zones_API_Methods object at 0x0000024729119810&gt;<br/><br/>    def verify_get_all_zones(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_all_zones()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            print(response_list)<br/>            for x in range(len(self.json_response[&quot;zoneInfo&quot;][&quot;zones&quot;])):<br/>                result.append(self.json_response[&quot;zoneInfo&quot;][&quot;zones&quot;][x][&quot;zoneId&quot;] != &quot;&quot;)<br/>    <br/>            if response_validation(self.response) and False not in result:<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Zones_Module_API\Zones_API_Methods.py:51: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>Expecting value: line 1 column 1 (char 0)
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_zones_api.py:9 test_Zones_Test_01  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/H_Zones_Module_API/test_zones_api.py::Test_Zones_api::test_Zones_Test_02</td>
          <td class="col-duration">2.48</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Zones_Module_API.Zones_API_Methods.Zones_API_Methods object at 0x000002472946ADD0&gt;<br/><br/>    def verify_get_zone_by_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           ex_zone_id = get_all_zones()[1][&quot;zoneInfo&quot;][&quot;zones&quot;][0][&quot;zoneId&quot;]<br/><br/>All_API_Methods_Package\Zones_Module_API\Zones_API_Methods.py:62: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_all_zones():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_all_zones_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Zones_Module_API\Zones_API_Methods.py:100: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.H_Zones_Module_API.test_zones_api.Test_Zones_api object at 0x000002472889B450&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Zones_Module_API\test_zones_api.py:17: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Zones_Module_API.Zones_API_Methods.Zones_API_Methods object at 0x000002472946ADD0&gt;<br/><br/>    def verify_get_zone_by_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            ex_zone_id = get_all_zones()[1][&quot;zoneInfo&quot;][&quot;zones&quot;][0][&quot;zoneId&quot;]<br/>            response_list = get_single_zone_by_id(ex_zone_id)<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            ac_zones_id = self.json_response[&quot;zoneInfo&quot;][&quot;zones&quot;][0][&quot;zoneId&quot;]<br/>            print(response_list)<br/>            if response_validation(self.response) and ex_zone_id == ac_zones_id:<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Zones_Module_API\Zones_API_Methods.py:88: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>Expecting value: line 1 column 1 (char 0)
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_zones_api.py:16 test_Zones_Test_01  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/I_Region_Module_API/test_region_api.py::Test_region_api::test_tags_Test_01</td>
          <td class="col-duration">3.72</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x0000024728A22D10&gt;<br/><br/>    def verify_get_region_by_account_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = get_region_request_by_account_id()<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:33: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_region_request_by_account_id():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        # region_id = select_region()<br/>&gt;       account_id = get_user_request()<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:438: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_user_request():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_users_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:267: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.I_Region_Module_API.test_region_api.Test_region_api object at 0x0000024728887E10&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Region_Module_API\test_region_api.py:10: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x0000024728A22D10&gt;<br/><br/>    def verify_get_region_by_account_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_region_request_by_account_id()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:55: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_region_api.py:9 test_region_Test_01  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/I_Region_Module_API/test_region_api.py::Test_region_api::test_tags_Test_02</td>
          <td class="col-duration">5.13</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x0000024729409A90&gt;<br/><br/>    def verify_get_region_by_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = get_request_by_region_id()<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:66: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_request_by_region_id():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>&gt;       region_id = get_region_request_by_account_id()<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:450: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_region_request_by_account_id():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        # region_id = select_region()<br/>&gt;       account_id = get_user_request()<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:438: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_user_request():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_users_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:267: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.I_Region_Module_API.test_region_api.Test_region_api object at 0x0000024728885650&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Region_Module_API\test_region_api.py:17: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x0000024729409A90&gt;<br/><br/>    def verify_get_region_by_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_request_by_region_id()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:88: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_region_api.py:16 test_region_Test_02  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/I_Region_Module_API/test_region_api.py::Test_region_api::test_tags_Test_03</td>
          <td class="col-duration">5.09</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x0000024728E7D850&gt;<br/><br/>    def verify_get_region_by_region_path(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = get_region_by_region_path()<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:99: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_region_by_region_path():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>&gt;       region_id = get_region_request_by_account_id()<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:471: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_region_request_by_account_id():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        # region_id = select_region()<br/>&gt;       account_id = get_user_request()<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:438: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_user_request():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_users_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:267: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.I_Region_Module_API.test_region_api.Test_region_api object at 0x0000024728887110&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Region_Module_API\test_region_api.py:24: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x0000024728E7D850&gt;<br/><br/>    def verify_get_region_by_region_path(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_region_by_region_path()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:121: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_region_api.py:23 test_region_Test_03  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/I_Region_Module_API/test_region_api.py::Test_region_api::test_tags_Test_04</td>
          <td class="col-duration">5.92</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x0000024728DEE9D0&gt;<br/><br/>    def verify_get_region_by_descendants(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = get_request_region_by_descendants()<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:132: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_request_region_by_descendants():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>&gt;       region_id = get_region_request_by_account_id()<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:482: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_region_request_by_account_id():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        # region_id = select_region()<br/>&gt;       account_id = get_user_request()<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:438: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_user_request():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_users_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:267: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.I_Region_Module_API.test_region_api.Test_region_api object at 0x0000024728886A50&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Region_Module_API\test_region_api.py:31: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x0000024728DEE9D0&gt;<br/><br/>    def verify_get_region_by_descendants(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_request_region_by_descendants()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:154: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_region_api.py:30 test_region_Test_04  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/I_Region_Module_API/test_region_api.py::Test_region_api::test_tags_Test_05</td>
          <td class="col-duration">3.80</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x0000024728DE2DD0&gt;<br/><br/>    def verify_create_regions_migrate_events(self):<br/>        result = []<br/>        try:<br/>            self.row = 6<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = get_create_regions_migrate_events()<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:165: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_create_regions_migrate_events():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>&gt;       zone_id = get_all_zones()<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:524: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_all_zones():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_all_zones_endpoint()}&quot;<br/>        query_params = {&quot;offset&quot;: 0}<br/>        response_str = requests.get(url, params=query_params, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:540: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.I_Region_Module_API.test_region_api.Test_region_api object at 0x00000247288AEC50&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Region_Module_API\test_region_api.py:38: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x0000024728DE2DD0&gt;<br/><br/>    def verify_create_regions_migrate_events(self):<br/>        result = []<br/>        try:<br/>            self.row = 6<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_create_regions_migrate_events()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:187: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_region_api.py:37 test_region_Test_05  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/I_Region_Module_API/test_region_api.py::Test_region_api::test_tags_Test_06</td>
          <td class="col-duration">6.35</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x00000247293AC2D0&gt;<br/><br/>    def verify_get_regions_by_cameras(self):<br/>        result = []<br/>        try:<br/>            self.row = 7<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = get_regions_by_cameras()<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:198: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_regions_by_cameras():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>&gt;       region_id = get_request_region_by_descendants()<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:513: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_request_region_by_descendants():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>&gt;       region_id = get_region_request_by_account_id()<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:482: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_region_request_by_account_id():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        # region_id = select_region()<br/>&gt;       account_id = get_user_request()<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:438: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_user_request():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_users_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:267: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.I_Region_Module_API.test_region_api.Test_region_api object at 0x00000247288865D0&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Region_Module_API\test_region_api.py:45: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x00000247293AC2D0&gt;<br/><br/>    def verify_get_regions_by_cameras(self):<br/>        result = []<br/>        try:<br/>            self.row = 7<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_regions_by_cameras()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:220: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_region_api.py:44 test_region_Test_06  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/I_Region_Module_API/test_region_api.py::Test_region_api::test_tags_Test_07</td>
          <td class="col-duration">6.38</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x0000024729289950&gt;<br/><br/>    def verify_update_region_by_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 8<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = get_request_update_region_by_id()<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:231: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_request_update_region_by_id():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>&gt;       request_id = get_request_region_by_descendants()<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:499: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_request_region_by_descendants():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>&gt;       region_id = get_region_request_by_account_id()<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:482: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_region_request_by_account_id():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        # region_id = select_region()<br/>&gt;       account_id = get_user_request()<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:438: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_user_request():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_users_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:267: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.I_Region_Module_API.test_region_api.Test_region_api object at 0x0000024728886010&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Region_Module_API\test_region_api.py:52: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x0000024729289950&gt;<br/><br/>    def verify_update_region_by_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 8<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_request_update_region_by_id()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            region_id = response_list[3]<br/>            self.exp_msg = Read_Expected_Region_Response_msg().update_success_msg(region_id)<br/>            self.act_msg = self.json_response[&quot;message&quot;]<br/>            if response_validation(self.response) and self.exp_msg == self.act_msg:<br/>                excel_result(self.row, &quot;Test_07&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_07&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_07&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:255: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_region_api.py:51 test_region_Test_07  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/I_Region_Module_API/test_region_api.py::Test_region_api::test_tags_Test_08</td>
          <td class="col-duration">2.43</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x0000024728EFE990&gt;<br/><br/>    def verify_regions_import(self):<br/>        result = []<br/>        try:<br/>            self.row = 9<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = get_regions_import()<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:266: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_regions_import():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        file_path = f&quot;{Path(__file__).parent.parent.parent}\\API_Test_Data\\Dmart.json&quot;<br/>        with open(file_path, &#x27;r&#x27;) as json_file:<br/>            json_data = json.load(json_file)<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_region_import_file()}&quot;<br/>        form_data = {&#x27;File&#x27;: (&#x27;json_file.json&#x27;, json.dumps(json_data), &#x27;application/json&#x27;)}<br/>        response_str = requests.post(url, files=form_data, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:555: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.I_Region_Module_API.test_region_api.Test_region_api object at 0x00000247288840D0&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Region_Module_API\test_region_api.py:59: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x0000024728EFE990&gt;<br/><br/>    def verify_regions_import(self):<br/>        result = []<br/>        try:<br/>            self.row = 9<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_regions_import()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response) or invalid_response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:286: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_region_api.py:58 test_region_Test_08  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/I_Region_Module_API/test_region_api.py::Test_region_api::test_tags_Test_09</td>
          <td class="col-duration">8.22</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x000002472910ADD0&gt;<br/><br/>    def varify_create_regions_by_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 10<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = create_request_regions()<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:297: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_request_regions():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_region_id_endpoint()}&quot;<br/>        data = region_module_test_module(2)<br/>        code = f&quot;{data[1]}{random_number()}&quot;<br/>&gt;       parent_id = get_request_region_by_descendants()<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:565: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_request_region_by_descendants():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>&gt;       region_id = get_region_request_by_account_id()<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:482: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_region_request_by_account_id():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        # region_id = select_region()<br/>&gt;       account_id = get_user_request()<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:438: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_user_request():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_users_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:267: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.I_Region_Module_API.test_region_api.Test_region_api object at 0x0000024728884B50&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Region_Module_API\test_region_api.py:66: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x000002472910ADD0&gt;<br/><br/>    def varify_create_regions_by_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 10<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = create_request_regions()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            self.r_body = response_list[2]<br/>            region_id = response_list[3]<br/>            self.act_msg = self.json_response[&quot;message&quot;]<br/>            self.exp_msg = Read_Expected_Region_Response_msg().create_success_msg(region_id)<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_09&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_09&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_09&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:321: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_region_api.py:65 test_region_Test_09  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/I_Region_Module_API/test_region_api.py::Test_region_api::test_tags_Test_10</td>
          <td class="col-duration">6.50</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x0000024729186C10&gt;<br/><br/>    def varify_create_regions_by_id_descendants(self):<br/>        result = []<br/>        try:<br/>            self.row = 11<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = create_request_regions_by_descendants()<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:332: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_request_regions_by_descendants():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>&gt;       response_ids = get_request_region_by_descendants()<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:583: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_request_region_by_descendants():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>&gt;       region_id = get_region_request_by_account_id()<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:482: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_region_request_by_account_id():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        # region_id = select_region()<br/>&gt;       account_id = get_user_request()<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:438: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_user_request():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_users_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:267: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.I_Region_Module_API.test_region_api.Test_region_api object at 0x0000024728885350&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Region_Module_API\test_region_api.py:73: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x0000024729186C10&gt;<br/><br/>    def varify_create_regions_by_id_descendants(self):<br/>        result = []<br/>        try:<br/>            self.row = 11<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = create_request_regions_by_descendants()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            self.r_body = response_list[2]<br/>            region_id = response_list[3]<br/>            self.act_msg = self.json_response[&quot;message&quot;]<br/>            self.exp_msg = Read_Expected_Region_Response_msg().create_success_msg(region_id)<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_10&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_10&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_10&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:356: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_region_api.py:72 test_region_Test_10  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/I_Region_Module_API/test_region_api.py::Test_region_api::test_tags_Test_11</td>
          <td class="col-duration">7.76</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x000002472886BD10&gt;<br/><br/>    def varify_create_regions_by_move(self):<br/>        result = []<br/>        try:<br/>            self.row = 12<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = create_request_regions_by_move()<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:367: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_request_regions_by_move():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>&gt;       source_id = create_request_regions_by_descendants()[3]<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:605: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_request_regions_by_descendants():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>&gt;       response_ids = get_request_region_by_descendants()<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:583: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_request_region_by_descendants():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>&gt;       region_id = get_region_request_by_account_id()<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:482: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_region_request_by_account_id():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        # region_id = select_region()<br/>&gt;       account_id = get_user_request()<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:438: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_user_request():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_users_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:267: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.I_Region_Module_API.test_region_api.Test_region_api object at 0x0000024728880910&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Region_Module_API\test_region_api.py:80: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x000002472886BD10&gt;<br/><br/>    def varify_create_regions_by_move(self):<br/>        result = []<br/>        try:<br/>            self.row = 12<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = create_request_regions_by_move()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            self.r_body = response_list[2]<br/>            region_id = response_list[3]<br/>            self.act_msg = self.json_response[&quot;message&quot;]<br/>            self.exp_msg = Read_Expected_Region_Response_msg().update_success_msg(region_id)<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_11&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_11&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_11&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:391: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_region_api.py:79 test_region_Test_11  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/I_Region_Module_API/test_region_api.py::Test_region_api::test_tags_Test_12</td>
          <td class="col-duration">7.75</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x00000247291F9390&gt;<br/><br/>    def varify_delete_regions(self):<br/>        result = []<br/>        try:<br/>            self.row = 13<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = delete_region_request()<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:402: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def delete_region_request():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>&gt;       region_id = create_request_regions_by_descendants()[3]<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:624: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_request_regions_by_descendants():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>&gt;       response_ids = get_request_region_by_descendants()<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:583: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_request_region_by_descendants():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>&gt;       region_id = get_region_request_by_account_id()<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:482: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_region_request_by_account_id():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        # region_id = select_region()<br/>&gt;       account_id = get_user_request()<br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:438: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_user_request():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_users_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:267: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.I_Region_Module_API.test_region_api.Test_region_api object at 0x0000024728883E90&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Region_Module_API\test_region_api.py:87: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Region_Module_API.Region_methods.Region_API_Methods object at 0x00000247291F9390&gt;<br/><br/>    def varify_delete_regions(self):<br/>        result = []<br/>        try:<br/>            self.row = 13<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = delete_region_request()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            region_id = response_list[2]<br/>            self.act_msg = self.json_response[&quot;message&quot;]<br/>            self.exp_msg = Read_Expected_Region_Response_msg().delete_success_msg(region_id)<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_12&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_12&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_12&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Region_Module_API\Region_methods.py:425: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_region_api.py:86 test_region_Test_12  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/J_Tags_Module_API/test_tags_api.py::Test_tags_api::test_tags_Test_01</td>
          <td class="col-duration">2.71</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Tags_Module_API.Tags_API_Methods.Tags_API_Methods object at 0x0000024728FC2DD0&gt;<br/><br/>    def verify_create_tags_with_valid_data(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = create_tags_request(self.row)<br/><br/>All_API_Methods_Package\Tags_Module_API\Tags_API_Methods.py:28: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 2<br/><br/>    def create_tags_request(row_no):<br/>        token = login_token()<br/>        print(token)<br/>        data = tags_test_data(row_no)<br/>        tag_name = f&quot;{data[0]}{random_number()}&quot;<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_tags_endpoint(tag_name, data[1], data[2])}&quot;<br/>    <br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>        # request_data = {&quot;name&quot;: tag_name, &quot;seriousEvent&quot;: data[1], &quot;type&quot;: data[2]}<br/>        # request_data = json.dumps(request_data)<br/>        response_str = requests.post(url, headers=headers)<br/>        # print(request_data)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Tags_Module_API\Tags_API_Methods.py:205: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.J_Tags_Module_API.test_tags_api.Test_tags_api object at 0x0000024728881450&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Tags_Module_API\test_tags_api.py:10: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Tags_Module_API.Tags_API_Methods.Tags_API_Methods object at 0x0000024728FC2DD0&gt;<br/><br/>    def verify_create_tags_with_valid_data(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = create_tags_request(self.row)<br/>    <br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>    <br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Tags_Module_API\Tags_API_Methods.py:50: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_tags_api.py:9 test_tags_Test_01  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/J_Tags_Module_API/test_tags_api.py::Test_tags_api::test_tags_Test_02</td>
          <td class="col-duration">2.50</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Tags_Module_API.Tags_API_Methods.Tags_API_Methods object at 0x000002472934F7D0&gt;<br/><br/>    def verify_all_get_tag_data(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = get_all_tags()<br/><br/>All_API_Methods_Package\Tags_Module_API\Tags_API_Methods.py:61: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_all_tags():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        print(headers)<br/>        # data = create_tags_request(2)<br/>        # role_id_exp = data[4]<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_tags_endpoint()}&quot;<br/>        print(url)<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Tags_Module_API\Tags_API_Methods.py:240: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.J_Tags_Module_API.test_tags_api.Test_tags_api object at 0x0000024728880390&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Tags_Module_API\test_tags_api.py:17: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Tags_Module_API.Tags_API_Methods.Tags_API_Methods object at 0x000002472934F7D0&gt;<br/><br/>    def verify_all_get_tag_data(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_all_tags()<br/>            print(response_list)<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>    <br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Tags_Module_API\Tags_API_Methods.py:83: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>{&#x27;Authorization&#x27;: &#x27;Token &#x27;}
https://ff-india-qa10.eastus2.cloudapp.azure.com/api/Tags
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_tags_api.py:16 test_tags_Test_02  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/J_Tags_Module_API/test_tags_api.py::Test_tags_api::test_tags_Test_03</td>
          <td class="col-duration">2.77</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Tags_Module_API.Tags_API_Methods.Tags_API_Methods object at 0x000002472906D8D0&gt;<br/><br/>    def verify_update_tag_with_valid_data(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = update_tags_request()<br/><br/>All_API_Methods_Package\Tags_Module_API\Tags_API_Methods.py:94: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def update_tags_request():<br/>&gt;       tag_name = create_tags_request(2)[2]<br/><br/>All_API_Methods_Package\Tags_Module_API\Tags_API_Methods.py:212: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 2<br/><br/>    def create_tags_request(row_no):<br/>        token = login_token()<br/>        print(token)<br/>        data = tags_test_data(row_no)<br/>        tag_name = f&quot;{data[0]}{random_number()}&quot;<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_tags_endpoint(tag_name, data[1], data[2])}&quot;<br/>    <br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>        # request_data = {&quot;name&quot;: tag_name, &quot;seriousEvent&quot;: data[1], &quot;type&quot;: data[2]}<br/>        # request_data = json.dumps(request_data)<br/>        response_str = requests.post(url, headers=headers)<br/>        # print(request_data)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Tags_Module_API\Tags_API_Methods.py:205: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.J_Tags_Module_API.test_tags_api.Test_tags_api object at 0x0000024728878350&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Tags_Module_API\test_tags_api.py:24: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Tags_Module_API.Tags_API_Methods.Tags_API_Methods object at 0x000002472906D8D0&gt;<br/><br/>    def verify_update_tag_with_valid_data(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = update_tags_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>    <br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Tags_Module_API\Tags_API_Methods.py:116: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_tags_api.py:23 test_tags_Test_03  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/J_Tags_Module_API/test_tags_api.py::Test_tags_api::test_tags_Test_04</td>
          <td class="col-duration">4.11</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Tags_Module_API.Tags_API_Methods.Tags_API_Methods object at 0x00000247288F9B50&gt;<br/><br/>    def verify_delete_tags_with_valid_tag_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = del_tags_by_id_request()<br/><br/>All_API_Methods_Package\Tags_Module_API\Tags_API_Methods.py:127: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def del_tags_by_id_request():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>&gt;       response_list = get_tags_by_id()<br/><br/>All_API_Methods_Package\Tags_Module_API\Tags_API_Methods.py:276: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_tags_by_id():<br/>&gt;       create_tags_request(2)<br/><br/>All_API_Methods_Package\Tags_Module_API\Tags_API_Methods.py:249: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 2<br/><br/>    def create_tags_request(row_no):<br/>        token = login_token()<br/>        print(token)<br/>        data = tags_test_data(row_no)<br/>        tag_name = f&quot;{data[0]}{random_number()}&quot;<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_tags_endpoint(tag_name, data[1], data[2])}&quot;<br/>    <br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>        # request_data = {&quot;name&quot;: tag_name, &quot;seriousEvent&quot;: data[1], &quot;type&quot;: data[2]}<br/>        # request_data = json.dumps(request_data)<br/>        response_str = requests.post(url, headers=headers)<br/>        # print(request_data)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Tags_Module_API\Tags_API_Methods.py:205: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.J_Tags_Module_API.test_tags_api.Test_tags_api object at 0x000002472887B490&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Tags_Module_API\test_tags_api.py:31: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Tags_Module_API.Tags_API_Methods.Tags_API_Methods object at 0x00000247288F9B50&gt;<br/><br/>    def verify_delete_tags_with_valid_tag_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = del_tags_by_id_request()<br/>            print(response_list)<br/>            self.response = response_list[0]<br/>            print(self.response)<br/>            self.json_response = response_list[1]<br/>            # self.act_msg = response_list[2]<br/>            # self.exp_msg = response_list[3]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Tags_Module_API\Tags_API_Methods.py:151: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_tags_api.py:30 test_tags_Test_04  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/J_Tags_Module_API/test_tags_api.py::Test_tags_api::test_tags_Test_05</td>
          <td class="col-duration">2.69</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Tags_Module_API.Tags_API_Methods.Tags_API_Methods object at 0x00000247292A7B50&gt;<br/><br/>    def verify_create_tag_with_tag_alert(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = create_tags_request(self.row)<br/><br/>All_API_Methods_Package\Tags_Module_API\Tags_API_Methods.py:162: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 2<br/><br/>    def create_tags_request(row_no):<br/>        token = login_token()<br/>        print(token)<br/>        data = tags_test_data(row_no)<br/>        tag_name = f&quot;{data[0]}{random_number()}&quot;<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_tags_endpoint(tag_name, data[1], data[2])}&quot;<br/>    <br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>        # request_data = {&quot;name&quot;: tag_name, &quot;seriousEvent&quot;: data[1], &quot;type&quot;: data[2]}<br/>        # request_data = json.dumps(request_data)<br/>        response_str = requests.post(url, headers=headers)<br/>        # print(request_data)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Tags_Module_API\Tags_API_Methods.py:205: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.J_Tags_Module_API.test_tags_api.Test_tags_api object at 0x000002472887A350&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Tags_Module_API\test_tags_api.py:38: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Tags_Module_API.Tags_API_Methods.Tags_API_Methods object at 0x00000247292A7B50&gt;<br/><br/>    def verify_create_tag_with_tag_alert(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = create_tags_request(self.row)<br/>    <br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>    <br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;Test_05&quot;, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Tags_Module_API\Tags_API_Methods.py:184: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_tags_api.py:37 test_tags_Test_05  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/K_Visitors_Search_Module_API/test_visitors_search_api.py::Test_visitors_search_api::test_Visitors_Test_01</td>
          <td class="col-duration">4.13</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x0000024728F2CA90&gt;<br/><br/>    def verify_post_start_search(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = start_search_request()<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:29: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def start_search_request():<br/>        test_data_row = 2<br/>        token = login_token()<br/>        image_path = f&quot;{Path(__file__).parent.parent.parent}\\API_Test_Data\\Visitor.png&quot;<br/>        data = start_search_test_data(test_data_row)<br/>        start_search = f&quot;{data[0]}&quot;<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().start_search_endpoint()}&quot;<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>&gt;       request_data = {&quot;regionId&quot;: get_region_id()}<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:462: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_region_id():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_all_zones_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       return response_str.json()[&quot;zoneInfo&quot;][&quot;zones&quot;][1][&quot;regionId&quot;]<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:516: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.K_Visitors_Search_Module_API.test_visitors_search_api.Test_visitors_search_api object at 0x0000024728880B10&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Visitors_Search_Module_API\test_visitors_search_api.py:10: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x0000024728F2CA90&gt;<br/><br/>    def verify_post_start_search(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = start_search_request()<br/>    <br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>    <br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:52: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>Expecting value: line 1 column 1 (char 0)
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_visitors_search_api.py:9 test_visitor_search_Test_01  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/K_Visitors_Search_Module_API/test_visitors_search_api.py::Test_visitors_search_api::test_Visitors_Test_02</td>
          <td class="col-duration">4.14</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x0000024728B961D0&gt;<br/><br/>    def verify_get_fed_search_status(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           job_id = start_search_request()[3]<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:63: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def start_search_request():<br/>        test_data_row = 2<br/>        token = login_token()<br/>        image_path = f&quot;{Path(__file__).parent.parent.parent}\\API_Test_Data\\Visitor.png&quot;<br/>        data = start_search_test_data(test_data_row)<br/>        start_search = f&quot;{data[0]}&quot;<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().start_search_endpoint()}&quot;<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>&gt;       request_data = {&quot;regionId&quot;: get_region_id()}<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:462: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_region_id():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_all_zones_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       return response_str.json()[&quot;zoneInfo&quot;][&quot;zones&quot;][1][&quot;regionId&quot;]<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:516: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.K_Visitors_Search_Module_API.test_visitors_search_api.Test_visitors_search_api object at 0x0000024728882E10&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Visitors_Search_Module_API\test_visitors_search_api.py:17: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x0000024728B961D0&gt;<br/><br/>    def verify_get_fed_search_status(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            job_id = start_search_request()[3]<br/>            response_list = fed_search_status_request(job_id)<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:85: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>Expecting value: line 1 column 1 (char 0)
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_visitors_search_api.py:16 test_visitor_search_Test_02  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/K_Visitors_Search_Module_API/test_visitors_search_api.py::Test_visitors_search_api::test_Visitors_Test_03</td>
          <td class="col-duration">4.15</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x0000024728B8F2D0&gt;<br/><br/>    def verify_get_visitor_image_by_image_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           job_id = start_search_request()[3]<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:96: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def start_search_request():<br/>        test_data_row = 2<br/>        token = login_token()<br/>        image_path = f&quot;{Path(__file__).parent.parent.parent}\\API_Test_Data\\Visitor.png&quot;<br/>        data = start_search_test_data(test_data_row)<br/>        start_search = f&quot;{data[0]}&quot;<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().start_search_endpoint()}&quot;<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>&gt;       request_data = {&quot;regionId&quot;: get_region_id()}<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:462: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_region_id():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_all_zones_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       return response_str.json()[&quot;zoneInfo&quot;][&quot;zones&quot;][1][&quot;regionId&quot;]<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:516: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.K_Visitors_Search_Module_API.test_visitors_search_api.Test_visitors_search_api object at 0x00000247288862D0&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Visitors_Search_Module_API\test_visitors_search_api.py:24: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x0000024728B8F2D0&gt;<br/><br/>    def verify_get_visitor_image_by_image_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            job_id = start_search_request()[3]<br/>            image_id = fed_search_status_request(job_id)[1][&quot;matched&quot;][0][&quot;id&quot;]<br/>            response_list = get_visitor_image_by_image_id(image_id)<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;,<br/>                                                                              self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;,<br/>                                                                              self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                         self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:121: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>Expecting value: line 1 column 1 (char 0)
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_visitors_search_api.py:23 test_visitor_search_Test_03  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/K_Visitors_Search_Module_API/test_visitors_search_api.py::Test_visitors_search_api::test_Visitors_Test_04</td>
          <td class="col-duration">2.89</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x0000024729555D90&gt;<br/><br/>    def verify_identify_alien_federated(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = identify_alien_federated_request()<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:133: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def identify_alien_federated_request():<br/>        test_data_row = 4<br/>        token = login_token()<br/>        image_path = f&quot;{Path(__file__).parent.parent.parent}\\API_Test_Data\\Visitor.png&quot;<br/>        data = identify_alien_federated_test_data(test_data_row)<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().post_identify_alien_federated()}&quot;<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        request_data = {&quot;EndAge&quot;: data[0], &quot;MaxMatches&quot;: data[1], &quot;StartAge&quot;: data[2], &quot;IncludeMatrics&quot;: data[3]}<br/>        files = [<br/>            (&#x27;Images&#x27;, (&#x27;image.png&#x27;, open(image_path, &#x27;rb&#x27;), &#x27;image/png&#x27;))<br/>        ]<br/>        response_str = requests.post(url, headers=headers, data=request_data, files=files)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:531: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.K_Visitors_Search_Module_API.test_visitors_search_api.Test_visitors_search_api object at 0x000002472886A8D0&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Visitors_Search_Module_API\test_visitors_search_api.py:31: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x0000024729555D90&gt;<br/><br/>    def verify_identify_alien_federated(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = identify_alien_federated_request()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;,<br/>                                                                              self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;,<br/>                                                                              self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                         self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:156: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>Expecting value: line 1 column 1 (char 0)
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_visitors_search_api.py:30 test_visitor_search_Test_04  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/K_Visitors_Search_Module_API/test_visitors_search_api.py::Test_visitors_search_api::test_Visitors_Test_05</td>
          <td class="col-duration">4.64</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x0000024728D36110&gt;<br/><br/>    def verify_identify_delete_federated(self):<br/>        result = []<br/>        try:<br/>            self.row = 6<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           job_id = start_search_request()[3]<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:168: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def start_search_request():<br/>        test_data_row = 2<br/>        token = login_token()<br/>        image_path = f&quot;{Path(__file__).parent.parent.parent}\\API_Test_Data\\Visitor.png&quot;<br/>        data = start_search_test_data(test_data_row)<br/>        start_search = f&quot;{data[0]}&quot;<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().start_search_endpoint()}&quot;<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>&gt;       request_data = {&quot;regionId&quot;: get_region_id()}<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:462: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_region_id():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_all_zones_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       return response_str.json()[&quot;zoneInfo&quot;][&quot;zones&quot;][1][&quot;regionId&quot;]<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:516: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.K_Visitors_Search_Module_API.test_visitors_search_api.Test_visitors_search_api object at 0x000002472890C3D0&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Visitors_Search_Module_API\test_visitors_search_api.py:38: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x0000024728D36110&gt;<br/><br/>    def verify_identify_delete_federated(self):<br/>        result = []<br/>        try:<br/>            self.row = 6<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            job_id = start_search_request()[3]<br/>            response_list = delete_alien_federated_request(job_id)<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;,<br/>                                                                              self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;,<br/>                                                                              self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                         self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:192: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>Expecting value: line 1 column 1 (char 0)
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_visitors_search_api.py:37 test_visitor_search_Test_05  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/K_Visitors_Search_Module_API/test_visitors_search_api.py::Test_visitors_search_api::test_Visitors_Test_06</td>
          <td class="col-duration">5.22</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x00000247291A7B50&gt;<br/><br/>    def verify_get_alien_image(self):<br/>        result = []<br/>        try:<br/>            self.row = 7<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           job_id = start_search_request()[3]<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:204: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def start_search_request():<br/>        test_data_row = 2<br/>        token = login_token()<br/>        image_path = f&quot;{Path(__file__).parent.parent.parent}\\API_Test_Data\\Visitor.png&quot;<br/>        data = start_search_test_data(test_data_row)<br/>        start_search = f&quot;{data[0]}&quot;<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().start_search_endpoint()}&quot;<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>&gt;       request_data = {&quot;regionId&quot;: get_region_id()}<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:462: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_region_id():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_all_zones_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       return response_str.json()[&quot;zoneInfo&quot;][&quot;zones&quot;][1][&quot;regionId&quot;]<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:516: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.K_Visitors_Search_Module_API.test_visitors_search_api.Test_visitors_search_api object at 0x000002472890D690&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Visitors_Search_Module_API\test_visitors_search_api.py:45: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x00000247291A7B50&gt;<br/><br/>    def verify_get_alien_image(self):<br/>        result = []<br/>        try:<br/>            self.row = 7<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            job_id = start_search_request()[3]<br/>            image_id = fed_search_status_request(job_id)[1][&quot;matched&quot;][0][&quot;id&quot;]<br/>            response_list = get_alien_image_by_image_id(image_id)<br/>            self.response = response_list<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;,<br/>                                                                              self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;,<br/>                                                                              self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                         self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:228: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>Expecting value: line 1 column 1 (char 0)
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_visitors_search_api.py:44 test_visitor_search_Test_06  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/K_Visitors_Search_Module_API/test_visitors_search_api.py::Test_visitors_search_api::test_Visitors_Test_07</td>
          <td class="col-duration">4.30</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x0000024728879D90&gt;<br/><br/>    def verify_identify_alien_federated_status(self):<br/>        result = []<br/>        try:<br/>            self.row = 8<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           job_id = start_search_request()[3]<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:240: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def start_search_request():<br/>        test_data_row = 2<br/>        token = login_token()<br/>        image_path = f&quot;{Path(__file__).parent.parent.parent}\\API_Test_Data\\Visitor.png&quot;<br/>        data = start_search_test_data(test_data_row)<br/>        start_search = f&quot;{data[0]}&quot;<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().start_search_endpoint()}&quot;<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>&gt;       request_data = {&quot;regionId&quot;: get_region_id()}<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:462: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_region_id():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_all_zones_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       return response_str.json()[&quot;zoneInfo&quot;][&quot;zones&quot;][1][&quot;regionId&quot;]<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:516: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.K_Visitors_Search_Module_API.test_visitors_search_api.Test_visitors_search_api object at 0x000002472890EC10&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Visitors_Search_Module_API\test_visitors_search_api.py:52: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x0000024728879D90&gt;<br/><br/>    def verify_identify_alien_federated_status(self):<br/>        result = []<br/>        try:<br/>            self.row = 8<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            job_id = start_search_request()[3]<br/>            response_list = get_identify_alien_federated_status(job_id)<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_07&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;,<br/>                                                                              self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_07&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;,<br/>                                                                              self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_07&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                         self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:264: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>Expecting value: line 1 column 1 (char 0)
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_visitors_search_api.py:51 test_visitor_search_Test_07  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/K_Visitors_Search_Module_API/test_visitors_search_api.py::Test_visitors_search_api::test_Visitors_Test_08</td>
          <td class="col-duration">4.24</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x0000024728C0A290&gt;<br/><br/>    def verify_query_alien_face_info(self):<br/>        result = []<br/>        try:<br/>            self.row = 9<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           job_id = start_search_request()[3]<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:276: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def start_search_request():<br/>        test_data_row = 2<br/>        token = login_token()<br/>        image_path = f&quot;{Path(__file__).parent.parent.parent}\\API_Test_Data\\Visitor.png&quot;<br/>        data = start_search_test_data(test_data_row)<br/>        start_search = f&quot;{data[0]}&quot;<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().start_search_endpoint()}&quot;<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>&gt;       request_data = {&quot;regionId&quot;: get_region_id()}<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:462: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_region_id():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_all_zones_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       return response_str.json()[&quot;zoneInfo&quot;][&quot;zones&quot;][1][&quot;regionId&quot;]<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:516: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.K_Visitors_Search_Module_API.test_visitors_search_api.Test_visitors_search_api object at 0x000002472890F2D0&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Visitors_Search_Module_API\test_visitors_search_api.py:59: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x0000024728C0A290&gt;<br/><br/>    def verify_query_alien_face_info(self):<br/>        result = []<br/>        try:<br/>            self.row = 9<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            job_id = start_search_request()[3]<br/>            image_id = fed_search_status_request(job_id)[1][&quot;matched&quot;][0][&quot;id&quot;]<br/>            response_list = get_query_alien_face_info(image_id)<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;,<br/>                                                                              self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;,<br/>                                                                              self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                         self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:301: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>Expecting value: line 1 column 1 (char 0)
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_visitors_search_api.py:58 test_visitor_search_Test_08  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/K_Visitors_Search_Module_API/test_visitors_search_api.py::Test_visitors_search_api::test_Visitors_Test_09</td>
          <td class="col-duration">4.10</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x00000247288FADD0&gt;<br/><br/>    def verify_identify_cancel_federated(self):<br/>        result = []<br/>        try:<br/>            self.row = 10<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = identify_cancel_federated_request()<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:313: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def identify_cancel_federated_request():<br/>        test_data_row = 2<br/>        token = login_token()<br/>        image_path = f&quot;{Path(__file__).parent.parent.parent}\\API_Test_Data\\img2.png&quot;<br/>        data = start_search_test_data(test_data_row)<br/>        start_search = f&quot;{data[0]}&quot;<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().start_search_endpoint()}&quot;<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>&gt;       request_data = {&quot;regionId&quot;: get_region_id()}<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:597: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_region_id():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_all_zones_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       return response_str.json()[&quot;zoneInfo&quot;][&quot;zones&quot;][1][&quot;regionId&quot;]<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:516: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.K_Visitors_Search_Module_API.test_visitors_search_api.Test_visitors_search_api object at 0x000002472890F990&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Visitors_Search_Module_API\test_visitors_search_api.py:66: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x00000247288FADD0&gt;<br/><br/>    def verify_identify_cancel_federated(self):<br/>        result = []<br/>        try:<br/>            self.row = 10<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = identify_cancel_federated_request()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            print(self.json_response)<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_09&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;,<br/>                                                                              self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_09&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;,<br/>                                                                              self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_09&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                         self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:337: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>Expecting value: line 1 column 1 (char 0)
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_visitors_search_api.py:65 test_visitor_search_Test_09  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/K_Visitors_Search_Module_API/test_visitors_search_api.py::Test_visitors_search_api::test_Visitors_Test_10</td>
          <td class="col-duration">2.48</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x0000024728FA0850&gt;<br/><br/>    def verify_query_alien_federated_identification_log(self):<br/>        result = []<br/>        try:<br/>            self.row = 11<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = get_query_alien_federated_identification_log()<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:349: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_query_alien_federated_identification_log():<br/>        token = login_token()<br/>        result_deleted = False<br/>        count = 20<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_query_alien_federated_identification_log_endpoint(result_deleted, count)}&quot;<br/>        print(url)<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:619: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.K_Visitors_Search_Module_API.test_visitors_search_api.Test_visitors_search_api object at 0x000002472898C050&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Visitors_Search_Module_API\test_visitors_search_api.py:73: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x0000024728FA0850&gt;<br/><br/>    def verify_query_alien_federated_identification_log(self):<br/>        result = []<br/>        try:<br/>            self.row = 11<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_query_alien_federated_identification_log()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            print(self.json_response)<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_10&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;,<br/>                                                                              self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_10&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;,<br/>                                                                              self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_10&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                         self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:373: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>https://ff-india-qa10.eastus2.cloudapp.azure.com/api/Visitors/queryAlienFederatedIdentificationLog?ResultsDeleted=False&amp;count=20
Expecting value: line 1 column 1 (char 0)
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_visitors_search_api.py:72 test_visitor_search_Test_10  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/K_Visitors_Search_Module_API/test_visitors_search_api.py::Test_visitors_search_api::test_Visitors_Test_11</td>
          <td class="col-duration">2.85</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x00000247290FC510&gt;<br/><br/>    def verify_visitor_search(self):<br/>        result = []<br/>        try:<br/>            self.row = 12<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = visitor_search_request()<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:385: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def visitor_search_request():<br/>        test_data_row = 6<br/>        token = login_token()<br/>        data = start_search_test_data(test_data_row)<br/>        start = data[0]<br/>        limit = data[1]<br/>        sort_direction = data[2]<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().post_visitor_search_endpoint(start, limit, sort_direction)}&quot;<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>        request_body = {&quot;startTime&quot;: data[3]}<br/>        request_data = json.dumps(request_body)<br/>        response_str = requests.post(url, headers=headers, data=request_data)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:636: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.K_Visitors_Search_Module_API.test_visitors_search_api.Test_visitors_search_api object at 0x000002472898C710&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Visitors_Search_Module_API\test_visitors_search_api.py:80: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x00000247290FC510&gt;<br/><br/>    def verify_visitor_search(self):<br/>        result = []<br/>        try:<br/>            self.row = 12<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = visitor_search_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            print(self.json_response)<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_11&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;,<br/>                                                                              self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_11&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;,<br/>                                                                              self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_11&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                         self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:410: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>Expecting value: line 1 column 1 (char 0)
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_visitors_search_api.py:79 test_visitor_search_Test_11  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/K_Visitors_Search_Module_API/test_visitors_search_api.py::Test_visitors_search_api::test_Visitors_Test_12</td>
          <td class="col-duration">3.66</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x00000247294EEE90&gt;<br/><br/>    def verify_visitor_count_by_zone(self):<br/>        result = []<br/>        try:<br/>            self.row = 13<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = get_verify_visitor_count_by_zone()<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:422: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_verify_visitor_count_by_zone():<br/>        test_data_row = 8<br/>        token = login_token()<br/>        data = verify_visitor_count_by_zone_test_data(test_data_row)<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_visitor_count_by_zone_endpoint()}&quot;<br/>        print(url)<br/>        query_param = {&quot;AgeBucket&quot;: data[0], &quot;Male&quot;: data[1], &quot;Female&quot;: data[2], &quot;White&quot;: data[3], &quot;Black&quot;: data[4],<br/>                       &quot;Asian&quot;: data[5], &quot;Indian&quot;: data[6], &quot;Other&quot; : data[7], &quot;UnknownEthnicity&quot;: data[8],<br/>                       &quot;StartAge&quot;: data[9], &quot;EndAge&quot;: data[10], &quot;Ascending&quot;: data[11], &quot;Count&quot;: data[12]<br/>                       }<br/>        response_str = requests.get(url, headers=headers, params=query_param)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:661: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.K_Visitors_Search_Module_API.test_visitors_search_api.Test_visitors_search_api object at 0x000002472898CDD0&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Visitors_Search_Module_API\test_visitors_search_api.py:87: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Visitors_Search_Module_API.Visitors_Search_Methods.Visitors_Search_API_Methods object at 0x00000247294EEE90&gt;<br/><br/>    def verify_visitor_count_by_zone(self):<br/>        result = []<br/>        try:<br/>            self.row = 13<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_verify_visitor_count_by_zone()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            print(self.json_response)<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_12&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;,<br/>                                                                              self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_12&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;,<br/>                                                                              self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_12&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                         self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Visitors_Search_Module_API\Visitors_Search_Methods.py:446: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>https://ff-india-qa10.eastus2.cloudapp.azure.com/api/Visitors/counts/ByZone
Expecting value: line 1 column 1 (char 0)
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_visitors_search_api.py:86 test_visitor_search_Test_12  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/L_Identify_and_Enroll_Module_API/test_identify_enroll_api.py::Test_identify_enroll_api::test_identify_enroll_Test_01</td>
          <td class="col-duration">7.72</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x00000247292DADD0&gt;<br/><br/>    def verify_create_enrollment(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = create_enrollment_request()<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:34: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_enrollment_request():<br/>        token = login_token()<br/>        image_path = f&quot;{Path(__file__).parent.parent.parent}\\API_Test_Data\\image.png&quot;<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_enrollment_endpoint()}&quot;<br/>        data = create_enrollment_data(2)<br/>&gt;       request_body = {&quot;CgroupId&quot;: get_C_group_Id(), &quot;OptOut&quot;: data[1], &quot;Basis&quot;: data[2], &quot;Action&quot;: data[3],<br/>                        &quot;ActivityType&quot;: data[4], &quot;BodyMarkings&quot;: data[5], &quot;Build&quot;: data[6],<br/>                        &quot;CaseEventType&quot;: data[7], &quot;CaseNumber&quot;: data[8], &quot;Enabled&quot;: data[9], &quot;Gender&quot;: data[10],<br/>                        &quot;HeightType&quot;: data[11], &quot;MethodOffence&quot;: data[12], &quot;NarrativeDesc&quot;: data[13],<br/>                        &quot;ProfileId&quot;: get_profile_id(), &quot;ReportedBy&quot;: data[15], &quot;ReportedLoss&quot;: data[16],<br/>                        &quot;StoreId&quot;: data[17], &quot;TimeIncident&quot;: data[18], &quot;RegionId&quot;: select_region()}<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:455: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_C_group_Id():<br/>&gt;       data = create_enrollment_group_with_addCaseGroupZone_request()<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:698: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_enrollment_group_with_addCaseGroupZone_request():<br/>        token = login_token()<br/>&gt;       data = create_enrollment_group_request(3)<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:463: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 3<br/><br/>    def create_enrollment_group_request(row_no):<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>        data = create_enrollment_group_test_data(row_no)<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_enrollment_group_endpoint()}&quot;<br/>        name = f&quot;{data[0]}{random_number()}&quot;<br/>        request_body = {&quot;name&quot;: name, &quot;description&quot;: data[1], &quot;faceThreshold&quot;: data[2], &quot;maskedFaceThreshold&quot;: data[3],<br/>                        &quot;eventsSuppressionInterval&quot;: data[4], &quot;priority&quot;: data[5], &quot;seriousOffender&quot;: data[6],<br/>                        &quot;alertHexColor&quot;: data[7], &quot;activeThreat&quot;: data[8]}<br/>        request_data = json.dumps(request_body)<br/>        response_str = requests.post(url, data=request_data, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:455: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.L_Identify_and_Enroll_Module_API.test_identify_enroll_api.Test_identify_enroll_api object at 0x000002472898EE50&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Identify_and_Enroll_Module_API\test_identify_enroll_api.py:14: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x00000247292DADD0&gt;<br/><br/>    def verify_create_enrollment(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = create_enrollment_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            self.act_msg = self.json_response[&quot;enroll&quot;][&quot;success&quot;]<br/>            self.exp_msg = Read_identify_enroll_Response_msg().create_enrollment_success_msg();<br/>            if response_validation(self.response) and self:<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:57: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_identify_enroll_api.py:13 test_identify_enroll_Test_01  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/L_Identify_and_Enroll_Module_API/test_identify_enroll_api.py::Test_identify_enroll_api::test_identify_enroll_Test_02</td>
          <td class="col-duration">8.13</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000024728DA3C90&gt;<br/><br/>    def verify_clear_enrollment_info(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = clear_enrollment_info_request()<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:68: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def clear_enrollment_info_request():<br/>&gt;       data = create_enrollment_request()<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:569: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_enrollment_request():<br/>        token = login_token()<br/>        image_path = f&quot;{Path(__file__).parent.parent.parent}\\API_Test_Data\\image.png&quot;<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_enrollment_endpoint()}&quot;<br/>        data = create_enrollment_data(2)<br/>&gt;       request_body = {&quot;CgroupId&quot;: get_C_group_Id(), &quot;OptOut&quot;: data[1], &quot;Basis&quot;: data[2], &quot;Action&quot;: data[3],<br/>                        &quot;ActivityType&quot;: data[4], &quot;BodyMarkings&quot;: data[5], &quot;Build&quot;: data[6],<br/>                        &quot;CaseEventType&quot;: data[7], &quot;CaseNumber&quot;: data[8], &quot;Enabled&quot;: data[9], &quot;Gender&quot;: data[10],<br/>                        &quot;HeightType&quot;: data[11], &quot;MethodOffence&quot;: data[12], &quot;NarrativeDesc&quot;: data[13],<br/>                        &quot;ProfileId&quot;: get_profile_id(), &quot;ReportedBy&quot;: data[15], &quot;ReportedLoss&quot;: data[16],<br/>                        &quot;StoreId&quot;: data[17], &quot;TimeIncident&quot;: data[18], &quot;RegionId&quot;: select_region()}<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:455: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_C_group_Id():<br/>&gt;       data = create_enrollment_group_with_addCaseGroupZone_request()<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:698: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_enrollment_group_with_addCaseGroupZone_request():<br/>        token = login_token()<br/>&gt;       data = create_enrollment_group_request(3)<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:463: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 3<br/><br/>    def create_enrollment_group_request(row_no):<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>        data = create_enrollment_group_test_data(row_no)<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_enrollment_group_endpoint()}&quot;<br/>        name = f&quot;{data[0]}{random_number()}&quot;<br/>        request_body = {&quot;name&quot;: name, &quot;description&quot;: data[1], &quot;faceThreshold&quot;: data[2], &quot;maskedFaceThreshold&quot;: data[3],<br/>                        &quot;eventsSuppressionInterval&quot;: data[4], &quot;priority&quot;: data[5], &quot;seriousOffender&quot;: data[6],<br/>                        &quot;alertHexColor&quot;: data[7], &quot;activeThreat&quot;: data[8]}<br/>        request_data = json.dumps(request_body)<br/>        response_str = requests.post(url, data=request_data, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:455: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.L_Identify_and_Enroll_Module_API.test_identify_enroll_api.Test_identify_enroll_api object at 0x000002472898F4D0&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Identify_and_Enroll_Module_API\test_identify_enroll_api.py:22: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000024728DA3C90&gt;<br/><br/>    def verify_clear_enrollment_info(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = clear_enrollment_info_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:89: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_identify_enroll_api.py:21 test_identify_enroll_Test_02  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/L_Identify_and_Enroll_Module_API/test_identify_enroll_api.py::Test_identify_enroll_api::test_identify_enroll_Test_03</td>
          <td class="col-duration">7.92</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000024728F0C610&gt;<br/><br/>    def verify_query_Enrollment_FaceInfo(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = query_Enrollment_FaceInfo_request()<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:100: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def query_Enrollment_FaceInfo_request():<br/>&gt;       data = create_enrollment_request()<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:600: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_enrollment_request():<br/>        token = login_token()<br/>        image_path = f&quot;{Path(__file__).parent.parent.parent}\\API_Test_Data\\image.png&quot;<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_enrollment_endpoint()}&quot;<br/>        data = create_enrollment_data(2)<br/>&gt;       request_body = {&quot;CgroupId&quot;: get_C_group_Id(), &quot;OptOut&quot;: data[1], &quot;Basis&quot;: data[2], &quot;Action&quot;: data[3],<br/>                        &quot;ActivityType&quot;: data[4], &quot;BodyMarkings&quot;: data[5], &quot;Build&quot;: data[6],<br/>                        &quot;CaseEventType&quot;: data[7], &quot;CaseNumber&quot;: data[8], &quot;Enabled&quot;: data[9], &quot;Gender&quot;: data[10],<br/>                        &quot;HeightType&quot;: data[11], &quot;MethodOffence&quot;: data[12], &quot;NarrativeDesc&quot;: data[13],<br/>                        &quot;ProfileId&quot;: get_profile_id(), &quot;ReportedBy&quot;: data[15], &quot;ReportedLoss&quot;: data[16],<br/>                        &quot;StoreId&quot;: data[17], &quot;TimeIncident&quot;: data[18], &quot;RegionId&quot;: select_region()}<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:455: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_C_group_Id():<br/>&gt;       data = create_enrollment_group_with_addCaseGroupZone_request()<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:698: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_enrollment_group_with_addCaseGroupZone_request():<br/>        token = login_token()<br/>&gt;       data = create_enrollment_group_request(3)<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:463: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 3<br/><br/>    def create_enrollment_group_request(row_no):<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>        data = create_enrollment_group_test_data(row_no)<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_enrollment_group_endpoint()}&quot;<br/>        name = f&quot;{data[0]}{random_number()}&quot;<br/>        request_body = {&quot;name&quot;: name, &quot;description&quot;: data[1], &quot;faceThreshold&quot;: data[2], &quot;maskedFaceThreshold&quot;: data[3],<br/>                        &quot;eventsSuppressionInterval&quot;: data[4], &quot;priority&quot;: data[5], &quot;seriousOffender&quot;: data[6],<br/>                        &quot;alertHexColor&quot;: data[7], &quot;activeThreat&quot;: data[8]}<br/>        request_data = json.dumps(request_body)<br/>        response_str = requests.post(url, data=request_data, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:455: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.L_Identify_and_Enroll_Module_API.test_identify_enroll_api.Test_identify_enroll_api object at 0x000002472898FB50&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Identify_and_Enroll_Module_API\test_identify_enroll_api.py:30: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000024728F0C610&gt;<br/><br/>    def verify_query_Enrollment_FaceInfo(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = query_Enrollment_FaceInfo_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:121: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_identify_enroll_api.py:29 test_identify_enroll_Test_03  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/L_Identify_and_Enroll_Module_API/test_identify_enroll_api.py::Test_identify_enroll_api::test_identify_enroll_Test_04</td>
          <td class="col-duration">7.59</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x00000247293F3010&gt;<br/><br/>    def verify_enrollment_profiles(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = get_enrollment_profiles_request()<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:132: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_enrollment_profiles_request():<br/>&gt;       create_enrollment_request()<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:612: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_enrollment_request():<br/>        token = login_token()<br/>        image_path = f&quot;{Path(__file__).parent.parent.parent}\\API_Test_Data\\image.png&quot;<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_enrollment_endpoint()}&quot;<br/>        data = create_enrollment_data(2)<br/>&gt;       request_body = {&quot;CgroupId&quot;: get_C_group_Id(), &quot;OptOut&quot;: data[1], &quot;Basis&quot;: data[2], &quot;Action&quot;: data[3],<br/>                        &quot;ActivityType&quot;: data[4], &quot;BodyMarkings&quot;: data[5], &quot;Build&quot;: data[6],<br/>                        &quot;CaseEventType&quot;: data[7], &quot;CaseNumber&quot;: data[8], &quot;Enabled&quot;: data[9], &quot;Gender&quot;: data[10],<br/>                        &quot;HeightType&quot;: data[11], &quot;MethodOffence&quot;: data[12], &quot;NarrativeDesc&quot;: data[13],<br/>                        &quot;ProfileId&quot;: get_profile_id(), &quot;ReportedBy&quot;: data[15], &quot;ReportedLoss&quot;: data[16],<br/>                        &quot;StoreId&quot;: data[17], &quot;TimeIncident&quot;: data[18], &quot;RegionId&quot;: select_region()}<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:455: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_C_group_Id():<br/>&gt;       data = create_enrollment_group_with_addCaseGroupZone_request()<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:698: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_enrollment_group_with_addCaseGroupZone_request():<br/>        token = login_token()<br/>&gt;       data = create_enrollment_group_request(3)<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:463: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 3<br/><br/>    def create_enrollment_group_request(row_no):<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>        data = create_enrollment_group_test_data(row_no)<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_enrollment_group_endpoint()}&quot;<br/>        name = f&quot;{data[0]}{random_number()}&quot;<br/>        request_body = {&quot;name&quot;: name, &quot;description&quot;: data[1], &quot;faceThreshold&quot;: data[2], &quot;maskedFaceThreshold&quot;: data[3],<br/>                        &quot;eventsSuppressionInterval&quot;: data[4], &quot;priority&quot;: data[5], &quot;seriousOffender&quot;: data[6],<br/>                        &quot;alertHexColor&quot;: data[7], &quot;activeThreat&quot;: data[8]}<br/>        request_data = json.dumps(request_body)<br/>        response_str = requests.post(url, data=request_data, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:455: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.L_Identify_and_Enroll_Module_API.test_identify_enroll_api.Test_identify_enroll_api object at 0x0000024728998250&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Identify_and_Enroll_Module_API\test_identify_enroll_api.py:38: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x00000247293F3010&gt;<br/><br/>    def verify_enrollment_profiles(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_enrollment_profiles_request()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:152: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_identify_enroll_api.py:37 test_identify_enroll_Test_04  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/L_Identify_and_Enroll_Module_API/test_identify_enroll_api.py::Test_identify_enroll_api::test_identify_enroll_Test_05</td>
          <td class="col-duration">8.40</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000024728BDC350&gt;<br/><br/>    def verify_identify_enrollment(self):<br/>        result = []<br/>        try:<br/>            self.row = 6<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = identify_enrollment()<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:163: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def identify_enrollment():<br/>&gt;       create_enrollment_request()<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:622: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_enrollment_request():<br/>        token = login_token()<br/>        image_path = f&quot;{Path(__file__).parent.parent.parent}\\API_Test_Data\\image.png&quot;<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_enrollment_endpoint()}&quot;<br/>        data = create_enrollment_data(2)<br/>&gt;       request_body = {&quot;CgroupId&quot;: get_C_group_Id(), &quot;OptOut&quot;: data[1], &quot;Basis&quot;: data[2], &quot;Action&quot;: data[3],<br/>                        &quot;ActivityType&quot;: data[4], &quot;BodyMarkings&quot;: data[5], &quot;Build&quot;: data[6],<br/>                        &quot;CaseEventType&quot;: data[7], &quot;CaseNumber&quot;: data[8], &quot;Enabled&quot;: data[9], &quot;Gender&quot;: data[10],<br/>                        &quot;HeightType&quot;: data[11], &quot;MethodOffence&quot;: data[12], &quot;NarrativeDesc&quot;: data[13],<br/>                        &quot;ProfileId&quot;: get_profile_id(), &quot;ReportedBy&quot;: data[15], &quot;ReportedLoss&quot;: data[16],<br/>                        &quot;StoreId&quot;: data[17], &quot;TimeIncident&quot;: data[18], &quot;RegionId&quot;: select_region()}<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:455: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_C_group_Id():<br/>&gt;       data = create_enrollment_group_with_addCaseGroupZone_request()<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:698: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_enrollment_group_with_addCaseGroupZone_request():<br/>        token = login_token()<br/>&gt;       data = create_enrollment_group_request(3)<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:463: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 3<br/><br/>    def create_enrollment_group_request(row_no):<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>        data = create_enrollment_group_test_data(row_no)<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_enrollment_group_endpoint()}&quot;<br/>        name = f&quot;{data[0]}{random_number()}&quot;<br/>        request_body = {&quot;name&quot;: name, &quot;description&quot;: data[1], &quot;faceThreshold&quot;: data[2], &quot;maskedFaceThreshold&quot;: data[3],<br/>                        &quot;eventsSuppressionInterval&quot;: data[4], &quot;priority&quot;: data[5], &quot;seriousOffender&quot;: data[6],<br/>                        &quot;alertHexColor&quot;: data[7], &quot;activeThreat&quot;: data[8]}<br/>        request_data = json.dumps(request_body)<br/>        response_str = requests.post(url, data=request_data, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:455: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.L_Identify_and_Enroll_Module_API.test_identify_enroll_api.Test_identify_enroll_api object at 0x00000247289988D0&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Identify_and_Enroll_Module_API\test_identify_enroll_api.py:46: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000024728BDC350&gt;<br/><br/>    def verify_identify_enrollment(self):<br/>        result = []<br/>        try:<br/>            self.row = 6<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = identify_enrollment()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:183: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_identify_enroll_api.py:45 test_identify_enroll_Test_05  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/L_Identify_and_Enroll_Module_API/test_identify_enroll_api.py::Test_identify_enroll_api::test_identify_enroll_Test_06</td>
          <td class="col-duration">7.15</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x00000247296B2650&gt;<br/><br/>    def verify_search_enrollments(self):<br/>        result = []<br/>        try:<br/>            self.row = 7<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = search_enrollment_request()<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:194: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def search_enrollment_request():<br/>        # create_enrollment_request()<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}api/Enrollments/searchEnrollments&quot;<br/>        data = identify_search_enrollment(8)<br/>        request_body = {&quot;fields&quot;: [{&quot;key&quot;: data[0], &quot;value&quot;: data[1]}], &quot;count&quot;: data[2], &quot;ascending&quot;: data[3],<br/>                        &quot;detailLevel&quot;: data[4], &quot;isExact&quot;: data[5], &quot;offset&quot;: data[6], &quot;orderBy&quot;: data[7],<br/>                        &quot;startEnrollmentDate&quot;: data[8], &quot;endEnrollmentDate&quot;: data[9], &quot;startExpirationDate&quot;: data[10],<br/>                        &quot;endExpirationDate&quot;: data[11], &quot;notInCGroup&quot;: data[12], &quot;searchInOr&quot;: data[13],<br/>&gt;                       &quot;cgroup_id&quot;: get_C_group_Id()}<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:592: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_C_group_Id():<br/>&gt;       data = create_enrollment_group_with_addCaseGroupZone_request()<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:698: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_enrollment_group_with_addCaseGroupZone_request():<br/>        token = login_token()<br/>&gt;       data = create_enrollment_group_request(3)<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:463: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 3<br/><br/>    def create_enrollment_group_request(row_no):<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>        data = create_enrollment_group_test_data(row_no)<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_enrollment_group_endpoint()}&quot;<br/>        name = f&quot;{data[0]}{random_number()}&quot;<br/>        request_body = {&quot;name&quot;: name, &quot;description&quot;: data[1], &quot;faceThreshold&quot;: data[2], &quot;maskedFaceThreshold&quot;: data[3],<br/>                        &quot;eventsSuppressionInterval&quot;: data[4], &quot;priority&quot;: data[5], &quot;seriousOffender&quot;: data[6],<br/>                        &quot;alertHexColor&quot;: data[7], &quot;activeThreat&quot;: data[8]}<br/>        request_data = json.dumps(request_body)<br/>        response_str = requests.post(url, data=request_data, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:455: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.L_Identify_and_Enroll_Module_API.test_identify_enroll_api.Test_identify_enroll_api object at 0x000002472898D250&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Identify_and_Enroll_Module_API\test_identify_enroll_api.py:54: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x00000247296B2650&gt;<br/><br/>    def verify_search_enrollments(self):<br/>        result = []<br/>        try:<br/>            self.row = 7<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = search_enrollment_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:215: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_identify_enroll_api.py:53 test_identify_enroll_Test_06  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/L_Identify_and_Enroll_Module_API/test_identify_enroll_api.py::Test_identify_enroll_api::test_identify_enroll_Test_07</td>
          <td class="col-duration">7.80</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000024728B49D90&gt;<br/><br/>    def verify_edit_enrollments(self):<br/>        result = []<br/>        try:<br/>            self.row = 8<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = edit_enrollment_request()<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:226: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def edit_enrollment_request():<br/>&gt;       enroll = create_enrollment_request()<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:533: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_enrollment_request():<br/>        token = login_token()<br/>        image_path = f&quot;{Path(__file__).parent.parent.parent}\\API_Test_Data\\image.png&quot;<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_enrollment_endpoint()}&quot;<br/>        data = create_enrollment_data(2)<br/>&gt;       request_body = {&quot;CgroupId&quot;: get_C_group_Id(), &quot;OptOut&quot;: data[1], &quot;Basis&quot;: data[2], &quot;Action&quot;: data[3],<br/>                        &quot;ActivityType&quot;: data[4], &quot;BodyMarkings&quot;: data[5], &quot;Build&quot;: data[6],<br/>                        &quot;CaseEventType&quot;: data[7], &quot;CaseNumber&quot;: data[8], &quot;Enabled&quot;: data[9], &quot;Gender&quot;: data[10],<br/>                        &quot;HeightType&quot;: data[11], &quot;MethodOffence&quot;: data[12], &quot;NarrativeDesc&quot;: data[13],<br/>                        &quot;ProfileId&quot;: get_profile_id(), &quot;ReportedBy&quot;: data[15], &quot;ReportedLoss&quot;: data[16],<br/>                        &quot;StoreId&quot;: data[17], &quot;TimeIncident&quot;: data[18], &quot;RegionId&quot;: select_region()}<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:455: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_C_group_Id():<br/>&gt;       data = create_enrollment_group_with_addCaseGroupZone_request()<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:698: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_enrollment_group_with_addCaseGroupZone_request():<br/>        token = login_token()<br/>&gt;       data = create_enrollment_group_request(3)<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:463: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 3<br/><br/>    def create_enrollment_group_request(row_no):<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>        data = create_enrollment_group_test_data(row_no)<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_enrollment_group_endpoint()}&quot;<br/>        name = f&quot;{data[0]}{random_number()}&quot;<br/>        request_body = {&quot;name&quot;: name, &quot;description&quot;: data[1], &quot;faceThreshold&quot;: data[2], &quot;maskedFaceThreshold&quot;: data[3],<br/>                        &quot;eventsSuppressionInterval&quot;: data[4], &quot;priority&quot;: data[5], &quot;seriousOffender&quot;: data[6],<br/>                        &quot;alertHexColor&quot;: data[7], &quot;activeThreat&quot;: data[8]}<br/>        request_data = json.dumps(request_body)<br/>        response_str = requests.post(url, data=request_data, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:455: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.L_Identify_and_Enroll_Module_API.test_identify_enroll_api.Test_identify_enroll_api object at 0x000002472898F2D0&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Identify_and_Enroll_Module_API\test_identify_enroll_api.py:62: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000024728B49D90&gt;<br/><br/>    def verify_edit_enrollments(self):<br/>        result = []<br/>        try:<br/>            self.row = 8<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = edit_enrollment_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            enroll_id = response_list[3]<br/>            self.act_msg = self.json_response[&quot;message&quot;]<br/>            self.exp_msg = Read_identify_enroll_Response_msg().edit_enrollment_success_msg(enroll_id)<br/>            if response_validation(self.response) and self.act_msg == self.exp_msg:<br/>                excel_result(self.row, &quot;Test_07&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_07&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_07&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:250: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_identify_enroll_api.py:61 test_identify_enroll_Test_07  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/L_Identify_and_Enroll_Module_API/test_identify_enroll_api.py::Test_identify_enroll_api::test_identify_enroll_Test_08</td>
          <td class="col-duration">8.46</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000024728DB6210&gt;<br/><br/>    def verify_delete_enrollments(self):<br/>        result = []<br/>        try:<br/>            self.row = 9<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = delete_enrollment_request()<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:261: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def delete_enrollment_request():<br/>&gt;       enroll = create_enrollment_request()<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:556: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_enrollment_request():<br/>        token = login_token()<br/>        image_path = f&quot;{Path(__file__).parent.parent.parent}\\API_Test_Data\\image.png&quot;<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_enrollment_endpoint()}&quot;<br/>        data = create_enrollment_data(2)<br/>&gt;       request_body = {&quot;CgroupId&quot;: get_C_group_Id(), &quot;OptOut&quot;: data[1], &quot;Basis&quot;: data[2], &quot;Action&quot;: data[3],<br/>                        &quot;ActivityType&quot;: data[4], &quot;BodyMarkings&quot;: data[5], &quot;Build&quot;: data[6],<br/>                        &quot;CaseEventType&quot;: data[7], &quot;CaseNumber&quot;: data[8], &quot;Enabled&quot;: data[9], &quot;Gender&quot;: data[10],<br/>                        &quot;HeightType&quot;: data[11], &quot;MethodOffence&quot;: data[12], &quot;NarrativeDesc&quot;: data[13],<br/>                        &quot;ProfileId&quot;: get_profile_id(), &quot;ReportedBy&quot;: data[15], &quot;ReportedLoss&quot;: data[16],<br/>                        &quot;StoreId&quot;: data[17], &quot;TimeIncident&quot;: data[18], &quot;RegionId&quot;: select_region()}<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:455: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_C_group_Id():<br/>&gt;       data = create_enrollment_group_with_addCaseGroupZone_request()<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:698: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_enrollment_group_with_addCaseGroupZone_request():<br/>        token = login_token()<br/>&gt;       data = create_enrollment_group_request(3)<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:463: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 3<br/><br/>    def create_enrollment_group_request(row_no):<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>        data = create_enrollment_group_test_data(row_no)<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_enrollment_group_endpoint()}&quot;<br/>        name = f&quot;{data[0]}{random_number()}&quot;<br/>        request_body = {&quot;name&quot;: name, &quot;description&quot;: data[1], &quot;faceThreshold&quot;: data[2], &quot;maskedFaceThreshold&quot;: data[3],<br/>                        &quot;eventsSuppressionInterval&quot;: data[4], &quot;priority&quot;: data[5], &quot;seriousOffender&quot;: data[6],<br/>                        &quot;alertHexColor&quot;: data[7], &quot;activeThreat&quot;: data[8]}<br/>        request_data = json.dumps(request_body)<br/>        response_str = requests.post(url, data=request_data, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:455: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.L_Identify_and_Enroll_Module_API.test_identify_enroll_api.Test_identify_enroll_api object at 0x000002472898CBD0&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Identify_and_Enroll_Module_API\test_identify_enroll_api.py:70: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000024728DB6210&gt;<br/><br/>    def verify_delete_enrollments(self):<br/>        result = []<br/>        try:<br/>            self.row = 9<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = delete_enrollment_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            enroll_id = response_list[3]<br/>            self.act_msg = self.json_response[&quot;message&quot;]<br/>            self.exp_msg = Read_identify_enroll_Response_msg().delete_enrollment_success_msg(enroll_id)<br/>            if response_validation(self.response) and self.act_msg == self.act_msg:<br/>                excel_result(self.row, &quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_08&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:285: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_identify_enroll_api.py:69 test_identify_enroll_Test_08  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/L_Identify_and_Enroll_Module_API/test_identify_enroll_api.py::Test_identify_enroll_api::test_identify_enroll_Test_09</td>
          <td class="col-duration">7.33</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000024728C09D90&gt;<br/><br/>    def verify_add_enrollment_with_image(self):<br/>        result = []<br/>        try:<br/>            self.row = 10<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = create_enrollment_with_image()<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:296: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_enrollment_with_image():<br/>&gt;       enroll = search_enrollment_request()[2]<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:474: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def search_enrollment_request():<br/>        # create_enrollment_request()<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}api/Enrollments/searchEnrollments&quot;<br/>        data = identify_search_enrollment(8)<br/>        request_body = {&quot;fields&quot;: [{&quot;key&quot;: data[0], &quot;value&quot;: data[1]}], &quot;count&quot;: data[2], &quot;ascending&quot;: data[3],<br/>                        &quot;detailLevel&quot;: data[4], &quot;isExact&quot;: data[5], &quot;offset&quot;: data[6], &quot;orderBy&quot;: data[7],<br/>                        &quot;startEnrollmentDate&quot;: data[8], &quot;endEnrollmentDate&quot;: data[9], &quot;startExpirationDate&quot;: data[10],<br/>                        &quot;endExpirationDate&quot;: data[11], &quot;notInCGroup&quot;: data[12], &quot;searchInOr&quot;: data[13],<br/>&gt;                       &quot;cgroup_id&quot;: get_C_group_Id()}<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:592: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_C_group_Id():<br/>&gt;       data = create_enrollment_group_with_addCaseGroupZone_request()<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:698: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_enrollment_group_with_addCaseGroupZone_request():<br/>        token = login_token()<br/>&gt;       data = create_enrollment_group_request(3)<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:463: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 3<br/><br/>    def create_enrollment_group_request(row_no):<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>        data = create_enrollment_group_test_data(row_no)<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_enrollment_group_endpoint()}&quot;<br/>        name = f&quot;{data[0]}{random_number()}&quot;<br/>        request_body = {&quot;name&quot;: name, &quot;description&quot;: data[1], &quot;faceThreshold&quot;: data[2], &quot;maskedFaceThreshold&quot;: data[3],<br/>                        &quot;eventsSuppressionInterval&quot;: data[4], &quot;priority&quot;: data[5], &quot;seriousOffender&quot;: data[6],<br/>                        &quot;alertHexColor&quot;: data[7], &quot;activeThreat&quot;: data[8]}<br/>        request_data = json.dumps(request_body)<br/>        response_str = requests.post(url, data=request_data, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:455: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.L_Identify_and_Enroll_Module_API.test_identify_enroll_api.Test_identify_enroll_api object at 0x000002472890FC50&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Identify_and_Enroll_Module_API\test_identify_enroll_api.py:78: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000024728C09D90&gt;<br/><br/>    def verify_add_enrollment_with_image(self):<br/>        result = []<br/>        try:<br/>            self.row = 10<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = create_enrollment_with_image()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_09&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_09&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_09&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:316: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_identify_enroll_api.py:77 test_identify_enroll_Test_09  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/L_Identify_and_Enroll_Module_API/test_identify_enroll_api.py::Test_identify_enroll_api::test_identify_enroll_Test_10</td>
          <td class="col-duration">8.99</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000024728DD2290&gt;<br/><br/>    def Verify_Get_enrollment_image_by_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 11<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           self.response = get_enrollment_by_id()<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:327: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_enrollment_by_id():<br/>&gt;       enroll = create_enrollment_request()<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:497: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_enrollment_request():<br/>        token = login_token()<br/>        image_path = f&quot;{Path(__file__).parent.parent.parent}\\API_Test_Data\\image.png&quot;<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_enrollment_endpoint()}&quot;<br/>        data = create_enrollment_data(2)<br/>&gt;       request_body = {&quot;CgroupId&quot;: get_C_group_Id(), &quot;OptOut&quot;: data[1], &quot;Basis&quot;: data[2], &quot;Action&quot;: data[3],<br/>                        &quot;ActivityType&quot;: data[4], &quot;BodyMarkings&quot;: data[5], &quot;Build&quot;: data[6],<br/>                        &quot;CaseEventType&quot;: data[7], &quot;CaseNumber&quot;: data[8], &quot;Enabled&quot;: data[9], &quot;Gender&quot;: data[10],<br/>                        &quot;HeightType&quot;: data[11], &quot;MethodOffence&quot;: data[12], &quot;NarrativeDesc&quot;: data[13],<br/>                        &quot;ProfileId&quot;: get_profile_id(), &quot;ReportedBy&quot;: data[15], &quot;ReportedLoss&quot;: data[16],<br/>                        &quot;StoreId&quot;: data[17], &quot;TimeIncident&quot;: data[18], &quot;RegionId&quot;: select_region()}<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:455: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_C_group_Id():<br/>&gt;       data = create_enrollment_group_with_addCaseGroupZone_request()<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:698: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_enrollment_group_with_addCaseGroupZone_request():<br/>        token = login_token()<br/>&gt;       data = create_enrollment_group_request(3)<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:463: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 3<br/><br/>    def create_enrollment_group_request(row_no):<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>        data = create_enrollment_group_test_data(row_no)<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_enrollment_group_endpoint()}&quot;<br/>        name = f&quot;{data[0]}{random_number()}&quot;<br/>        request_body = {&quot;name&quot;: name, &quot;description&quot;: data[1], &quot;faceThreshold&quot;: data[2], &quot;maskedFaceThreshold&quot;: data[3],<br/>                        &quot;eventsSuppressionInterval&quot;: data[4], &quot;priority&quot;: data[5], &quot;seriousOffender&quot;: data[6],<br/>                        &quot;alertHexColor&quot;: data[7], &quot;activeThreat&quot;: data[8]}<br/>        request_data = json.dumps(request_body)<br/>        response_str = requests.post(url, data=request_data, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:455: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.L_Identify_and_Enroll_Module_API.test_identify_enroll_api.Test_identify_enroll_api object at 0x000002472886B550&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Identify_and_Enroll_Module_API\test_identify_enroll_api.py:86: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000024728DD2290&gt;<br/><br/>    def Verify_Get_enrollment_image_by_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 11<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            self.response = get_enrollment_by_id()<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_10&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_10&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_10&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:345: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_identify_enroll_api.py:85 test_identify_enroll_Test_10  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/L_Identify_and_Enroll_Module_API/test_identify_enroll_api.py::Test_identify_enroll_api::test_identify_enroll_Test_11</td>
          <td class="col-duration">9.25</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000024729157050&gt;<br/><br/>    def Verify_remove_enrollment_image_by_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 12<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = remove_enrollment_images_request()<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:356: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def remove_enrollment_images_request():<br/>        token = login_token()<br/>&gt;       data = get_face_id_using_case_id()<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:508: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_face_id_using_case_id():<br/>&gt;       enroll = create_enrollment_request()<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:521: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_enrollment_request():<br/>        token = login_token()<br/>        image_path = f&quot;{Path(__file__).parent.parent.parent}\\API_Test_Data\\image.png&quot;<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_enrollment_endpoint()}&quot;<br/>        data = create_enrollment_data(2)<br/>&gt;       request_body = {&quot;CgroupId&quot;: get_C_group_Id(), &quot;OptOut&quot;: data[1], &quot;Basis&quot;: data[2], &quot;Action&quot;: data[3],<br/>                        &quot;ActivityType&quot;: data[4], &quot;BodyMarkings&quot;: data[5], &quot;Build&quot;: data[6],<br/>                        &quot;CaseEventType&quot;: data[7], &quot;CaseNumber&quot;: data[8], &quot;Enabled&quot;: data[9], &quot;Gender&quot;: data[10],<br/>                        &quot;HeightType&quot;: data[11], &quot;MethodOffence&quot;: data[12], &quot;NarrativeDesc&quot;: data[13],<br/>                        &quot;ProfileId&quot;: get_profile_id(), &quot;ReportedBy&quot;: data[15], &quot;ReportedLoss&quot;: data[16],<br/>                        &quot;StoreId&quot;: data[17], &quot;TimeIncident&quot;: data[18], &quot;RegionId&quot;: select_region()}<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:455: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_C_group_Id():<br/>&gt;       data = create_enrollment_group_with_addCaseGroupZone_request()<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:698: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_enrollment_group_with_addCaseGroupZone_request():<br/>        token = login_token()<br/>&gt;       data = create_enrollment_group_request(3)<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:463: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 3<br/><br/>    def create_enrollment_group_request(row_no):<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>        data = create_enrollment_group_test_data(row_no)<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_enrollment_group_endpoint()}&quot;<br/>        name = f&quot;{data[0]}{random_number()}&quot;<br/>        request_body = {&quot;name&quot;: name, &quot;description&quot;: data[1], &quot;faceThreshold&quot;: data[2], &quot;maskedFaceThreshold&quot;: data[3],<br/>                        &quot;eventsSuppressionInterval&quot;: data[4], &quot;priority&quot;: data[5], &quot;seriousOffender&quot;: data[6],<br/>                        &quot;alertHexColor&quot;: data[7], &quot;activeThreat&quot;: data[8]}<br/>        request_data = json.dumps(request_body)<br/>        response_str = requests.post(url, data=request_data, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:455: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.L_Identify_and_Enroll_Module_API.test_identify_enroll_api.Test_identify_enroll_api object at 0x00000247289981D0&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Identify_and_Enroll_Module_API\test_identify_enroll_api.py:94: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000024729157050&gt;<br/><br/>    def Verify_remove_enrollment_image_by_id(self):<br/>        result = []<br/>        try:<br/>            self.row = 12<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = remove_enrollment_images_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_11&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_11&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_11&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:377: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_identify_enroll_api.py:93 test_identify_enroll_Test_11  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/L_Identify_and_Enroll_Module_API/test_identify_enroll_api.py::Test_identify_enroll_api::test_identify_enroll_Test_12</td>
          <td class="col-duration">9.16</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x00000247291A6210&gt;<br/><br/>    def verify_create_enrollment_with_id_and_notification_group(self):<br/>        result = []<br/>        try:<br/>            self.row = 13<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = create_enrollment_with_id_and_notification_group_request()<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:388: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_enrollment_with_id_and_notification_group_request():<br/>&gt;       data = create_enrollment_request()<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:669: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_enrollment_request():<br/>        token = login_token()<br/>        image_path = f&quot;{Path(__file__).parent.parent.parent}\\API_Test_Data\\image.png&quot;<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_enrollment_endpoint()}&quot;<br/>        data = create_enrollment_data(2)<br/>&gt;       request_body = {&quot;CgroupId&quot;: get_C_group_Id(), &quot;OptOut&quot;: data[1], &quot;Basis&quot;: data[2], &quot;Action&quot;: data[3],<br/>                        &quot;ActivityType&quot;: data[4], &quot;BodyMarkings&quot;: data[5], &quot;Build&quot;: data[6],<br/>                        &quot;CaseEventType&quot;: data[7], &quot;CaseNumber&quot;: data[8], &quot;Enabled&quot;: data[9], &quot;Gender&quot;: data[10],<br/>                        &quot;HeightType&quot;: data[11], &quot;MethodOffence&quot;: data[12], &quot;NarrativeDesc&quot;: data[13],<br/>                        &quot;ProfileId&quot;: get_profile_id(), &quot;ReportedBy&quot;: data[15], &quot;ReportedLoss&quot;: data[16],<br/>                        &quot;StoreId&quot;: data[17], &quot;TimeIncident&quot;: data[18], &quot;RegionId&quot;: select_region()}<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:455: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_C_group_Id():<br/>&gt;       data = create_enrollment_group_with_addCaseGroupZone_request()<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:698: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_enrollment_group_with_addCaseGroupZone_request():<br/>        token = login_token()<br/>&gt;       data = create_enrollment_group_request(3)<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:463: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 3<br/><br/>    def create_enrollment_group_request(row_no):<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>        data = create_enrollment_group_test_data(row_no)<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_enrollment_group_endpoint()}&quot;<br/>        name = f&quot;{data[0]}{random_number()}&quot;<br/>        request_body = {&quot;name&quot;: name, &quot;description&quot;: data[1], &quot;faceThreshold&quot;: data[2], &quot;maskedFaceThreshold&quot;: data[3],<br/>                        &quot;eventsSuppressionInterval&quot;: data[4], &quot;priority&quot;: data[5], &quot;seriousOffender&quot;: data[6],<br/>                        &quot;alertHexColor&quot;: data[7], &quot;activeThreat&quot;: data[8]}<br/>        request_data = json.dumps(request_body)<br/>        response_str = requests.post(url, data=request_data, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:455: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.L_Identify_and_Enroll_Module_API.test_identify_enroll_api.Test_identify_enroll_api object at 0x0000024728998E90&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Identify_and_Enroll_Module_API\test_identify_enroll_api.py:102: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x00000247291A6210&gt;<br/><br/>    def verify_create_enrollment_with_id_and_notification_group(self):<br/>        result = []<br/>        try:<br/>            self.row = 13<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = create_enrollment_with_id_and_notification_group_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_12&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_12&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_12&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:409: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_identify_enroll_api.py:101 test_identify_enroll_Test_12  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/L_Identify_and_Enroll_Module_API/test_identify_enroll_api.py::Test_identify_enroll_api::test_identify_enroll_Test_13</td>
          <td class="col-duration">8.07</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000024728B94F10&gt;<br/><br/>    def verify_query_enrollment_info(self):<br/>        result = []<br/>        try:<br/>            self.row = 14<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = query_enrollment_info_request()<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:420: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def query_enrollment_info_request():<br/>&gt;       data = create_enrollment_request()<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:685: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_enrollment_request():<br/>        token = login_token()<br/>        image_path = f&quot;{Path(__file__).parent.parent.parent}\\API_Test_Data\\image.png&quot;<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_enrollment_endpoint()}&quot;<br/>        data = create_enrollment_data(2)<br/>&gt;       request_body = {&quot;CgroupId&quot;: get_C_group_Id(), &quot;OptOut&quot;: data[1], &quot;Basis&quot;: data[2], &quot;Action&quot;: data[3],<br/>                        &quot;ActivityType&quot;: data[4], &quot;BodyMarkings&quot;: data[5], &quot;Build&quot;: data[6],<br/>                        &quot;CaseEventType&quot;: data[7], &quot;CaseNumber&quot;: data[8], &quot;Enabled&quot;: data[9], &quot;Gender&quot;: data[10],<br/>                        &quot;HeightType&quot;: data[11], &quot;MethodOffence&quot;: data[12], &quot;NarrativeDesc&quot;: data[13],<br/>                        &quot;ProfileId&quot;: get_profile_id(), &quot;ReportedBy&quot;: data[15], &quot;ReportedLoss&quot;: data[16],<br/>                        &quot;StoreId&quot;: data[17], &quot;TimeIncident&quot;: data[18], &quot;RegionId&quot;: select_region()}<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:455: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_C_group_Id():<br/>&gt;       data = create_enrollment_group_with_addCaseGroupZone_request()<br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:698: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_enrollment_group_with_addCaseGroupZone_request():<br/>        token = login_token()<br/>&gt;       data = create_enrollment_group_request(3)<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:463: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 3<br/><br/>    def create_enrollment_group_request(row_no):<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>        data = create_enrollment_group_test_data(row_no)<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_enrollment_group_endpoint()}&quot;<br/>        name = f&quot;{data[0]}{random_number()}&quot;<br/>        request_body = {&quot;name&quot;: name, &quot;description&quot;: data[1], &quot;faceThreshold&quot;: data[2], &quot;maskedFaceThreshold&quot;: data[3],<br/>                        &quot;eventsSuppressionInterval&quot;: data[4], &quot;priority&quot;: data[5], &quot;seriousOffender&quot;: data[6],<br/>                        &quot;alertHexColor&quot;: data[7], &quot;activeThreat&quot;: data[8]}<br/>        request_data = json.dumps(request_body)<br/>        response_str = requests.post(url, data=request_data, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:455: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.L_Identify_and_Enroll_Module_API.test_identify_enroll_api.Test_identify_enroll_api object at 0x0000024728999510&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Identify_and_Enroll_Module_API\test_identify_enroll_api.py:110: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Identify_and_Enroll_Module_API.Identify_Enroll_Module_API.Identify_Enroll_API_Methods object at 0x0000024728B94F10&gt;<br/><br/>    def verify_query_enrollment_info(self):<br/>        result = []<br/>        try:<br/>            self.row = 14<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = query_enrollment_info_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_12&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_12&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_12&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Identify_and_Enroll_Module_API\Identify_Enroll_Module_API.py:441: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_identify_enroll_api.py:109 test_identify_enroll_Test_13  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/M_All_Module_Search_API/test_all_module_search_api.py::Test_All_Module_Search_api::test_All_Module_Search_Test_01</td>
          <td class="col-duration">4.43</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.All_Module_Search_API.All_module_search_API_Methods.All_Module_Search_API_Methods object at 0x0000024728DCBB90&gt;<br/><br/>    def verify_events_search(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = get_event_search()<br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:31: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_event_search():<br/>        token = login_token()<br/>        print(token)<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>        data = events_test_data(2)<br/>        print(data)<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().events_search_endpoint()}&quot;<br/>        print(url)<br/>        params = {&quot;Start&quot;: &quot;0&quot;, &quot;Limit&quot;: &quot;20&quot;, &quot;SortDirection&quot;: &quot;Ascending&quot;}<br/>        request_body = {&quot;enrollmentGroupIds&quot;: [data[0]], &quot;startTime&quot;: data[1], &quot;endTime&quot;: data[2],<br/>&gt;                       &quot;tags&quot;: [data[3]], &quot;regionIds&quot;: [select_region()], &quot;cameraIds&quot;: [data[5]],<br/>                        &quot;eventIds&quot;: [data[6]]}<br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:240: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def select_region():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_region_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:854: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.M_All_Module_Search_API.test_all_module_search_api.Test_All_Module_Search_api object at 0x000002472899A510&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\All_Module_Search_API\test_all_module_search_api.py:11: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.All_Module_Search_API.All_module_search_API_Methods.All_Module_Search_API_Methods object at 0x0000024728DCBB90&gt;<br/><br/>    def verify_events_search(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_event_search()<br/>            self.response = response_list[0]<br/>            print(self.response)<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:55: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>
[None, &#x27;2023-09-11T18:30:00.000Z&#x27;, &#x27;2023-10-12T18:29:00.000Z&#x27;, None, &#x27;dynamic&#x27;, None, None]
No section: &#x27;M_All_Module_Search_API&#x27;
https://ff-india-qa10.eastus2.cloudapp.azure.com/None
Expecting value: line 1 column 1 (char 0)
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_all_module_search_api.py:10 test_All_Module_Search_Test_01  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/M_All_Module_Search_API/test_all_module_search_api.py::Test_All_Module_Search_api::test_All_Module_Search_Test_02</td>
          <td class="col-duration">2.51</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.All_Module_Search_API.All_module_search_API_Methods.All_Module_Search_API_Methods object at 0x00000247292FABD0&gt;<br/><br/>    def verify_users_search(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = get_user_by_id_request()<br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:66: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_user_by_id_request():<br/>&gt;       data = get_user_request()<br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:251: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_user_request():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_users_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:267: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.M_All_Module_Search_API.test_all_module_search_api.Test_All_Module_Search_api object at 0x000002472899ABD0&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\All_Module_Search_API\test_all_module_search_api.py:18: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.All_Module_Search_API.All_module_search_API_Methods.All_Module_Search_API_Methods object at 0x00000247292FABD0&gt;<br/><br/>    def verify_users_search(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_user_by_id_request()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:86: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_all_module_search_api.py:17 test_All_Module_Search_Test_02  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/M_All_Module_Search_API/test_all_module_search_api.py::Test_All_Module_Search_api::test_All_Module_Search_Test_03</td>
          <td class="col-duration">5.34</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.All_Module_Search_API.All_module_search_API_Methods.All_Module_Search_API_Methods object at 0x000002472907C2D0&gt;<br/><br/>    def verify_notes_search(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           create_notes_request()<br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:97: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_notes_request():<br/>        token = login_token()<br/>        image_path = f&quot;{Path(__file__).parent.parent.parent}\\API_Test_Data\\image.png&quot;<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_notes_endpoint()}&quot;<br/>        data = create_enrollment_data(2)<br/>        request_body = {&quot;gender&quot;: data[0], &quot;build&quot;: data[1], &quot;bodyMarkings&quot;: data[2], &quot;narrativeDesc&quot;: data[3],<br/>                        &quot;action&quot;: data[4], &quot;storeId&quot;: data[5], &quot;caseNumber&quot;: data[6],<br/>                        &quot;timeIncident&quot;: data[7], &quot;reportedBy&quot;: data[8], &quot;reportedLoss&quot;: data[9],<br/>                        &quot;caseEventType&quot;: data[10],<br/>                        &quot;activityType&quot;: data[11], &quot;heightType&quot;: data[12], &quot;methodOffence&quot;: data[13],<br/>&gt;                       &quot;ProfileId&quot;: get_profile_id(), &quot;ClearGeo&quot;: data[15], &quot;geo&quot;: data[16],<br/>                        }<br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:321: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_profile_id():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}api/Profiles&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:341: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.M_All_Module_Search_API.test_all_module_search_api.Test_All_Module_Search_api object at 0x000002472899B290&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\All_Module_Search_API\test_all_module_search_api.py:25: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.All_Module_Search_API.All_module_search_API_Methods.All_Module_Search_API_Methods object at 0x000002472907C2D0&gt;<br/><br/>    def verify_notes_search(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            create_notes_request()<br/>            response_list = notes_search_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:120: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>Expecting value: line 1 column 1 (char 0)
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_all_module_search_api.py:24 test_All_Module_Search_Test_03  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/M_All_Module_Search_API/test_all_module_search_api.py::Test_All_Module_Search_api::test_All_Module_Search_Test_04</td>
          <td class="col-duration">5.20</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.All_Module_Search_API.All_module_search_API_Methods.All_Module_Search_API_Methods object at 0x0000024728C613D0&gt;<br/><br/>    def verify_visitors_search(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           create_notes_request()<br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:131: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def create_notes_request():<br/>        token = login_token()<br/>        image_path = f&quot;{Path(__file__).parent.parent.parent}\\API_Test_Data\\image.png&quot;<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_notes_endpoint()}&quot;<br/>        data = create_enrollment_data(2)<br/>        request_body = {&quot;gender&quot;: data[0], &quot;build&quot;: data[1], &quot;bodyMarkings&quot;: data[2], &quot;narrativeDesc&quot;: data[3],<br/>                        &quot;action&quot;: data[4], &quot;storeId&quot;: data[5], &quot;caseNumber&quot;: data[6],<br/>                        &quot;timeIncident&quot;: data[7], &quot;reportedBy&quot;: data[8], &quot;reportedLoss&quot;: data[9],<br/>                        &quot;caseEventType&quot;: data[10],<br/>                        &quot;activityType&quot;: data[11], &quot;heightType&quot;: data[12], &quot;methodOffence&quot;: data[13],<br/>&gt;                       &quot;ProfileId&quot;: get_profile_id(), &quot;ClearGeo&quot;: data[15], &quot;geo&quot;: data[16],<br/>                        }<br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:321: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_profile_id():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}api/Profiles&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:341: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.M_All_Module_Search_API.test_all_module_search_api.Test_All_Module_Search_api object at 0x000002472899B990&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\All_Module_Search_API\test_all_module_search_api.py:32: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.All_Module_Search_API.All_module_search_API_Methods.All_Module_Search_API_Methods object at 0x0000024728C613D0&gt;<br/><br/>    def verify_visitors_search(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            create_notes_request()<br/>            response_list = get_visitors_request()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:154: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>Expecting value: line 1 column 1 (char 0)
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_all_module_search_api.py:31 test_All_Module_Search_Test_04  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/M_All_Module_Search_API/test_all_module_search_api.py::Test_All_Module_Search_api::test_All_Module_Search_Test_05</td>
          <td class="col-duration">4.53</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.All_Module_Search_API.All_module_search_API_Methods.All_Module_Search_API_Methods object at 0x0000024728AEE790&gt;<br/><br/>    def verify_enrollments_search(self):<br/>        result = []<br/>        try:<br/>            self.row = 6<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = get_enrollment_group_by_id()<br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:165: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_enrollment_group_by_id():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>&gt;       data = create_enrollment_group_request(3)<br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:348: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row_no = 3<br/><br/>    def create_enrollment_group_request(row_no):<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>        data = create_enrollment_group_test_data(row_no)<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_enrollment_group_endpoint()}&quot;<br/>        name = f&quot;{data[0]}{random_number()}&quot;<br/>        request_body = {&quot;name&quot;: name, &quot;description&quot;: data[1], &quot;faceThreshold&quot;: data[2], &quot;maskedFaceThreshold&quot;: data[3],<br/>                        &quot;eventsSuppressionInterval&quot;: data[4], &quot;priority&quot;: data[5], &quot;seriousOffender&quot;: data[6],<br/>                        &quot;alertHexColor&quot;: data[7], &quot;activeThreat&quot;: data[8]}<br/>        request_data = json.dumps(request_body)<br/>        response_str = requests.post(url, data=request_data, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Enrollment_Group_Module_API\Enrollment_Group_API_Methods.py:455: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.M_All_Module_Search_API.test_all_module_search_api.Test_All_Module_Search_api object at 0x000002472899C090&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\All_Module_Search_API\test_all_module_search_api.py:39: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.All_Module_Search_API.All_module_search_API_Methods.All_Module_Search_API_Methods object at 0x0000024728AEE790&gt;<br/><br/>    def verify_enrollments_search(self):<br/>        result = []<br/>        try:<br/>            self.row = 6<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_enrollment_group_by_id()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:188: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_all_module_search_api.py:38 test_All_Module_Search_Test_05  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/M_All_Module_Search_API/test_all_module_search_api.py::Test_All_Module_Search_api::test_All_Module_Search_Test_06</td>
          <td class="col-duration">3.78</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.All_Module_Search_API.All_module_search_API_Methods.All_Module_Search_API_Methods object at 0x0000024729268FD0&gt;<br/><br/>    def verify_visitor_search_jobs_search(self):<br/>        result = []<br/>        try:<br/>            self.row = 7<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = get_visitor_search_jobs_search()<br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:199: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_visitor_search_jobs_search():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>&gt;       user_id = get_user_request()<br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:359: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_user_request():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_users_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:267: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.M_All_Module_Search_API.test_all_module_search_api.Test_All_Module_Search_api object at 0x000002472899C750&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\All_Module_Search_API\test_all_module_search_api.py:46: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.All_Module_Search_API.All_module_search_API_Methods.All_Module_Search_API_Methods object at 0x0000024729268FD0&gt;<br/><br/>    def verify_visitor_search_jobs_search(self):<br/>        result = []<br/>        try:<br/>            self.row = 7<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_visitor_search_jobs_search()<br/>            self.r_body = response_list[0]<br/>            self.response = response_list[1]<br/>            self.json_response = response_list[2]<br/>            if response_validation(self.response):<br/>                excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_06&quot;, self.r_body, self.json_response, self.response.status_code, self.act_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\All_Module_Search_API\All_module_search_API_Methods.py:222: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_all_module_search_api.py:45 test_All_Module_Search_Test_06  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/N_Audit_Module_API/test_audit_api.py::Test_Account_api::test_Account_Test_01</td>
          <td class="col-duration">3.81</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Audit_Module_API.Audit_API_Methods.Audit_API_Methods object at 0x00000247291A61D0&gt;<br/><br/>    def verify_audit_approvers(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = get_all_account()<br/><br/>All_API_Methods_Package\Audit_Module_API\Audit_API_Methods.py:28: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_all_account():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_audit_approvers_endpoint()}&quot;<br/>        print(url)<br/>&gt;       userid_data = get_user_request()<br/><br/>All_API_Methods_Package\Audit_Module_API\Audit_API_Methods.py:216: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_user_request():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_users_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:730: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.N_Audit_Module_API.test_audit_api.Test_Account_api object at 0x000002472899E210&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Audit_Module_API\test_audit_api.py:10: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Audit_Module_API.Audit_API_Methods.Audit_API_Methods object at 0x00000247291A61D0&gt;<br/><br/>    def verify_audit_approvers(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_all_account()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            print(response_list)<br/>            for x in range(len(self.json_response)):<br/>                result.append(self.json_response[x][&quot;accountId&quot;] != &quot;&quot;)<br/>    <br/>            if response_validation(self.response) and False not in result:<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Audit_Module_API\Audit_API_Methods.py:55: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>https://ff-india-qa10.eastus2.cloudapp.azure.com/api/reports/audit/enrollment/approvers
Expecting value: line 1 column 1 (char 0)
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_audit_api.py:9 test_Account_Test_01  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/N_Audit_Module_API/test_audit_api.py::Test_Account_api::test_Account_Test_02</td>
          <td class="col-duration">3.74</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Audit_Module_API.Audit_API_Methods.Audit_API_Methods object at 0x0000024728CEC310&gt;<br/><br/>    def verify_audit_users(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = get_all_account_user()<br/><br/>All_API_Methods_Package\Audit_Module_API\Audit_API_Methods.py:66: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_all_account_user():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_audit_users_endpoint()}&quot;<br/>        print(url)<br/>&gt;       userid_data = get_user_request()<br/><br/>All_API_Methods_Package\Audit_Module_API\Audit_API_Methods.py:232: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_user_request():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_users_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:730: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.N_Audit_Module_API.test_audit_api.Test_Account_api object at 0x000002472899E8D0&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Audit_Module_API\test_audit_api.py:17: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Audit_Module_API.Audit_API_Methods.Audit_API_Methods object at 0x0000024728CEC310&gt;<br/><br/>    def verify_audit_users(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_all_account_user()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            print(response_list)<br/>            for x in range(len(self.json_response)):<br/>                result.append(self.json_response[x][&quot;accountId&quot;] != &quot;&quot;)<br/>    <br/>            if response_validation(self.response) and False not in result:<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Audit_Module_API\Audit_API_Methods.py:93: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>https://ff-india-qa10.eastus2.cloudapp.azure.com/api/reports/audit/enrollment/users
Expecting value: line 1 column 1 (char 0)
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_audit_api.py:16 test_Account_Test_02  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/N_Audit_Module_API/test_audit_api.py::Test_Account_api::test_Account_Test_03</td>
          <td class="col-duration">3.89</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Audit_Module_API.Audit_API_Methods.Audit_API_Methods object at 0x0000024729282F10&gt;<br/><br/>    def verify_audit_login(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = get_all_account_login()<br/><br/>All_API_Methods_Package\Audit_Module_API\Audit_API_Methods.py:104: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_all_account_login():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_audit_login_endpoint()}&quot;<br/>        print(url)<br/>&gt;       userid_data = get_user_request()<br/><br/>All_API_Methods_Package\Audit_Module_API\Audit_API_Methods.py:249: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_user_request():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_users_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Users_Module_API\Users_API_Methods.py:730: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.N_Audit_Module_API.test_audit_api.Test_Account_api object at 0x0000024718179650&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Audit_Module_API\test_audit_api.py:24: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Audit_Module_API.Audit_API_Methods.Audit_API_Methods object at 0x0000024729282F10&gt;<br/><br/>    def verify_audit_login(self):<br/>        result = []<br/>        try:<br/>            self.row = 4<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_all_account_login()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            print(response_list)<br/>            for x in range(len(self.json_response)):<br/>                result.append(self.json_response[x][&quot;accountId&quot;] != &quot;&quot;)<br/>    <br/>            if response_validation(self.response) and False not in result:<br/>                excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Audit_Module_API\Audit_API_Methods.py:131: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>https://ff-india-qa10.eastus2.cloudapp.azure.com/api/reports/audit/Login
Expecting value: line 1 column 1 (char 0)
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_audit_api.py:23 test_Account_Test_03  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/N_Audit_Module_API/test_audit_api.py::Test_Account_api::test_Account_Test_04</td>
          <td class="col-duration">2.49</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Audit_Module_API.Audit_API_Methods.Audit_API_Methods object at 0x0000024729320B50&gt;<br/><br/>    def verify_get_audit_logins(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = get_all_login_users()<br/><br/>All_API_Methods_Package\Audit_Module_API\Audit_API_Methods.py:142: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_all_login_users():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_request_audit_logins()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Audit_Module_API\Audit_API_Methods.py:265: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.N_Audit_Module_API.test_audit_api.Test_Account_api object at 0x000002472899AE50&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Audit_Module_API\test_audit_api.py:31: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Audit_Module_API.Audit_API_Methods.Audit_API_Methods object at 0x0000024729320B50&gt;<br/><br/>    def verify_get_audit_logins(self):<br/>        result = []<br/>        try:<br/>            self.row = 5<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = get_all_login_users()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            if response_validation(self.response) and False not in result:<br/>                excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Audit_Module_API\Audit_API_Methods.py:165: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>Expecting value: line 1 column 1 (char 0)
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_audit_api.py:30 test_Account_Test_04  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/N_Audit_Module_API/test_audit_api.py::Test_Account_api::test_Account_Test_05</td>
          <td class="col-duration">2.75</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Audit_Module_API.Audit_API_Methods.Audit_API_Methods object at 0x0000024729183210&gt;<br/><br/>    def verify_audit_threshold_changes(self):<br/>        result = []<br/>        try:<br/>            self.row = 6<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = verify_audit_threshold_changes()<br/><br/>All_API_Methods_Package\Audit_Module_API\Audit_API_Methods.py:176: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def verify_audit_threshold_changes():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_request_audit_threshold_changes()}&quot;<br/>        data = get_all_account_test_data(5)<br/>        request_body = {&quot;endDate&quot;: data[2], &quot;startDate&quot;: data[1], &quot;userIds&quot;: [None]}<br/>        request_data = json.dumps(request_body)<br/>        response_str = requests.post(url, request_data, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Audit_Module_API\Audit_API_Methods.py:277: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.N_Audit_Module_API.test_audit_api.Test_Account_api object at 0x0000024728998C90&gt;<br/><br/>&gt;   ???<br/><br/>D:\Git Hub\FF_Automation_Script_13_09_2023\All_API_Test_Cases_Package\Audit_Module_API\test_audit_api.py:38: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Audit_Module_API.Audit_API_Methods.Audit_API_Methods object at 0x0000024729183210&gt;<br/><br/>    def verify_audit_threshold_changes(self):<br/>        result = []<br/>        try:<br/>            self.row = 6<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = verify_audit_threshold_changes()<br/>            self.response = response_list[0]<br/>            self.json_response = response_list[1]<br/>            print(response_list)<br/>            for x in range(len(self.json_response)):<br/>                result.append(self.json_response[x][&quot;accountId&quot;] != &quot;&quot;)<br/>    <br/>            if response_validation(self.response) and False not in result:<br/>                excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>            print(ex)<br/>&gt;           excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Audit_Module_API\Audit_API_Methods.py:203: AttributeError<br/> ------------------------------Captured stdout call------------------------------ <br/>Expecting value: line 1 column 1 (char 0)
<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_audit_api.py:37 test_Account_Test_05  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/O_Integration_End_To_End/test_integration_end_to_end.py::Test_integration_api::test_integration_Test_01</td>
          <td class="col-duration">4.89</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Integration_End_To_End.integration_Methods.Integration_API_Methods object at 0x0000024729989D10&gt;<br/><br/>    def integration_end_to_end(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = integration_end_to_end_request()<br/><br/>All_API_Methods_Package\Integration_End_To_End\integration_Methods.py:34: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def integration_end_to_end_request():<br/>        result = []<br/>        response_str = &quot;&quot;<br/>        row_count = getRowCount(API_Base_Utilities.test_data_excel_path,<br/>                                Read_API_Endpoints().integration_Test_data_sheet_name())<br/>        for x in range(2, row_count + 1):<br/>            row = x<br/>&gt;           data = add_enrollment_to_alert_group_request(row)[3]<br/><br/>All_API_Methods_Package\Integration_End_To_End\integration_Methods.py:359: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row = 2<br/><br/>    def add_enrollment_to_alert_group_request(row):<br/>        token = login_token()<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().put_enrollment_group_to_alert_group()}&quot;<br/>&gt;       enrollment_group_id = create_enrollment_group_request_for_approve_en(row)<br/><br/>All_API_Methods_Package\Integration_End_To_End\integration_Methods.py:342: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row = 2<br/><br/>    def create_enrollment_group_request_for_approve_en(row):<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>        data = user_request_for_create_user_no_approve_en_right_test_data(row, 65, 74)<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_enrollment_group_endpoint()}&quot;<br/>        name = f&quot;{data[0]}{random_number()}&quot;<br/>        request_body = {&quot;name&quot;: name, &quot;description&quot;: data[1], &quot;faceThreshold&quot;: data[2], &quot;maskedFaceThreshold&quot;: data[3],<br/>                        &quot;eventsSuppressionInterval&quot;: data[4], &quot;priority&quot;: data[5], &quot;seriousOffender&quot;: data[6],<br/>                        &quot;alertHexColor&quot;: data[7], &quot;activeThreat&quot;: data[8]}<br/>        request_data = json.dumps(request_body)<br/>        response_str = requests.post(url, data=request_data, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Integration_End_To_End\integration_Methods.py:786: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.O_Integration_End_To_End.test_integration_end_to_end.Test_integration_api object at 0x000002472899F950&gt;<br/><br/>    @pytest.mark.p1<br/>    def test_integration_Test_01(self):<br/>        self.logger.info(&quot;test_integration_Test_01  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Integration_API_Methods(self.logger).integration_end_to_end():<br/><br/>All_API_Test_Cases_Package\O_Integration_End_To_End\test_integration_end_to_end.py:13: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Integration_End_To_End.integration_Methods.Integration_API_Methods object at 0x0000024729989D10&gt;<br/><br/>    def integration_end_to_end(self):<br/>        result = []<br/>        try:<br/>            self.row = 2<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = integration_end_to_end_request()<br/>            self.response = response_list[1]<br/>            if False not in response_list[0]:<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_01&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Integration_End_To_End\integration_Methods.py:54: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_integration_end_to_end.py:12 test_integration_Test_01  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/O_Integration_End_To_End/test_integration_end_to_end.py::Test_integration_api::test_integration_Test_02</td>
          <td class="col-duration">3.71</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Integration_End_To_End.integration_Methods.Integration_API_Methods object at 0x0000024728CDE550&gt;<br/><br/>    def second_integration_end_to_end_VS_with_pic(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = integration_end_to_end_VS_with_pic_request()<br/><br/>All_API_Methods_Package\Integration_End_To_End\integration_Methods.py:65: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def integration_end_to_end_VS_with_pic_request():<br/>        result = []<br/>        response_str = &quot;&quot;<br/>&gt;       start_search_resp = start_search_request(login_token())<br/><br/>All_API_Methods_Package\Integration_End_To_End\integration_Methods.py:453: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>token = &#x27;&#x27;<br/><br/>    def start_search_request(token):<br/>        image_path = f&quot;{Path(__file__).parent.parent.parent}\\API_Test_Data\\img5.png&quot;<br/>&gt;       region_id = get_user_info_request()<br/><br/>All_API_Methods_Package\Integration_End_To_End\integration_Methods.py:376: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_user_info_request():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_user_info_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Integration_End_To_End\integration_Methods.py:255: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.O_Integration_End_To_End.test_integration_end_to_end.Test_integration_api object at 0x000002472899FC90&gt;<br/><br/>    def test_integration_Test_02(self):<br/>        self.logger.info(&quot;test_integration_Test_02  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Integration_API_Methods(self.logger).second_integration_end_to_end_VS_with_pic():<br/><br/>All_API_Test_Cases_Package\O_Integration_End_To_End\test_integration_end_to_end.py:20: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Integration_End_To_End.integration_Methods.Integration_API_Methods object at 0x0000024728CDE550&gt;<br/><br/>    def second_integration_end_to_end_VS_with_pic(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = integration_end_to_end_VS_with_pic_request()<br/>            self.response = response_list[1]<br/>            if False not in response_list[0]:<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_02&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Integration_End_To_End\integration_Methods.py:85: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_integration_end_to_end.py:19 test_integration_Test_02  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/O_Integration_End_To_End/test_integration_end_to_end.py::Test_integration_api::test_integration_Test_03</td>
          <td class="col-duration">3.75</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Integration_End_To_End.integration_Methods.Integration_API_Methods object at 0x0000024729517410&gt;<br/><br/>    def third_integration_end_to_end_VS_with_pic_metadata(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = integration_end_to_end_VS_with_pic_meta_data_request()<br/><br/>All_API_Methods_Package\Integration_End_To_End\integration_Methods.py:96: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def integration_end_to_end_VS_with_pic_meta_data_request():<br/>        result = []<br/>        response_str = &quot;&quot;<br/>&gt;       start_search_resp = start_search_with_pic_metadata_request()<br/><br/>All_API_Methods_Package\Integration_End_To_End\integration_Methods.py:536: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def start_search_with_pic_metadata_request():<br/>        token = login_token()<br/>        image_path = f&quot;{Path(__file__).parent.parent.parent}\\API_Test_Data\\image.png&quot;<br/>&gt;       region_id = get_user_info_request()<br/><br/>All_API_Methods_Package\Integration_End_To_End\integration_Methods.py:560: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_user_info_request():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_user_info_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Integration_End_To_End\integration_Methods.py:255: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.O_Integration_End_To_End.test_integration_end_to_end.Test_integration_api object at 0x00000247289B8290&gt;<br/><br/>    def test_integration_Test_03(self):<br/>        self.logger.info(&quot;test_integration_Test_03  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Integration_API_Methods(self.logger).third_integration_end_to_end_VS_with_pic_metadata():<br/><br/>All_API_Test_Cases_Package\O_Integration_End_To_End\test_integration_end_to_end.py:27: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Integration_End_To_End.integration_Methods.Integration_API_Methods object at 0x0000024729517410&gt;<br/><br/>    def third_integration_end_to_end_VS_with_pic_metadata(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = integration_end_to_end_VS_with_pic_meta_data_request()<br/>            self.response = response_list[1]<br/>            if False not in response_list[0]:<br/>                excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_03&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Integration_End_To_End\integration_Methods.py:116: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_integration_end_to_end.py:26 test_integration_Test_03  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/O_Integration_End_To_End/test_integration_end_to_end.py::Test_integration_api::test_integration_Test_04</td>
          <td class="col-duration">3.87</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Integration_End_To_End.integration_Methods.Integration_API_Methods object at 0x0000024728B965D0&gt;<br/><br/>    def fourth_integration_end_to_end_VS_with_only_metadata(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = integration_end_to_end_VS_with_only_meta_data_request()<br/><br/>All_API_Methods_Package\Integration_End_To_End\integration_Methods.py:127: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def integration_end_to_end_VS_with_only_meta_data_request():<br/>        result = []<br/>        response_str = &quot;&quot;<br/>        row_count = getRowCount(API_Base_Utilities.test_data_excel_path,<br/>                                Read_API_Endpoints().integration_Test_data_sheet_name())<br/>&gt;       start_search_resp = start_search_with_only_metadata_request()<br/><br/>All_API_Methods_Package\Integration_End_To_End\integration_Methods.py:590: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def start_search_with_only_metadata_request():<br/>        token = login_token()<br/>        image_path = f&quot;{Path(__file__).parent.parent.parent}\\API_Test_Data\\image.png&quot;<br/>&gt;       region_id = get_user_info_request()<br/><br/>All_API_Methods_Package\Integration_End_To_End\integration_Methods.py:605: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def get_user_info_request():<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;}<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().get_user_info_endpoint()}&quot;<br/>        response_str = requests.get(url, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Integration_End_To_End\integration_Methods.py:255: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.O_Integration_End_To_End.test_integration_end_to_end.Test_integration_api object at 0x00000247289B8990&gt;<br/><br/>    def test_integration_Test_04(self):<br/>        self.logger.info(&quot;test_integration_Test_04  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Integration_API_Methods(self.logger).fourth_integration_end_to_end_VS_with_only_metadata():<br/><br/>All_API_Test_Cases_Package\O_Integration_End_To_End\test_integration_end_to_end.py:34: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Integration_End_To_End.integration_Methods.Integration_API_Methods object at 0x0000024728B965D0&gt;<br/><br/>    def fourth_integration_end_to_end_VS_with_only_metadata(self):<br/>        result = []<br/>        try:<br/>            self.row = 3<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = integration_end_to_end_VS_with_only_meta_data_request()<br/>            self.response = response_list[1]<br/>            if False not in response_list[0]:<br/>                excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_04&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Integration_End_To_End\integration_Methods.py:147: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_integration_end_to_end.py:33 test_integration_Test_04  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/O_Integration_End_To_End/test_integration_end_to_end.py::Test_integration_api::test_integration_Test_05</td>
          <td class="col-duration">4.68</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Integration_End_To_End.integration_Methods.Integration_API_Methods object at 0x000002472890FE90&gt;<br/><br/>    def verify_approve_enrollment_end_to_end_integration_flow(self):<br/>        result = []<br/>        try:<br/>            self.row = 6<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = approve_enrollment_end_to_end_flow()<br/><br/>All_API_Methods_Package\Integration_End_To_End\integration_Methods.py:162: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def approve_enrollment_end_to_end_flow():<br/>        result = []<br/>        row_count = getRowCount(API_Base_Utilities.test_data_excel_path,<br/>                                Read_API_Endpoints().approve_integration_Test_Data_sheet_name())<br/>        for x in range(2, row_count + 1):<br/>            row = x<br/>&gt;           data = add_enrollment_to_alert_group_request(row)<br/><br/>All_API_Methods_Package\Integration_End_To_End\integration_Methods.py:863: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row = 2<br/><br/>    def add_enrollment_to_alert_group_request(row):<br/>        token = login_token()<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().put_enrollment_group_to_alert_group()}&quot;<br/>&gt;       enrollment_group_id = create_enrollment_group_request_for_approve_en(row)<br/><br/>All_API_Methods_Package\Integration_End_To_End\integration_Methods.py:342: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row = 2<br/><br/>    def create_enrollment_group_request_for_approve_en(row):<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>        data = user_request_for_create_user_no_approve_en_right_test_data(row, 65, 74)<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_enrollment_group_endpoint()}&quot;<br/>        name = f&quot;{data[0]}{random_number()}&quot;<br/>        request_body = {&quot;name&quot;: name, &quot;description&quot;: data[1], &quot;faceThreshold&quot;: data[2], &quot;maskedFaceThreshold&quot;: data[3],<br/>                        &quot;eventsSuppressionInterval&quot;: data[4], &quot;priority&quot;: data[5], &quot;seriousOffender&quot;: data[6],<br/>                        &quot;alertHexColor&quot;: data[7], &quot;activeThreat&quot;: data[8]}<br/>        request_data = json.dumps(request_body)<br/>        response_str = requests.post(url, data=request_data, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Integration_End_To_End\integration_Methods.py:786: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.O_Integration_End_To_End.test_integration_end_to_end.Test_integration_api object at 0x00000247289B9050&gt;<br/><br/>    def test_integration_Test_05(self):<br/>        self.logger.info(&quot;test_integration_Test_04  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Integration_API_Methods(self.logger).verify_approve_enrollment_end_to_end_integration_flow():<br/><br/>All_API_Test_Cases_Package\O_Integration_End_To_End\test_integration_end_to_end.py:48: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Integration_End_To_End.integration_Methods.Integration_API_Methods object at 0x000002472890FE90&gt;<br/><br/>    def verify_approve_enrollment_end_to_end_integration_flow(self):<br/>        result = []<br/>        try:<br/>            self.row = 6<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = approve_enrollment_end_to_end_flow()<br/>            self.response = response_list[1]<br/>            if False not in response_list[0]:<br/>                excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Integration_End_To_End\integration_Methods.py:182: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_integration_end_to_end.py:47 test_integration_Test_04  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">All_API_Test_Cases_Package/O_Integration_End_To_End/test_integration_end_to_end.py::Test_integration_api::test_integration_Test_06</td>
          <td class="col-duration">4.64</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>&gt;           return complexjson.loads(self.text, **kwargs)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:971: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>s = &#x27;&#x27;, cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None<br/>object_pairs_hook = None, kw = {}<br/><br/>    def loads(s, *, cls=None, object_hook=None, parse_float=None,<br/>            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):<br/>        &quot;&quot;&quot;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance<br/>        containing a JSON document) to a Python object.<br/>    <br/>        ``object_hook`` is an optional function that will be called with the<br/>        result of any object literal decode (a ``dict``). The return value of<br/>        ``object_hook`` will be used instead of the ``dict``. This feature<br/>        can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br/>    <br/>        ``object_pairs_hook`` is an optional function that will be called with the<br/>        result of any object literal decoded with an ordered list of pairs.  The<br/>        return value of ``object_pairs_hook`` will be used instead of the ``dict``.<br/>        This feature can be used to implement custom decoders.  If ``object_hook``<br/>        is also defined, the ``object_pairs_hook`` takes priority.<br/>    <br/>        ``parse_float``, if specified, will be called with the string<br/>        of every JSON float to be decoded. By default this is equivalent to<br/>        float(num_str). This can be used to use another datatype or parser<br/>        for JSON floats (e.g. decimal.Decimal).<br/>    <br/>        ``parse_int``, if specified, will be called with the string<br/>        of every JSON int to be decoded. By default this is equivalent to<br/>        int(num_str). This can be used to use another datatype or parser<br/>        for JSON integers (e.g. float).<br/>    <br/>        ``parse_constant``, if specified, will be called with one of the<br/>        following strings: -Infinity, Infinity, NaN.<br/>        This can be used to raise an exception if invalid JSON numbers<br/>        are encountered.<br/>    <br/>        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``<br/>        kwarg; otherwise ``JSONDecoder`` is used.<br/>        &quot;&quot;&quot;<br/>        if isinstance(s, str):<br/>            if s.startswith(&#x27;\ufeff&#x27;):<br/>                raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,<br/>                                      s, 0)<br/>        else:<br/>            if not isinstance(s, (bytes, bytearray)):<br/>                raise TypeError(f&#x27;the JSON object must be str, bytes or bytearray, &#x27;<br/>                                f&#x27;not {s.__class__.__name__}&#x27;)<br/>            s = s.decode(detect_encoding(s), &#x27;surrogatepass&#x27;)<br/>    <br/>        if (cls is None and object_hook is None and<br/>                parse_int is None and parse_float is None and<br/>                parse_constant is None and object_pairs_hook is None and not kw):<br/>&gt;           return _default_decoder.decode(s)<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;<br/>_w = &lt;built-in method match of re.Pattern object at 0x0000024716487780&gt;<br/><br/>    def decode(self, s, _w=WHITESPACE.match):<br/>        &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` instance<br/>        containing a JSON document).<br/>    <br/>        &quot;&quot;&quot;<br/>&gt;       obj, end = self.raw_decode(s, idx=_w(s, 0).end())<br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:337: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;json.decoder.JSONDecoder object at 0x0000024715DE3790&gt;, s = &#x27;&#x27;, idx = 0<br/><br/>    def raw_decode(self, s, idx=0):<br/>        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with<br/>        a JSON document) and return a 2-tuple of the Python<br/>        representation and the index in ``s`` where the document ended.<br/>    <br/>        This can be used to decode a JSON document from a string that may<br/>        have extraneous data at the end.<br/>    <br/>        &quot;&quot;&quot;<br/>        try:<br/>            obj, end = self.scan_once(s, idx)<br/>        except StopIteration as err:<br/>&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None<br/><span class="error">E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\json\decoder.py:355: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Methods_Package.Integration_End_To_End.integration_Methods.Integration_API_Methods object at 0x0000024729609950&gt;<br/><br/>    def verify_disable_approve_enrollment_end_to_end_integration_flow(self):<br/>        result = []<br/>        try:<br/>            self.row = 6<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>&gt;           response_list = disable_approve_enrollment_end_to_end_flow()<br/><br/>All_API_Methods_Package\Integration_End_To_End\integration_Methods.py:193: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>    def disable_approve_enrollment_end_to_end_flow():<br/>        result = []<br/>        row_count = getRowCount(API_Base_Utilities.test_data_excel_path,<br/>                                Read_API_Endpoints().disable_approve_enrollment_data_sheet_name())<br/>        for x in range(2, row_count + 1):<br/>            row = x<br/>&gt;           data = add_enrollment_to_alert_group_request_for_disable_en(row)<br/><br/>All_API_Methods_Package\Integration_End_To_End\integration_Methods.py:899: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row = 2<br/><br/>    def add_enrollment_to_alert_group_request_for_disable_en(row):<br/>        token = login_token()<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().put_enrollment_group_to_alert_group()}&quot;<br/>&gt;       enrollment_group_id = create_enrollment_group_request_for_disable_en(row)<br/><br/>All_API_Methods_Package\Integration_End_To_End\integration_Methods.py:1017: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>row = 2<br/><br/>    def create_enrollment_group_request_for_disable_en(row):<br/>        token = login_token()<br/>        headers = {&quot;Authorization&quot;: f&quot;Token {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}<br/>        data = user_request_for_create_user_no_disable_en_right_test_data(row, 65, 74)<br/>        url = f&quot;{API_Base_Utilities.Base_URL}{Read_API_Endpoints().create_enrollment_group_endpoint()}&quot;<br/>        name = f&quot;{data[0]}{random_number()}&quot;<br/>        request_body = {&quot;name&quot;: name, &quot;description&quot;: data[1], &quot;faceThreshold&quot;: data[2], &quot;maskedFaceThreshold&quot;: data[3],<br/>                        &quot;eventsSuppressionInterval&quot;: data[4], &quot;priority&quot;: data[5], &quot;seriousOffender&quot;: data[6],<br/>                        &quot;alertHexColor&quot;: data[7], &quot;activeThreat&quot;: data[8]}<br/>        request_data = json.dumps(request_body)<br/>        response_str = requests.post(url, data=request_data, headers=headers)<br/>&gt;       response_json = response_str.json()<br/><br/>All_API_Methods_Package\Integration_End_To_End\integration_Methods.py:1038: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Response [401]&gt;, kwargs = {}<br/><br/>    def json(self, **kwargs):<br/>        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.<br/>    <br/>        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.<br/>        :raises requests.exceptions.JSONDecodeError: If the response body does not<br/>            contain valid json.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not self.encoding and self.content and len(self.content) &gt; 3:<br/>            # No encoding set. JSON RFC 4627 section 3 states we should expect<br/>            # UTF-8, -16 or -32. Detect which one to use; If the detection or<br/>            # decoding fails, fall back to `self.text` (using charset_normalizer to make<br/>            # a best guess).<br/>            encoding = guess_json_utf(self.content)<br/>            if encoding is not None:<br/>                try:<br/>                    return complexjson.loads(self.content.decode(encoding), **kwargs)<br/>                except UnicodeDecodeError:<br/>                    # Wrong UTF codec detected; usually because it&#x27;s not UTF-8<br/>                    # but some other 8-bit codec.  This is an RFC violation,<br/>                    # and the server didn&#x27;t bother to tell us what codec *was*<br/>                    # used.<br/>                    pass<br/>                except JSONDecodeError as e:<br/>                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/>    <br/>        try:<br/>            return complexjson.loads(self.text, **kwargs)<br/>        except JSONDecodeError as e:<br/>            # Catch JSON-related errors and raise as requests.JSONDecodeError<br/>            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError<br/>&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)<br/><span class="error">E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br/><br/>C:\Users\HP\AppData\Local\Programs\Python\Python311\Lib\site-packages\requests\models.py:975: JSONDecodeError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;All_API_Test_Cases_Package.O_Integration_End_To_End.test_integration_end_to_end.Test_integration_api object at 0x00000247289B9710&gt;<br/><br/>    def test_integration_Test_06(self):<br/>        self.logger.info(&quot;test_integration_Test_06  : Execution Started &gt;&gt;&quot;)<br/>&gt;       if Integration_API_Methods(self.logger).verify_disable_approve_enrollment_end_to_end_integration_flow():<br/><br/>All_API_Test_Cases_Package\O_Integration_End_To_End\test_integration_end_to_end.py:55: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;All_API_Methods_Package.Integration_End_To_End.integration_Methods.Integration_API_Methods object at 0x0000024729609950&gt;<br/><br/>    def verify_disable_approve_enrollment_end_to_end_integration_flow(self):<br/>        result = []<br/>        try:<br/>            self.row = 6<br/>            time_entry(self.row, &quot;start_time&quot;, self.sheet_name)<br/>            response_list = disable_approve_enrollment_end_to_end_flow()<br/>            self.response = response_list[1]<br/>            print(response_list[0])<br/>            if False not in response_list[0]:<br/>                excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg, True, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(True)<br/>            else:<br/>                self.log.info(f&quot;actual_status_code = {self.response.status_code}, expected_status_code = 200&quot;)<br/>                self.log.info(f&quot;actual_message = {self.act_msg}, expected_message = {self.exp_msg}&quot;)<br/>                excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code,<br/>                             self.act_msg,<br/>                             False, self.sheet_name)<br/>                time_entry(self.row, &quot;end_time&quot;, self.sheet_name), time_entry(self.row, &quot;total_time&quot;, self.sheet_name)<br/>                result.append(False)<br/>            if False in result:<br/>                return False<br/>            else:<br/>                return True<br/>        except Exception as ex:<br/>&gt;           excel_result(self.row, &quot;Test_05&quot;, self.r_body, self.json_response, self.response.status_code, self.exp_msg,<br/>                         False, self.sheet_name)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;status_code&#x27;</span><br/><br/>All_API_Methods_Package\Integration_End_To_End\integration_Methods.py:214: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_integration_end_to_end.py:54 test_integration_Test_06  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">All_API_Test_Cases_Package/A_Login_Module_API/test_login_api.py::Test_login_api::test_Login_Test_01</td>
          <td class="col-duration">3.85</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log"> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_login_api.py:12 test_Login_Test_01  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">All_API_Test_Cases_Package/A_Login_Module_API/test_login_api.py::Test_login_api::test_Login_Test_03</td>
          <td class="col-duration">3.15</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log"> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_login_api.py:28 test_Login_Test_03  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">All_API_Test_Cases_Package/A_Login_Module_API/test_login_api.py::Test_login_api::test_Login_Test_04</td>
          <td class="col-duration">4.49</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log"> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_login_api.py:36 test_Login_Test_04  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">All_API_Test_Cases_Package/A_Login_Module_API/test_login_api.py::Test_login_api::test_Login_Test_05</td>
          <td class="col-duration">3.55</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log"> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_login_api.py:44 test_Login_Test_05  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">All_API_Test_Cases_Package/B_User_Role_Module_API/test_user_role_api.py::Test_user_role_api::test_user_role_Test_01</td>
          <td class="col-duration">6.80</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log"> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_user_role_api.py:10 test_user_role_Test_01  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">All_API_Test_Cases_Package/B_User_Role_Module_API/test_user_role_api.py::Test_user_role_api::test_user_role_Test_02</td>
          <td class="col-duration">9.30</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log"> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_user_role_api.py:17 test_user_role_Test_02  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">All_API_Test_Cases_Package/B_User_Role_Module_API/test_user_role_api.py::Test_user_role_api::test_user_role_Test_03</td>
          <td class="col-duration">11.53</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log"> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_user_role_api.py:24 test_user_role_Test_03  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">All_API_Test_Cases_Package/B_User_Role_Module_API/test_user_role_api.py::Test_user_role_api::test_user_role_Test_04</td>
          <td class="col-duration">9.04</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log"> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_user_role_api.py:31 test_user_role_Test_04  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">All_API_Test_Cases_Package/B_User_Role_Module_API/test_user_role_api.py::Test_user_role_api::test_user_role_Test_05</td>
          <td class="col-duration">9.47</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log"> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_user_role_api.py:38 test_user_role_Test_05  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">All_API_Test_Cases_Package/B_User_Role_Module_API/test_user_role_api.py::Test_user_role_api::test_user_role_Test_06</td>
          <td class="col-duration">7.24</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log"> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_user_role_api.py:45 test_user_role_Test_06  : Execution Started &gt;&gt;<br/></div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">All_API_Test_Cases_Package/Detect_Face_Module_API/test_detect_faces_api.py::Test_detect_face_api::test_tags_Test_01</td>
          <td class="col-duration">7.67</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log"> -------------------------------Captured log call-------------------------------- <br/>INFO     root:test_detect_faces_api.py:9 test_detect_face_Test_01  : Execution Started &gt;&gt;<br/></div></td></tr></tbody></table></body></html>